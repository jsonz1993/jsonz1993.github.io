<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[自己的收藏夹]]></title>
    <url>%2F2018%2F11%2Fshare%2F</url>
    <content type="text"><![CDATA[一些以后可能会需要的文章 HTML5 图片上传解决方案 Blob对象]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式——刚才明明是好的]]></title>
    <url>%2F2018%2F11%2Fregexp-global%2F</url>
    <content type="text"><![CDATA[今天测试提一个jira给我，说有一个很诡异的bug，表单验证有时候会成功，有时候会失败。 而且很有规律性的，两下成功，接着失败，再两下成功，再失败…看代码也没什么问题，\S匹配任何非空字符，g全局查找，这么简单的一个正则怎么可能会出错。123456const r = /\S/g;$input.addEventListener('blur', (e)=&gt; &#123; // ... const result = r.test(e.currentTarget.value); // ...&#125;); 然后直接拿到控制台去测试，发现也有类似的问题，但是如果每次都直接调用正则表达式的test方法，又不会有问题。所以一开始怀疑是把正则对象存起来导致的。 后面在 stackoverflow和 MDN上找到真正的原因。 当设置全局标志的正则使用test()如果正则表达式设置了全局标志，test() 的执行会改变正则表达式 lastIndex属性。连续的执行test()方法，后续的执行将会从 lastIndex 处开始匹配字符串，(exec() 同样改变正则本身的 lastIndex属性值). 这意思就很明显了，我们每一次搜索匹配中之后，下次就从他的下一位开始执行搜索。 所以最后看业务场景，完全不需要加这个g，直接去掉就算fix了。当然如果你头很铁…一定要加g的话，那也可以每次执行完重置 lastIndex。1234567const r = /\S/g;$input.addEventListener('blur', (e)=&gt; &#123; // ... const result = r.test(e.currentTarget.value); if (result) r.lastIndex = 0; // ...&#125;); last 谢谢大钊子和坤少两位同事]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React源码系列]]></title>
    <url>%2F2018%2F11%2Freact-source%2F</url>
    <content type="text"><![CDATA[react16 源码阅读学习记录]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程]]></title>
    <url>%2F2018%2F09%2Ffp%2F</url>
    <content type="text"><![CDATA[本文ppt请笑纳 函数式编程维基百科对函数式编程的定义：函数式编程（英语：functional programming）或称函数程序设计，是一种编程典范，它将计算机运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。这里的函数指的是数学上的函数，既自变量（数据）的映射。 与命令式编程对比，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元(小函数)让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。 我的理解是，以纯函数（ 避免使用程序状态以及异变对象）为单元，去抽象、拆分模块功能的编程思想。其实函数式编程我们平时不陌生，比如react, redux 都多多少少有一些相关。 所以我们得出几个函数式编程的要点： 避免使用程序状态以及异变对象，数据映射=&gt; 纯函数 强调执行结果而非过程=&gt; 声明式 纯函数纯函数：输出结果只由输入决定，并且不产生副作用(effects)。 避免使用 this，window 等外部变量 没有产生副作用(Effects)，既把Effects抽离出来 Effects有哪些呢？比如 改动外部数据，发起ajax请求，改动dom等等。写过dva的就知道，dva的model有一个effects，就是用来放这些副作用的代码。 我们把Effects分离出来之后，剩下的就是纯函数，纯函数可以很简单的进行单元测试，所以是不容易出bug的，因为往往有bug的都是不可预见的部分。 举个例子123const arr=['bilibili', 'hello', 'jsonz'];arr.slice(1, 3); // 没副作用arr.splice(1, 2); // 有副作用，修改到原来的arr数组 可能会造成意想不到的bug 虽然执行之后，都能得到 Hello Jsonz。 但是 splice 会改动到原来的数组，所以不算纯函数。 工作中其实很多工具类的function都是纯函数，redux的Reducer也是标准的纯函数。 redux reducers123456function set(state, &#123; payload &#125;) &#123; return &#123; ...state, ...payload, &#125;&#125; 纯函数的好处是，你不需要担心某个值在某处发送意想不到的改变导致出bug；纯函数里不产生副作用，所以也不会担心改动到其他地方，代码更健硕；可以更优雅的组合复用，方便移植到其他环境(web workers)；方便的写单元测试。 声明式在说声明式之前，要先普及一下与之对应的命令式（指令式）。我们平时写的代码基本都是命令式，既我们通过一条一条的命令去执行一些操作，其中会涉及到很多细节的东西。既关注执行过程，用各种控制语句if...else...与for循环等。 命令式编程：命令“机器”如何去做事情(how)，这样不管你想要的是什么(what)，它都会按照你的命令实现。声明式编程：告诉“机器”你想要的是什么(what)，让机器想出如何去做(how)。 SQL语句是典型声明式，SQL存储过程和存储函数则是命令式编程。 react里面的两种编程方式12345678910111213141516171819202122// 函数式编程const data= [&#123;name: 'jsonz', age: 2&#125;, &#123; name: 'balala', age: 3&#125;, &#123; name: '小魔仙', age: 30&#125;];const dom = data.filter(item=&gt; age&lt;10) .map(item=&gt; &lt;span&gt;&#123;item.name&#125; - &#123;item.age&#125;&lt;span&gt;); // 这里后面的span是闭合的&lt;/span&gt;// 命令式编程const data= [&#123;name: 'jsonz', age: 2&#125;, &#123; name: 'balala', age: 3&#125;, &#123; name: '小魔仙', age: 30&#125;];let newData = [];for (let i= 0; i&lt; data.length; i++) &#123; if (data[i].age &lt; 10) &#123; newData.push(data); &#125;&#125;const dom2 = [];for (let i= 0; i&lt; newData.length; i++) &#123; dom2.push(`&lt;span&gt;$&#123;item.name&#125;-$&#123;item.age&#125;&lt;span&gt;`);&#125; 我们可以看出声明式的代码更加简洁清晰优雅。 声明式代码复用12345678910111213141516171819202122232425262728293031// 双倍function double(arr) &#123; const results = []; for (let i = 0; i&lt; arr.length; i++) &#123; results.push(arr[i] * 2); &#125; return results;&#125;// +1function addOne(arr) &#123; const results = []; for (let i = 0; i&lt; arr.length; i++) &#123; results.push(arr[i] +1); &#125; return results;&#125;// 声明式: 去重复代码，简洁function double(arr) &#123; return arr.map(item=&gt; item*2);&#125;function addOne(arr) &#123; return arr.map(item=&gt; item+1);&#125;// 声明式究极版： 借助 Ramdaconst m= _.curry((fn, arr) =&gt; arr.map(item=&gt; fn(item)));const double = m(item=&gt; item*2);const addOne = m(item=&gt; item+1); 这里我们可以看出一些函数式最简单的思路：把循环和判断等控制语句尽可能换成筛选 filter、映射 map、化约 reduce。 cookie获取1234567891011121314151617181920212223242526272829303132333435// 命令式// 获取cookievar _cookie = document.cookie;// cookie 的形式是字符串 "key1=value1; key2=value2; "; 把他转变成数组形式 ["key1=value1", "key2=value2"]。 用 "; "作为分隔符var _cookieArray = _cookie.split('; ');// 循环把数组里面的 key1=value1变成对象obj的key和value 方便获取var obj = &#123;&#125;;for (var i= 0; i&lt; _cookieArray.length; i++) &#123; // 取出cookie数组里面的单个: key1=value1 var cookieItem = _cookieArray[i]; // 把这个字符串key1= value1 变换成数组 [key1, value1]，用 "=" 做为分割符 var cookieItemArray = cookieItem.split('='); // [key1, value1] // 把分割好的数组，赋值给obj var key = cookieItemArray[0]; var value = cookieItemArray[1]; obj[key] = value;&#125;// 函数式document.cookie.split('; ') .map(item=&gt; &#123; const [key, value] = item.split('='); return &#123;key, value&#125;; &#125;) .reduce((acc, cur)=&gt; &#123; const &#123; key, value &#125; = cur; acc[key] = value; return acc; &#125;, &#123;&#125;); 综合 纯函数 + 声明式该部分源代码可以看这个仓库 ( ☉_☉)≡☞o────★°仓库地址 求完美数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 完全数（Perfect number），又称完美数或完备数，是一些特殊的自然数。 它所有的真因子（即除了自身以外的约数）的和（即因子函数），恰好等于它本身// 比如 6 = 1 + 2 + 3 是完美数; 8 != 1 + 2 + 4 不是完美数// &#123; let num = 6; function isPerfect() &#123; return aliquotSum() === num; &#125; function isFactor(potential) &#123; return num % potential === 0; &#125; function getFactors() &#123; const arr = []; arr.push(1); arr.push(num); for (let i= 2; i&lt; num; i++) &#123; if (isFactor(i)) arr.push(i); &#125; return arr; &#125; function aliquotSum() &#123; let sum = 0; const factors = getFactors(num); for (let i= 0; i&lt; factors.length; i++) &#123; sum += factors[i]; &#125; sum -= num; return sum; &#125; const result = isPerfect(); console.log(result);&#125;// 向函数式靠拢// 1. 将 num 变为传参 而不是外部状态// 2. 使得所有方法都变为纯函数// 3. 真因子相加改为函数式写法&#123; function isPerfect(num) &#123; return aliquotSum(num) === num; &#125; function isFactor(num, potential) &#123; return num % potential === 0; &#125; function getFactors(num) &#123; return Array.from(Array(num), (item, i)=&gt; i) .filter(v=&gt; isFactor(num, v)); &#125; function aliquotSum(num) &#123; let sum = 0; const factors = getFactors(num); for (let i= 0; i&lt; factors.length; i++) &#123; sum += factors[i]; &#125; return sum; &#125; const result = isPerfect(6); console.log(result);&#125;// 究极版&#123; const aliquotSum = num=&gt; Array.from(Array(num), (item, i)=&gt; i) .filter(item=&gt; num % item === 0) .reduce((cur, next)=&gt; cur += next); function isPerfect(num) &#123; return aliquotSum(num) === num; &#125; const result = isPerfect(6); console.log(result);&#125; 上面都是比较小的工具demo，基本上不包含Effects，但是实际上项目充斥一堆业务逻辑(Effects)，所以一般会借助一些工具/库来实现,比如 ramda.js和rx.js。 rxJs 官网的描述是 Reactive Extensions Library for JavaScript简单来说RxJS就是辅助我们写出函数式响应式代码的一种工具。 我们现在来实现一个功能，页面上有一个按钮，点击之后输出计数1234567891011121314151617181920212223// 普通版本&#123; let count = 0; const button = document.querySelector('#button'); button.addEventListener('click', ()=&gt; &#123; count += 1; // 用到外部变量 console.log(`clicked!$&#123;count&#125; times`); &#125;);&#125;// RxJs版本&#123; const &#123; fromEvent, operators: &#123; scan, &#125; &#125; = rxjs; const button = document.querySelector('#button'); fromEvent(button, 'click') .pipe( // scan 随着时间的推移进行归并。 scan((count)=&gt; count+ 1, 0) ) .subscribe(count=&gt; console.log(`clicked! $&#123;count&#125; times`));&#125; 节流和累加点击坐标1234567891011121314151617181920212223242526&#123; let count = 0; const button = document.querySelector('#button'); const rate = 1000; let lastClick = Date.now() - rate; button.addEventListener('click', (e)=&gt; &#123; if (Date.now() - lastClick &gt;= rate) &#123; count += e.clientX; console.log(`clicked!$&#123;count&#125; times`); lastClick = Date.now(); &#125; &#125;);&#125;&#123; const &#123; fromEvent, operators: &#123; scan, throttleTime, map &#125; &#125; = rxjs; const button = document.querySelector('#button'); fromEvent(button, 'click') .pipe( throttleTime(1000), map(e=&gt; e.clientX), scan((count, clientX)=&gt; count+ clientX, 0) ) .subscribe(count=&gt; console.log(`clicked! $&#123;count&#125; times`));&#125; 接下来我们用Ramda.js来实现一个页面，获取某个关键字图片，并展示出来。Ramda主要帮忙实现一些 curry, compose 等功能 12345678910111213141516171819202122232425262728293031323334353637383940414243444546requirejs.config(&#123; paths: &#123; ramda: 'https://cdnjs.cloudflare.com/ajax/libs/ramda/0.13.0/ramda.min', jquery: 'https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min' &#125;&#125;);require([ 'ramda', 'jquery' ], function (_, $) &#123; // 我们把不纯的Effects抽出来 const Impure = &#123; getJSON: _.curry((callback, url)=&gt; $.getJSON(url, callback)), setHtml: _.curry((sel, html)=&gt; $(sel).html(html)), &#125;; // 传入url 生成 img dom const img = function(url) &#123; return $('&lt;img /&gt;', &#123; src: url &#125;); &#125;; // 获取传入参数的 media 属性，以及获取 media属性上的 m。 等价于 arg.media.m const mediaUrl = _.compose(_.prop('m'), _.prop('media')); // 获取传入参数的 item 属性，以及对每个item执行 mediaUrl 函数 const srcs = _.compose(_.map(mediaUrl), _.prop('items')); // 把img和srcs函数整合起来 const images = _.compose(_.map(img), srcs); const url = term=&gt; `https://api.flickr.com/services/feeds/photos_public.gne ?tags=$&#123;term&#125;&amp;format=json&amp;jsoncallback=?`; // 把imges获取到的参数传给 Impure.setHtml('body'); const renderImages = _.compose(Impure.setHtml('body'), images); // 把所有小函数整合成一个大的函数，我们只需要给这个app喂数据即可 const app = _.compose(Impure.getJSON(renderImages), url); app('cat');&#125;); 优化1234567891011// old const mediaUrl = _.compose(_.prop('m'), _.prop('media')); const srcs = _.compose(_.map(mediaUrl), _.prop('items')); const images = _.compose(_.map(img), srcs); // new const mediaUrl = _.compose(_.prop('m'), _.prop('media')); const images = _.compose(_.map(img), _.map(mediaUrl), _.prop('items')); 再优化1const images = _.compose(_.map(_.compose(img, mediaUrl)), _.prop('items')); 函数式和面向对象对比面向对象编程思想，封装 继承 多态。 把状态的改变封装起来，让代码更加清晰，通过类与继承去处理关联关系。但是会充满公用变量，this，bind等。 面向对象目前更加广泛，而且更容易被接受，写起来更容易，但可能会有更多冗余的代码，捆绑了很多状态，典型的问题是 你只需要一个香蕉，但是却得到一个拿着香蕉的大猩猩以及整个丛林。 函数式编程思想，尽量减少不确定因素，来让代码更加清晰健硕。 每个函数都不要去修改原有的数据，而是通过产生新的数据来做为运算结果，这也意味着函数式比较耗资源，所以在计算机石器时代并不流行。 简单来说就是很多小的纯函数，一个小函数只做一些事情，然后用这些小函数来组织成更大的函数，函数的参数与返回值也大部分都是函数。最后能得到一个超级牛逼的函数，我们只要把数据给他，就可以了。 函数式简洁，清晰可复用性高，出错几率更小。但是一开始思维很难从面向对象或命令式转换过来，往往也需要借助一些工具库来编写。 结语这里只提了函数式编程的一些思想，但是真正函数式开发还包含很多其他要学的。比如我们用到的柯里化curry还有代码组合compose等，光RxJs提供的api就有179个之多… 再者不知道是不是对函数式的理解不够透彻，有试过某个需求用函数式的思想去写，但是有点好像硬掰的样子，写的有点不伦不类….所以现在只是吸收一些函数式的思想（比如纯函数减少不确定性），但是平时工作不会很刻意全部都用函数式去写。只是当成一个可以扩展的知识面，后面如果函数式真的在前端流行起来，再上手也不迟。 顺路感慨JS的灵活性，既有ES6面向对象的特性class也有ES5的 filter、map、reduce，以及ES.Next的装饰器(Decorator)等函数式编程的特性。 最后再给出参考的以及学习过程看到的一些不错的书籍和文章: JS 函数式编程指南深入浅出Rxjs函数式编程思维命令式、声明式、面向对象、函数式、控制反转之华山论剑（上）RxJs 响应式代码库Ramda 函数式工具库Haskell 纯函数式编程语言什么是函数式编程思维函数式编程术语解析]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道赋值面试题引发的思考]]></title>
    <url>%2F2018%2F07%2Fcircular-reference%2F</url>
    <content type="text"><![CDATA[本篇主要说一些基础知识点，关于多项赋值顺序，对象引用等，期间插入一点es6只是以及解决问题的思路。 开头先来做一道面试题 part112345var a=&#123;n:1&#125;;var b=a;a.x=a=&#123;n:2&#125;;console.log(a.x);console.log(b.x); 最后输出的是什么？ 先不说答案，我们来分析一下 L2(第二行) 我们把a赋值给b， 由于a是对象类型，这就意味着b和a指向同一个内存地址 L3 a.x = a = { n: 2} 这里我们有个疑惑，这句语句执行顺序是 a = {n: 2} &amp;&amp; a.x = {n:2} 还是 a.x = {n:2} &amp;&amp; a= {n:2} 还是这种 a = {n: 2} &amp;&amp; a.x = a 我们这里可以借助 Object.defineProperty 或 ES6的 Proxy来验证多项赋值的顺序是怎样的 123456789101112131415const obj = new Proxy(&#123;&#125;, &#123; set(target, key, value, r) &#123; console.log(key, value) if (key === 'a') Reflect.set(target, key, 'isA', r); else Reflect.set(target, key, value, r); &#125;&#125;);obj.b = obj.a= &#123;n: 1&#125;;// 输出:// "a" &#123;n: 1&#125;// "b" &#123;n: 1&#125;obj.a; // isAobj.b; // &#123;n: 1&#125; 所以我们可以得出 赋值的顺序是从右边开始到左边的。而且是直接 a = {n: 1}, a.x = {n:1 }，而不是 a.x = a 这样去赋值 现在我们再借助 Proxy 来分析一开始part1这道题，用obj.a, obj.b 来代替原题目的 a和b。 1234567891011121314var obj = new Proxy(&#123;&#125;, &#123; get: function (target, key, receiver) &#123; console.log(`getting $&#123;key&#125;!`); return Reflect.get(target, key, receiver); &#125;, set: function (target, key, value, receiver) &#123; console.log(`setting $&#123;key&#125;!`); return Reflect.set(target, key, value, receiver); &#125;&#125;);obj.a = &#123;n: 1 &#125;;// getting a;obj.b = obj.a; // getting a; setting b;obj.a.x = obj.a = &#123;n:2 &#125;; // getting a; setting a; 可以看到 obj.a.x = obj.a = {n: 2}这段语句执行时，会先输出一个 getting a 再输出 setting a。这就意味着在对 obj.a.x 赋值时，程序是先获取 obj.a指向的对象的内存地址，此时触发了 getting a，然后再对右边 obj.a 进行赋值，触发了 setting a， 赋值完最后一步才是对 obj.a.x赋值 {n:2 }。 重点: 在对obj.a.x赋值的时刻已经获取了obj.a该对象指向的内存地址，所以后面a就算指向其他地址，也和这里的obj.a.x无关。此时指向该地址的还有obj.b 我们再用三张图来捋一捋整理的思路 执行 obj.a = {n: 1}; obj.b = obj.a后obj对应的引用是这样的 执行 obj.a.x = xxx 时 执行obj.a.x = obj.a = {n:2} 后 至此，这道面试题相信大家都有答案了，可以自己去控制台验证一下。 假如这时候再执行 obj.a.n = 3， 打印obj.b会输出什么呢？ part2接下来我们来看另一道题，关于对象循环引用的 12var a = &#123; n: 1&#125;a.b = a; 这里的a明显是循环引用，那么我们要怎样才能判断一个对象是否是循环引用呢？ 其实这道题我一开始除了递归判断外没有很好的解决方案，后面是群里一个叫话费的大佬说(这道题也是他出的)直接用 JSON.stringify，微信小游戏的源码里面就是这么去判断。 JSON.stringify 如果遇到参数里有循环引用的，就会抛出一个循环调用的错误 Uncaught TypeError: Converting circular structure to JSON 那如果不用JSON.stringify或者想要自己实现一个去检测循环调用，该怎么写呢？（面试官和部门前端leader最喜欢这么问） 一般遇到这种，最简单的方法就是去找这个方法的 polyfill， json3。我找的是 json3的 polyfill 里面大概是遍历对象存到stack数组，再在解析的时候去判断是否有循环引用的情况。 json3.js#L482 照着他的思路大概写了一个，其实就是前面说到的简单递归判断123456789101112var stack = [];function fn(obj) &#123; var len; for (len = stack.length; len--;) &#123; if (stack[len] === obj) throw TypeError() &#125; stack.push(obj); for (let k in obj) &#123; const value = obj[k] if (typeof value === 'object') fn(value); &#125;&#125; 第一次讲关于语言知识点的，如果发现有错误的地方 欢迎指出~最后谢谢惠顾，请笑纳]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视频转字符画]]></title>
    <url>%2F2018%2F07%2Fvideo-to-chat%2F</url>
    <content type="text"><![CDATA[先看一下效果，原视频是这样的 我们要实现的效果是这样子的，之所以找这个视频是因为…这个视频和背景的对比度比较高做出来比较有辨识度，没有其他的意思 ( *・ω・)✄╰ひ╯ 起因某天一个基友在群里问我，在抖音看到一种视频，问我是不是能实现。我说可以的~于是当天晚上花了一个多小时折腾了一个粗糙版本… 先把视频丢到部门技术群问有没有关键字，给了一个keyword 图片转字符串 于是照着这个思路去gayhub找资源拼乐高！ 整体思路 第一步我们通过 input[type=&quot;file&quot;] 获取文件 拿到文件之后，用 URL.createObjectURL来获取视频的路径 通过 ctx.drawImage 我们可以把某个 video 当前的图像渲染到 canvas里面 ctx.getImageData 可以获取当前canvas 里面图片的色值，利用公式计算出灰度 根据灰度的深浅去匹配要显示的字符，深色匹配比较密集的字符，最浅的直接用空格代替，然后用 ctx.fillText重绘进去 设置 video.currentTime 来获得视频的某一时刻图像，重复上述重绘过程 既然大概的思路已经理清，接下来就是具体的编码，把想法写出来的过程 具体编码实现获取视频文件首先我们先确定下html需要哪些元素 一个 input[type=”file”] 用来给用户上传的 一个 video 用来承载上传的video 一个 canvas 用来展示最终的结果 大概是长这样：index.html123&lt;input type="file" id="inputFile" accept=".mp4" /&gt;&lt;canvas id="canvasShow"&gt;&lt;/canvas&gt;&lt;video id="video"&gt;&lt;/video&gt; 接下来js文件，我们要先对 input 绑定个监听事件，拿到文件url之后设置给video这里要注意两点，一个是 url用完不用的话，用 URL.revokeObjectURL 释放资源； 一个是我们这里用了 await 在domVide.onCanplay之前不做任何操作，防止视频没有加载完就操作，有黑屏风险。 如果对 es6、es7、es8不熟悉的小伙伴要去补一下了~ 现在基本不会这些基本语法都看不懂demo= =附上阮一峰老师的ES6教程，又想起面试被问ES7有什么新特性 简直是*了狗index.js1234567domInput.addEventListener('change', async(&#123;target: &#123;files &#125;&#125;)=&gt; &#123; const file = files[0]; const url = URL.createObjectURL(file); domVideo.src = urlrl; await new Promise(res=&gt; domVideo.addEventListener('canplay', res)); // next ====&gt; handleVideoInit()&#125;); 将视频渲染到canvas拿到视频之后，我们要把当前这一个时刻的图像渲染到canvas里面先用ctx.drawImage(video, 0, 0, width, height) 把video dom当前屏渲染进canvas再用ctx.getImageData(0, 0, width, height) 获取图片的色值来做处理可以通过调整 img2Text 来选择渲染出来的图片是想要怎样的(由哪些字符组成等等)比如把 textList改为 [‘Aa’, ‘Bv’, ‘Cc’, ‘Dd’, ‘#’, ‘&amp;’, ‘@’, ‘$’, ‘*’, ‘?’, ‘;’, ‘^’, ‘·’, ‘·’, ‘·’, ‘·’]，辨识度会高一点 index.js handleVideoInit123456789101112131415161718192021222324252627282930313233343536/*domVide =&gt; video元素size =&gt; 存放video等元素的长宽canvasVideo =&gt; 存放video当前的图像的canvascanvasShow =&gt; 存放最后展示效果的canvas*/const size = &#123;w: 0, h: 0&#125;;const canvasVideo = document.createElement('canvas');function handleVideoInit() &#123; domVideo.currentTime = 0; size.w = domVideo.width = canvasVideo.width = canvasShow.width = domVideo.videoWidth * .5; size.h = domVideo.height = canvasVideo.height = canvasShow.height = domVideo.videoHeight * .5; video2Img();&#125;function video2Img() &#123; const &#123; w, h &#125; = size; ctxVideo.drawImage(domVideo, 0, 0, w, h); const &#123; data &#125; = ctxVideo.getImageData(0, 0, w, h); ctxShow.clearRect(0, 0, w, h); for (let _h= 0; _h&lt; h; _h+= 8) &#123; for (let _w= 0; _w&lt; w; _w+= 8) &#123; const index = (_w + w * _h) * 4; const r = data[index + 0]; const g = data[index + 1]; const b = data[index + 2]; const gray = .299 * r + .587 * g + .114 * b; ctxShow.fillText(img2Text(gray), _w, _h + 8); &#125; &#125;&#125;function img2Text(g) &#123; const i = g % 16 === 0 ? parseInt(g / 16) - 1 : parseInt(g/ 16); return ['#', '&amp;', '@', '%', '$', 'w', '*', '+', 'o', '?', '!', ';', '^', ',', '.', ' '][i];&#125; 到这一步，其实已经实现了把一张图片变为字符填充图了,剩下的工作无非就是把视频变成一张张的图片，然后重复执行这些逻辑 持续调用渲染字符视频我们改一下 video2Img 函数，将其实现为能持续调用的形式， 再添加一个函数 clear 用来清理垃圾 这里用到的是 window.requestAnimationFrame 去持续调用index.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546function video2Img(&#123; timePoint= 0, curT= Date.now(), prevT= Date.now(), prevInterval,&#125;) &#123; const &#123; w, h &#125; = size; ctxVideo.drawImage(domVideo, 0, 0, w, h); drawOnce(); let _interval = Math.max((curT - prevT), 16) / 1000; if (curT - prevT !== 0) _interval -= prevInterval; await new Promise(res=&gt; setTimeout(res, _interval*1000)); const nextTimePoint = _interval + timePoint; if (nextTimePoint &gt; domVideo.duration) return clear(); tId = window.requestAnimationFrame(()=&gt; video2Img(&#123; timePoint: nextTimePoint, prevT: curT, curT: Date.now(), prevInterval: _interval, &#125;)); &#125;function drawOnce() &#123; const &#123; data &#125; = ctxVideo.getImageData(0, 0, w, h); ctxShow.clearRect(0, 0, w, h); for (let _h= 0; _h&lt; h; _h+= 8) &#123; for (let _w= 0; _w&lt; w; _w+= 8) &#123; const index = (_w + w * _h) * 4; const r = data[index + 0]; const g = data[index + 1]; const b = data[index + 2]; const gray = .299 * r + .587 * g + .114 * b; ctxShow.fillText(img2Text(gray), _w, _h + 8); &#125; &#125;&#125;function cleart() &#123; const &#123;w, h&#125; = size; lastUrl &amp;&amp; URL.revokeObjectURL(lastUrl); tId &amp;&amp; window.cancelAnimationFrame(tId); ctxShow.clearRect(0, 0, w, h); ctxVideo.clearRect(0, 0, w, h);&#125; 源码与demo至此，功能基本都实现了，下面提供在线的呆毛和github仓库地址~ 在线呆毛github 源码video转图片忘了是在github看哪个项目的，ctx.drawImage(video, 0, 0, width, height)这个是看完才知道的。 图片转字符基本是看这个大哥的github 在找方案的时候看到的一个像素图实现，挺有趣的，以前实现马赛克是拿周围像素值取平均去做，这个哥们是直接放大截图 更简单粗暴传送门]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>github</tag>
        <tag>JavaScript</tag>
        <tag>Canvas</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-07-27 小记]]></title>
    <url>%2F2018%2F07%2F2018-07-27%2F</url>
    <content type="text"><![CDATA[上一篇文已经是一个月前的，还是改不了懒的习惯 习惯性对最近做一些总结，关于面试，关于工作上，关于最近学习的东西。 关于面试记得从四月尾就一段时间去面一次，现在已经确定继续留在租租车。顺路捣鼓一些东西，考考专升本。 自荔枝之后面了四家 cvte 阿里外包 YY 车主无忧 cvtecvte 我都忘了有投他公司简历，一天晚上看书，突然就来了个电话说是xxxx的xxx，来进行电话面试。然后就稀里糊涂聊了半个多小时，之后就说等hr电话。 hr电话聊了下加班情况，企业文化，福利等东西。 其实之前就一直听说cvte很封闭，又很传统，加班贼疯狂，企业文化又很那啥，所以打心里不会去那里 所以hr面的时候，也没有怎么回答，但是有一点是cvte居然是没有薪资保密的，所以我就顺路问了hr的薪资看是不是真的像他说的一样 薪资允许讨论。结果估计因为这个得罪了hr= =没有过hr面 阿里外包阿里外包其实是最意外的一家是武汉一家公司联系上的，联系之后想着去试一下阿里的面试到底是怎样的 所以就答应了hr非常的好，面试前再三叮嘱，也把面试官看完简历的反馈告诉了我还让同事提前面我一轮，面完说 没什么问题 面试当天聊了下项目经验还有基础知识和一些问题的排查思路 本以为答的挺不错的，和面试官也聊得很愉快。后面面试官说去找老大来面，让我骚等片刻 过段时间后说老大在开会，让我回去等通知…现在想起才知道原来老大在开会是一个拒绝人的套路 图样图森破 去阿里面想起了一年前去面uc，那时候也面得很开心，后面得知是应聘外包岗就没怎么想继续下去… 但是阿里的面试官给我的感觉没有像一些小公司的人一样，给人的感觉是很亲切的。和我说如果想进某个大公司，最简单的方法就是参与该公司的开源项目，这是收获最大的一个点。 虽然过了不会去，但是总体来说还是很意外。 车主无忧车主无忧这个就比较尴尬了，是在公司同一栋…面试大概的感觉就是挺容易的，面试官问的问题都是针对项目经验，所以基本没有造假划水就没什么问题。面三四轮，技术面面前端Leader，技术二面面部门负责人，然后就是cto面，面完hr和我说不能给我期望薪资三年最多只能给xxk…说一开始以为我是有三年半经验，所以可以给四年的薪资后面接了offer考虑下完全不值得跳就放弃 但是车主无忧有个题外话，和hr聊天聊很久，hr说 之前租租车有高级前端来面试给出的评价是很水，所以对我原本的不抱什么希望。但是技术面给的评价是很不错，所以有点惊讶租租车内部的水平差异大。 YY UED面YY是最近最开心，收获最大的一次面试。UED当时面试的时候只有四个前端，我总共面了五轮？基本上就是部门轮着人来虐我= = 一面和leader聊聊天，说一些场景的解决方案 然后就是笔试题，做完之后就是面三面。 三面和部门一个技术大牛聊聊天，聊框架居多，一个vue的人 对react了解比我深很多，这是挺佩服的他有个评分标准，大概就是想招vue 6分以上，以写写demo看看api为1分；能保证项目正常上线5分；熟悉整个框架结构原理，遇到问题能准确知道是在哪个环节出问题，对整个生命周期及运转很熟悉为6分；对整个vue生态都很了解，精准到每次迭代改动的源码部分，还有vuex等生态也很关注为10分。大牛说我是面过的同等工作年限的中上水平，这句话让我开心了好久好久….哈哈哈哈给出的评价是各方面都很均衡，没什么明确的缺点，但是这也意味着没有一个能拿出来讲的有深入研究的方向。最后让我回去等通知 几天后hr打电话说过去面试，开心。四面是部门另一个前端面试，聊了一些基础知识吧，还有一些场景和概念性的问题。具体问什么忘了，只记得聊的也挺愉快的。面完之后是leader下来闲聊一下，问还有什么问题，没有就面hr了 hr面是在yy面试最累的一个，全程hr拿着小本本，边问边记。可能是前面和技术小伙伴聊得比较open，到hr这边突然变得谨慎了，所以面完hr之后 整个人都好累。也是很传统的问了以前的公司，为什么跳槽啊之类的。 有一些不一样的就是问我怎么保证有持续的产出和能保持高效长期学习，因为UED是需要不断的探索前瞻技术的，还有就是问我有没有blog，多少人订阅…emmmm 我说我的博客没人订阅没人看，自己写着玩 🤦‍ 过了几天后hr打电话聊offer，总体来说比现在的高了不少，算是很满意的一个offer了。 本来铁了心要过去那边浪，毕竟部门的同事基本都见了一遍 哈哈哈哈，然后offer又比较心水。 后面因为个人原因选择继续留在租租车，但是如果在以后有机会，还是会优先考虑yy的。 关于工作项目拆包既然选择留在租租车，肯定就不能像之前半年划划水就过去 最近工作上主要负责的是，想着把部门的项目做个拆包 原本小项目慢慢迭代成很大的项目，一次打包要花半个小时….加上现在目录的问题，每天过来都要打一个全量包。 所以现在的计划是，对项目模块进行拆包，一个模块独立成一个项目，有自己的node_models，但是共用一个git。 这个其实从半年前就有人提出来，但是太难搞了 所以一直没人去推 首先要考虑的是部门不可能停掉日常迭代，来等你拆包。而且你的需求也不会因为这个技术需求而减少，所以要在平时做需求的间隙做这件事情。 尽可能把路径替换，文件迁移等做成脚本去跑，不然做不下去。而且拆包之后，要考虑后端的模板路径问题还有部署的问题，加上一些前端 pwa,amp的构建考虑真是个大工程… 最近的成果是本地能跑起来，但是还缺一个 本地服务，加上还没有和后端，部署那块沟通。 任重道远 下半年的指标下半年，老大给定的技术指标是React和Webpack两项 其实原本给的是Http和浏览器内核，但是我觉得说现在我去了解那两块没什么大的收获。 加上在yy面试之后，面试官一直给的评价是没有一个很深入的点，所以就选了React去做深入的方向。 React探索之余了解Webpack和 PWA部分 关于webpack前几天有个需求是项目上用到的cookie都要记录到某个文档里面，一开始想着写一个webpack插件去做这件事情。 项目的webpack是3.x，官方的文档全都升级到4.x，一开始有点蛋疼，也没有一个比较适合入门的demo，要不就是太简单，要不就是很复杂的。 后面终于大概跑了起来，但是跑起来之后，发现和预想的不一致。为什么呢？ 文档需要记录的是 key value description, 举个例子cookie.set(‘name’, ‘jsonz’, ‘用户名’); 我的方案是在webpack编译的时候拿到babel转义和代码压缩优化之前的内容，因为项目上涉及到cookie的操作都会用一个 cookie-js 的类库，所以可以利用这个做为切入点。 大概的思路是： webpack生命周期里面去拿到源文件，然后用一个语法分析树，解析成AST，再根据类型去筛选出 cookie-js 函数调用传入的参数 本来觉得天衣无缝，但是理想很天真，实际项目上五花八门，比如1234567891011import Cookie from 'Cookie-js';const cookie = require('Cookie-js');const key = IS_DEV? '_name': 'name';const value = JSON.parse(Cookie.get('obj')).name;Cookie.set(key, value, '名字');cookie.set('user', &#123; name: 'jsonz', age: 25&#125;); 所以其实如果真的要用脚本记录，只能在运行环境下记录，所以放弃这个方案…. 关于捣鼓小程序前段时间是自己捣鼓了一个小程序，用来给每天做计划的。大概长这样 技术栈:前端: 用的是美团的 mpvue，暂时发现其实和写vue很多不一样，因为有很多可能是小程序的局限问题，也可能是转换问题，n多莫名其妙的bug而且还无法正面干。 后端:Node: 做主要服务端语言，用的阿里Egg.js框架MySQL: 为什么选择MySQL而不是前端(node)惯用的mongodb呢？ 主要原因有两个，一个是mongo体验过了；一个是现在业界其实mySql还是占绝大多数，而且比较成熟，想体验一波关系型数据库。 服务器：Nginx: 没什么好说的，对于一个没有折腾过的人来说还是挺开心的Centos 看起来是挺简单的，但是对于个人学习来说是个挺好的项目。特别是一个完全没有真正捣鼓过后端，服务端的人来说，真的很happy，比单纯写前端要考虑的事情多很多。 但是最近因为工作的事情，暂时搁置一边，目前还是 0.0.1 可以用最简单的计划的功能。后面拆包完成之后就回来加功能再发布 图片转字符前几天有高中好朋友在群里发一个视频，问我们说真的是可以这样的吗？ 原视频是死肥宅都知道的极乐净土，然后我觉得很有趣，就问公司群这种怎么实现，大概是图片转字符串于是就去搜了一下 canvas 转字符串，再找了下怎么把视频转图片 🤦‍没错，我就是大自然的搬运工最后实现出来大概是这样子 大概的实现思路是 通过video和canvas把视频逐帧丢到canvas里面，再用canvas读出每个像素的灰度去匹配一个字符串，然后用这些字符串重写一个canvas出来。 后面有时间再把这个整理成一篇文章出来 关于学习最近是有点懒惰了，专升本一直看离散数学，原本预计7月份要看完顺路做一套题，现在怕是要延迟一个星期最少。看完还有万恶的网络原理和数据库原理… 加油💪 最后附上周末团建的图]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window.print——关于浏览器打印]]></title>
    <url>%2F2018%2F06%2Fwindow-print%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%8D%B0%2F</url>
    <content type="text"><![CDATA[近日有个需求是做页面打印的，趁这个机会补一下比较冷门的浏览器打印知识。本文主要讨论 Chrome、Safari、Firefox浏览器的情况。 打印接口首先浏览器打印是一个很成熟的应用~ 至少是很早就已经有应用的功能，所以不会有什么兼容问题 最简单的打印就是直接调用 window.print()，当然用 document.execCommand(&#39;print&#39;) 也可以达到同样的效果。 这时候在Safari和Chrome都会弹起打印预览的窗口,FireFox没有预览而是直接让你选择打印机，OSx下可以通过预览PDF来预览~ 一般这种直接在网页上调用 print 的方法是没办法满足我们的业务需求，比如说： 调整布局和字体大小来适应A4纸 打印的时候用不同的样式风格 使用更高清的图片来打印 某一些不相关的东西不出现在打印中等等等等 那么有哪些方法可以帮助我们改善打印的用户体验呢？ 使用 print style sheet (打印样式表)我们可以在 link 上加上一个 media=”print” 来标识这是打印机才会应用的样式表, 如: 1&lt;link href="/example.css" media="print" rel="stylesheet" /&gt; 这样打印的时候，就会默认将该样式表应用到文档中 使用媒介查询兼容性: IE9+ 其他主流浏览器都支持当我们要修改的样式没有那么多的时候，其实完全不需要重新写个样式表，只要写上一个媒介查询也可以达到同样的效果，如: 12345678h1 &#123; font-size: 14px;&#125;@media print &#123; h1 &#123; font-size: 20px; &#125;&#125; 事件监听beforeprint &amp;&amp; afterprint有两个事件可以监听到到打印事件，一个是beforeprint,一个是afterprint，分别表示打印事件触发前后。这个事件在 IE6 就已经支持了，不过一点都不惊讶~ 毕竟IE很早就支持很多接口调用，之前好像做过IE打开Excel的需求~兼容大概是 Firefox、IE全支持, Chrome63+支持, Safari暂不支持，算是一半一半吧。123456window.addEventListener('beforeprint', ()=&gt; &#123; document.body.innerHTML = '正在打印...';&#125;);window.addEventListener('afterprint', ()=&gt; &#123; document.body.innerHTML = '打印完成...';&#125;); window.matchMedia 测试媒体查询接口如果你想要兼容Safari或许可以试一下 window.matchMedia兼容是 IE10+，其他主流浏览器完全没问题。 这个的用法稍微有点不一样，首先创建一个MediaQueryList对象，再通过他监听变化，如:12345const printMedia = window.matchMedia('print');function printChange(&#123; matches, &#125;) &#123; document.body.innerHTML = matches? '正在打印...': '打印完成/取消';&#125;printMedia.addListener(printChange); 更加个性化定制打印区域/打印内容如果项目上用的是jq等，或者想简单粗暴的打印某个区域又不想重新写样式表啊，什么的。最傻瓜版的方式就是直接用jq插件 jQuery.print 也可以自己写一个去处理，大概的思路是创建一个iframe，把要打印的dom和样式表都丢进去，再调用iframe的打印事件。 这里写一个简单的 demo 1234567891011121314151617181920212223242526272829303132333435363738394041function printPartial(dom, &#123; title= document.title,&#125;= &#123;&#125;) &#123; if (!dom) return; let copyDom = document.createElement('span'); const styleDom = document.querySelectorAll('style, link, meta'); const titleDom = document.createElement('title'); titleDom.innerText = title; copyDom.appendChild(titleDom); Array.from(styleDom).forEach(item=&gt; &#123; copyDom.appendChild(item.cloneNode(true)); &#125;); copyDom.appendChild(dom.cloneNode(true)); const htmlTemp = copyDom.innerHTML; copyDom = null; const iframeDom = document.createElement('iframe'); const attrObj = &#123; height: 0, width: 0, border: 0, wmode: 'Opaque' &#125;; const styleObj = &#123; position: 'absolute', top: '-999px', left: '-999px', &#125;; Object.entries(attrObj).forEach(([key, value])=&gt; iframeDom.setAttribute(key, value)); Object.entries(styleObj).forEach(([key, value])=&gt; iframeDom.style[key] = value); document.body.insertBefore(iframeDom, document.body.children[0]); const iframeWin = iframeDom.contentWindow; const iframeDocs = iframeWin.document; iframeDocs.write(`&lt;!doctype html&gt;`); iframeDocs.write(htmlTemp); iframeWin.focus(); iframeWin.print(); document.body.removeChild(iframeDom);&#125;printPartial(document.querySelector('#description')); 最后一些注意的事情 打印会打印document下所有可见元素， 包括 &lt;header&gt; 里面的 背景都不会被打印出来，包括背景色啊背景图片啊等等 如果图片是懒加载的，需要特殊处理，不然打印的时候会直接空白 参考:https://blog.csdn.net/fengshuiyue/article/details/57483057Mozilla printMozilla Using_a_print_style_sheet]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP常用知识点总结]]></title>
    <url>%2F2018%2F05%2Fhttp-mini-book%2F</url>
    <content type="text"><![CDATA[同样是因为面试的过程中，发现自己对http的一些概念和知识点和零碎，借此机会看了《HTTP小书》，顺手写了篇记录总结一些常见的http知识点。 http 简介请求:客户端软件打开到服务器的连接，发起请求如下：12345GET /hello.htm HTTP/1.1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36Host: example.comAccept-Language: en-usAccept-Encoding: gzip, deflate 响应:服务端收到请求消息后根据资源定位符在服务器找到该资源，并响应给客户端:123456789HTTP/1.1 200 OKX-Powered-By: ExpressContent-Type: text/html; charset=utf-8Content-Length: 22ETag: W/&quot;16-dDTk/xb5lvRNBfrz6lE//HVBox8&quot;Date: Tue, 22 May 2018 03:04:08 GMTConnection: keep-alive&lt;h1&gt;Hello, Jsonz!&lt;/h1&gt; 请求消息请求信息一般由请求行、头部字段区、CRLF与消息主体（可选）组成 请求行请求消息的第一行称为请求行，一般包括 请求方法， 请求资源标识符 还有请求的协议版本 Request-List = Method SPACE Request-URI SPACE HTTP-Version CRLF 请求方法比较常用的有 GET, POST。 这里用的是GET 发起一个请求获取资源 GET 请求一个制定名称的资源 POST 创建一个新的子资源，或者更新一个存在的资源 PUT 指定的URL不存在则创建，存在则修改 DELETE 删除指定资源 OPTIONS 返回服务器支持的方法 CONNECT、TRACE 对于 POST 和 PUT的选择，作者给出的例子是创建订单PUT /other/1 创建单号为1的订单，如果存在就更新他，订单号由客户端提供POST /other 创建订单，订单号由服务端提供POST /other/1 更新订单，如果不存在应该抛错重复执行PUT请求不会影响服务器状态，而POST则会导致创建两个订单 但是工作中，几乎只用过GET和POST，对于创建订单的例子中，PUT和POST的区别我的理解比较浅显，一个是客户端/服务端提供订单号，一个是语义化。 头部字段从第二行到空行之间都属于头部字段区，用来传递更多详细的信息，这个案例里面是1234User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36Host: example.comAccept-Language: en-usAccept-Encoding: gzip, deflate 比如说这里:User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36 我们可以知道客户端用的是 Mac OSx系统，Chrome v66.0.x版本的浏览器Accept-Language: en-us 语言是英语Accept-Encoding: gzip, deflate 支持的压缩编码为gzip和deflate 空行(CRLF)空行也叫CRLF，是隔开请求头与请求主体的 消息主体发送给服务端的消息，比如用POST方法提交表单时，表单的内容就是存在消息主体里面。如果是用GET方法就会丢到请求URL里 响应信息响应信息和请求信息的组成结构相似，由状态行、头部字段行、空行（CRLF）和消息主体构成。 状态行HTTP/1.1 200 OK 请求行一般由 协议版本号、状态码与状态码描述组成。 协议版本号有: 0.9、1.0、1.1、2.0等，目前比较流行的是2.0与1.1 状态码有以下几种类型，状态码和前端开发会比较相关一点，更具体的介绍后面会详细说 1xx 信息提示 2xx 成功 3xx 重定向 4xx 客户端错误 5xx 服务端错误 头部字段状态行与空行之间就是响应头部字段了， 响应头比请求头功能相对来说多一点，比如后面会说到的Set-Cookie。123456X-Powered-By: ExpressContent-Type: text/html; charset=utf-8Content-Length: 22ETag: W/&quot;16-dDTk/xb5lvRNBfrz6lE//HVBox8&quot;Date: Tue, 22 May 2018 03:04:08 GMTConnection: keep-alive 响应头包括一些服务本身的信息以及响应内容体的信息，比如这里的Date: Tue, 22 May 2018 03:04:08 GMT 是响应的时间Content-Length: 22是返回的消息体长度。 空行(CRLF)和请求的CRLF是一样的，用来隔开响应头和响应内容主体 响应消息主体在我们这个例子里面是一句很简单的 &lt;h1&gt;Hello, Jsonz!&lt;/h1&gt;，这里响应主体有很多种格式，如果是gif的话会返回gif的二进制字节集合 请求请求的结构组成Request:1234Request-Line CRLF*Request-HEAD CRLFCRLF[ message-body ] Request-Line =&gt; Request-List = Method SPACE Request-URI SPACE HTTP-Version CRLF这里我们主要Request-Methods部分 GETGET 方法一般是用来获取URL指定的资源 可以配合 Range 来获取局部资源。发起请求12GET /index.txt HTTP/1.1Range: bytes=0-4 服务端响应12345HTTP/1.1 206 Partial ContentContent-Type: text/htmlContent-Range: bytes 0-5/12Content-Length: 5hello 在一些视频的场景，比如用户点击到某个进度，我们可以直接从该进度去请求，而不是整一个视频都请求下来。响应头的Content-Range: bytes 0-5/12指的是当前返回0-5，总长为12。 配合 ETag 做缓存服务端在响应头里面会给一个ETag标识，这个标识我们在开头的时候有说了是文件的唯一标识符。那么我们是不是可以这么做，在GET请求时使用条件获取头部字段，如果服务端发现这个字段与文件的ETag标识匹配，则可以做缓存，否则发送新的文档过来。 发起请求12GET /hello.htm HTTP/1.1If-None-Match: W/&quot;16-dDTk/xb5lvRNBfrz6lE//HVBox8&quot; 服务端响应12345HTTP/1.1 304 Not ModifiedX-Powered-By: ExpressETag: W/&quot;16-dDTk/xb5lvRNBfrz6lE//HVBox8&quot;Date: Tue, 22 May 2018 12:08:23 GMTConnection: keep-alive 这里我们的ETag与文件匹配上了，所以服务端直接响应 304 状态码(Not Modified); HEADHEAD方法和GET方法的区别是 HEAD方法请求，响应的时候就只会发送响应消息的头部字段，不会把响应消息主体返回 那么HEAD的场景一般在什么地方呢？ 一般可用于发起一个请求来获取服务端的资源大小，再分段获取。 POST我们平时大部分场景用的都是POST方法，因为POST方法不会把参数都丢在URL上，对请求的数据大小没有限制，请求也不会缓存。 OPTIONSOPTIONS方法主要是用来查询URL指定的资源所支持的方法列表 发起请求1OPTIONS /hello.htm HTTP/1.1 服务端响应12345678910HTTP/1.1 200 OKX-Powered-By: ExpressAllow: GET,HEADContent-Type: text/html; charset=utf-8Content-Length: 8ETag: W/&quot;8-ZRAf8oNBS3Bjb/SU2GYZCmbtmXg&quot;Date: Tue, 22 May 2018 12:20:42 GMTConnection: keep-aliveGET,HEAD% 这里列出了这个资源支持 GET与HEAD方法 PUTPUT方法上面讲了是 对URL指定的资源进行创建，如果存在就修改他。 理论上这种需求直接用POST方法就完全够用了，比如创建订单POST /order/create更新订单 POST /order/orderId 但是这里如果改成PUT创建的话，可以直接这样 PUT /order 更符合Restful API规范，如果换成前端的层面来说，就像div与header, nav, section, aside, footer这些更有语义化的标签。 DELETE删除某个资源，没什么好说的 CONNECT 在当前已经建立HTTP连接的情况下，CONNECT 方法用来告知代理服务器，客户端想要和服务器之间建立SSL连接。 客户端使用如下消息，通知代理服务器，去做一个连接到指定的服务器地址和端口:1CONNECT example.com 443 HTTP/1.1 代理服务器随后提取CONNECT 方法指定的地址和端口（这里是 example.com 443 ），建立和此服务器的SSL连接，成功后随后通知客户端，需要的连接建立完毕： 1HTTP/1.1 OK 使用CONNECT发起请求，服务端不会去解析字段等操作，而是完完全全单纯的做转发，我们称之为透明代理。 TRACE查询到目标资源经过的中间节点。 响应响应结构组成Response:1234Response-Line*(header CRLF) CRLF[ message-body ] Response-Line =&gt; HTTP-Version SPACE Status-Code SPACE Reason-Phrease CRLF这里我们主要Status-Code部分 1xx100 Continue服务器已经接收到请求头，并且客户端应继续发送请求主体（在需要发送身体的请求的情况下：例如，POST请求），或者如果请求已经完成，忽略这个响应。 比如客户端上传一些视频文件，可以先在请求头加一个Expect: 100-continue 如果服务端允许接收该文件（大小），就返回100，不允许则返回417状态码。 2xx2xx 系列都是表示请求已经成功处理了，这里列举几个比较常见的 200 OK最常见的可能就是200了，平时写ajax很多都是直接判断 xmlhttp.status==200, 他代表的是请求已经成功完成 201 Created201表示请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回。假如需要的资源无法及时创建的话，应当返回’202 Accepted’。 202 Accepted202代表服务器已接受请求，但尚未处理。最终该请求可能会也可能不会被执行，并且可能在处理发生时被禁止 204 No Content服务器成功处理了请求，没有返回任何内容。 206 Partical Content206主要是为了支持大文件的分段下载，类似迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 这里用书里的一个例子来展示,先用 HEAD 获取该资源的大小，再用Range分段获取，这些方法上面都有介绍过，这里综合起来运用:12345678910111213141516171819202122232425262728HEAD /large.jpg HTTP/1.1Host: example.comHTTP/1.1 200 OKAccept-Ranges: bytesContent-Length: 4000Get /large.jpg HTTP/1.1Host: example.comRange: bytes=0-1999HTTP/1.1 206 Partical ContentAccept-Ranges: bytesContent-Length: 2000Content-Range: bytes 0-1999/4000&#123;binary data&#125;GET /large.jpg HTTP/1.1Host: example.comRange: bytes=2000-HTTP/1.1 206 Partical ContentAccept-Ranges: bytesContent-Length: 2000Content-Range: bytes 2000-3999/4000&#123;binary data&#125; 2xx 很多只是规范与语义化的区别。 3xx3xx系列除了 304 以外，其他都是用于重定向的 300 Multiple Choices300是请求的资源有一系列可供选择的回馈信息，用户或浏览器能够自行选择一个首选的地址进行重定向。 301 Moved Permanently &amp;&amp; 302 Found301 与 302 都代表当前访问的URL对应的资源被移动到一个新的位置，这个位置会在响应头Location内指定。他们的区别是 301是永久被移动到新位置，而302是暂时性的临时重定向 304 Not Modified304我们在前面已经有见到过了，用ETag与If-None-Match配合做缓存时，就会返回304 代表该资源未被修改，可以继续用以前下载的副本。 400400指的是客户端错误，既服务端接收到该请求，但是收到的请求无法处理,这里列出常见的几种 400 Bad Request由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求 401 Unauthorized401既未认证，应该是最简单的用户认证登录系统了。与403不同，这里如果用户提供必要的凭据，就可以访问资源。 403 Forbidden服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。项目中的经验就是，如果用户登录状态过期，后台返回403状态码，这时候我们再去执行自动登录或者提示登录的逻辑。 404 Not Fount请求失败，请求所希望得到的资源未被在服务器上发现，但允许用户的后续请求。这个可能是最常见的4xx状态码 412 Precondition Failed 客户端发起了条件请求，服务器发现这个请求中的其中一个条件并不成立，那么服务器就会用此错误码作为响应消息的状态码返回给客户端。比如我们在请求头设置条件限定:If-Unmodified-Since，如果服务端校验这个条件，发现说没有满足的话，就会返回 412 状态码。 5xx400是客户端错误，500就是服务端的错误状态码。 500 Internal Server Error500为通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。没有给出具体错误信息，一般开发者可以查日志等去解决该错误。 503 Service Unavailable 说明服务器现在无法提供服务，但是将来可以。如果服务器知道何时资源可用，应该在响应中包含Retry-After的首部，提示客户端可以重试服务的时间。如果没有提供Retry-After头部，那么客户端应当以处理500响应的方式处理它。 以上是觉得比较常见的状态码，更多请见维基百科 Cache-Control一般我们在服务端响应可以加上这个响应头Cache-Control: max-age=2592000 来让浏览器把这个资源缓存下来，缓存的时间为2592000既30天，也可以在时间后面加上个public来指示该响应可以被任何中间人（cdn,代理)缓存。 消息主体在请求消息或响应消息里面，都可以包含一个可选的消息主体，服务端或客户端都没办法从消息主体里面获取是什么内容啊，什么类型啊什么的，所以就会有一组头部字段来标示他。 1234567891011Content-Type 实体中所承载对象的类型,如 txt/html; image/jpegContent-Length 所传送实体主体的长度或大小。Content-Language 与所传送对象最相配的人类语言, en-us等Content-Encoding 对象数据所做的压缩格式,gzip等.Content-Location 一个备用位置，请求时可通过它获得对象。Content-Range 说明它是整体的哪个部分,可用于分段获取。Content-MD5 实体主体内容的校验和。Last-Modified 所传输内容在服务器上创建或最后修改的日期时间。Expires 实体数据将要失效的日期时间。Allow 该资源所允许的各种请求方法，例如，GET 和 HEAD。ETag 这份文档的唯一验证码，可用于缓存 HTTP/2.0(h2)这里简单说一下h2与HTTP/1.1对于前端开发人员来说比较大的改动。 多路复用 (Multiplexing)多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。在HTTP/1.1中，我们客户端在同一时间，针对同一于域名下的请求会有限制，如果超过某个值的请求会被堵塞到。所以一般的优化有前端用雪碧图来合并多个小图片减少请求，后端把资源分到不同的域下面，减少同域的限制。但是如果网站用了h2的话，前端不需要考虑类似雪碧图之类的把多个请求合并为一个减少的优化。 最后啰嗦两句之所以会看《HTTP小书》是因为前段时间问我一个朋友说有没有关于HTTP比较好的书籍推荐，《HTTP权威指南》六七百页细节太多怕是看完留不住什么概念。他给我推了《HTTP小书》，这本书算是有点改变我一些关于知识获取的认知。简单来说就是，大家别看9块钱的书就那么几页，翻一个上午或者一天就看完，然后就觉得不值，非得要看哪种几百页的才觉得钱回本了。这篇文只是个人在看的时候做了一些归纳，书中有更详细更好的解释，关键是提供了源码与例子，在看概念的时候实操一遍会加深很多印象。总的来说，这本书挺值的，和他的标语一样：准能帮你省下不少时间 《HTTP小书》《HTTP小书》作者刘传君HTTP Method 更详细的介绍HTTP缓存 - MDN]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>Book</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-05-21 小记]]></title>
    <url>%2F2018%2F05%2F2018-05-21%2F</url>
    <content type="text"><![CDATA[最近工作不是很忙，也没有再投简历去面试，好像又开始恢复以前的学习热情与节奏。 发了几篇水文~ 看了一个小脚手架的部分源码《create-react-app》，看了一本技术书《css世界》，一本小说《白金数据》。 但是写这篇流水的主要目的是再次意识到自己看问题太过 局限。 先交代一下背景： 目前公司的项目是基于 cookie 去判断一些环境，然后指向测试环境或者正式环境 对于 font 字体文件来说，他的请求是没有带上cookie的（chrome的bug，chrome觉得说这个文件不需要带上cookie，safari就会带) 出现的问题是： 如果测试环境有了新的 font 字体，那么因为他没有带上cookie，所以会被指向正式环境服务器去请求资源，但是这个时候正式环境还没有这个 font 字体，所以会报404。 怎么解决？ 我给出的方案是: 后端给出一个页面，我们打包后把字体文件丢到正式环境上面 如果不想这么low手动的话， 那就在打包字体的命令行后面自动去提交到正式环境 老大给出的方案是:直接根据目前的环境分离机制，在nginx配置一下：测试环境下所有静态资源直接指到测试环境 = =简直被吊打，看问题还是很局限 没有跳出前端的圈子…╮(╯▽╰)╭ 所以接下来优先补后端的一些基础知识 💪]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《css世界》常用技巧 —— 读书笔记]]></title>
    <url>%2F2018%2F05%2Fcss-world%2F</url>
    <content type="text"><![CDATA[前段时间面了荔枝，反馈说对一些css概念性的东西掌握不是很好~ 所以最近有空看了张鑫旭大佬的《CSS世界》全本通熟易懂，继承了博客的画风，入口即化 很多东西三言两语讲不清楚，大家可以入手张鑫旭大佬的书来看看，里面很多常用的概念和属性都帮我们捋一遍。《css世界》购买链接附上张鑫旭大佬的博客，有事没事看一看经常会有意外收获张鑫旭博客 改变 width/height 作用细节的 box-sizing box-sizing的作用是什么？ 一句话，改变了 width 作用的盒子。默认情况下，width 是作用在 content box 上的，box-sizing 的作用就是可以把 width 作用的盒子变成其他几个。 但是目前 box-sizing 仅支持 content-box 和 border-box。123456789101112131415161718/* 这里 box1宽度默认作用在content-box,所以 width 表现为 100 + 10*2 + 20*2 = 160px */.box1 &#123; width: 100px; height: 100px; border: 10px; padding: 20px; background-color: red;&#125;/* 这里 box2添加了 box-sizing: border-box; 所以宽度作用改成了content、padding与border，width 表现为100px, content为: 100- 10* 2- 20* 2 = 40px*/.box2 &#123; width: 100px; height: 100px; border: 10px; padding: 20px; background-color: red; box-sizing: border-box;&#125; min-width/max-width min-height/max-height 权重超越 !important, min-width超越max-widthmin-*初始值规范里为 0，实际尝试为automax-*初始值为 auto12345678/*下面代码表现为 100px*/.box1 &#123; min-width: 100px max-width: 10px; width: 50px!important;&#125; padding的百分比值计算规则是相对于宽度计算的这里引出一道面试题， 不借助js的情况下用一个元素实现相对于浏览器窗口宽度1/2的正方形当时我的回答是用vw，如果早点看css世界就知道padding这个属性了。12345678910/* vw方法 */.box1 &#123; width: 50vw; height: 50vw;&#125;/* padding方法 */.box2 &#123; padding: 25%; display: inline-block;&#125; padding 的图形绘制 一个元素画出红领巾的“三道杠”1234567891011.box1 &#123; display: inline-block; background: currentColor; width: 140px; height: 10px; border-top: 10px solid; border-bottom: 10px solid; padding: 35px 0; /* 这里其实关键起作用的还是 background-clip: content-box; 把背景色作用从border-box改为content-box*/ background-clip: content-box;&#125; 1&lt;div class="box1"&gt;&lt;/div&gt; padding 的图形绘制 一个元素画出双层圆点图形效果1234567891011.box1 &#123; display: inline-block; background: currentColor; width: 100px; height: 100px; padding: 10px; background-clip: content-box; border: 10px solid; background-clip: content-box; border-radius: 50%;&#125; 1&lt;div class="box1"&gt;&lt;/div&gt; margin的百分比值计算规则和padding一样，但是margin在垂直方向没办法改变自身内部尺寸往往要借助父元素作为载体，还存在margin合并的问题还是那道浏览器窗口1/2的面试题，如果没有要求只用一个元素实现的话，可以用margin去实现 这里简单说一下，之所以设置父级box1的overflow:hidden，是因为要创建一个块级格式化上下文元素,一方面可以用子级margin撑起高度，另一方面处理margin合并问题，所以子级.box2直接用margin:100%，而不是200%。12345678910.box1 &#123; background: currentColor; overflow: hidden; /* 宽度窗口1/2 */ width: 50%;&#125;.box2 &#123; /* 高度窗口1/2 */ margin: 100%;&#125; 1&lt;div class="box1"&gt;&lt;div class="box2"&gt;&lt;/div&gt;&lt;/div&gt; margin合并的解决方法这里只列举出margin-top合并的情况, margin-bottom与其相对应 父元素设为块级格式化上下文，7就是 父元素设置border-top 父元素设置padding-top (这里可以用margin-top负值来消除作用) 父元素与第一个子元素之间添加内联元素进行分隔 利用 margin: auto 做垂直上下居中1234567891011121314151617.box1 &#123; height: 400px; width: 400px; border: 1px solid ; position: relative;&#125;.box2 &#123; position: absolute; left: 0; right: 0; top: 0; bottom: 0; background-color: currentColor; width: 200px; height: 200px; margin: auto;&#125; 1&lt;div class="box1"&gt;&lt;div class="box2"&gt;&lt;/div&gt;&lt;/div&gt; border 默认颜色为元素color值border绘制三角形项目上画三角形绝大部分都是用border，好控制，实现简单，成本低只需一个元素。123456.box1 &#123; border: 10px; border-style: solid; border-color: currentColor transparent transparent; width: 0;&#125; css尺寸单位ex，指的是字母x的高度。这里简单说一下，css里面的基线(baseline)其实就是字母x的下边缘线关于ex的应用这里不写呆毛了，我们可以利用他来实现文字与图片居中，直接给张鑫旭大佬的demo再感慨一下，虽然这些东西多多少少都在张鑫旭博客看到，但是这本书真的对一些东西的讲解很通俗易懂。大家可以入手有空翻一翻 BFC 块级格式化上下文在上面我们讲过了设置overflow:hidden;可以创建BFC来清除浮动，那么还有哪些方法可以创建BFC呢？ 根目录 float 值不为 node overflow 的值为 auto、scroll或hidden(常用) display 值为 table-cell、 table-caption和 inline-block(常用) position 的值不为 relative和 staticBFC的结界特性最重要的用途不是去margin重叠或清除float影响，而是实现更健壮、更智能的自适应布局面试的时候面试官问我BFC主要用来做什么，我的回答是 清除浮动和去margin重叠。真的是哪壶不开提哪壶…哭死😭 用BFC实现一边固定宽度，另一边自适应布局12345678910111213141516&lt;style&gt; .box1 &#123; float: left; width: 200px; background: currentColor; &#125; .box2 &#123; overflow: hidden; background: red; &#125; div &#123; height: 200px; &#125;&lt;/style&gt;&lt;div class="box1"&gt;&lt;/div&gt;&lt;div class="box2"&gt;&lt;/div&gt; 无依赖absolute绝对定位（没有left/top/right/bottom)我们平时如果对元素进行 absolute 定位，多半会加多个 left,top然后给父级加个 relative。实际上大多数情况我们可以直接用margin辅助定位，12345.father&#123; position: relative; &#125;/* @before */.son &#123;position: absolute; top: 10px; left: 10px;&#125;/* @after */.son &#123;position: absolute; margin-top: 10px; margin-left: 10px;&#125; 这么实现有两个好处，一个是我们不需要父级去加个relative后面要撤销，直接改 .son样式就好。第二个好处就是某些场景适应性比依赖项定位好无依赖在有多语言场景下做角标简直是天使！！！不然一个英语场景，一个日语场景网站肯定会乱套…. 单行显示…更多效果1234567891011&lt;style&gt; .p1 &#123; text-overflow: ellipsis; width: 200px; overflow: hidden; white-space: nowrap; &#125;&lt;/style&gt;&lt;p class="p1"&gt; 目前，对-webkit-私有前缀支持良好的浏览器还可以实现多行文字打点效果，但是却无 须依赖 overflow:hidden。比方说，最多显示 2 行内容，再多就打点就&lt;/p&gt; 多行显示…更多效果这里用了Overflow是因为，不用的话，会把多余的内容展示出来，但是用不用都会有省略号效果123456789101112&lt;style&gt; .p1 &#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; width: 500px; overflow: hidden; &#125;&lt;/style&gt;&lt;p class="p1"&gt; 目前，对-webkit-私有前缀支持良好的浏览器还可以实现多行文字打点效果，但是却无 须依赖 overflow:hidden。比方说，最多显示 2 行内容，再多就打点就&lt;/p&gt; outline自动填满屏幕剩余空间的应用技巧tip:clip是裁剪功能，很多情况下我们都用他来实现一些隐藏的效果，比如这个栗子🌰..12345678910111213141516&lt;style&gt; .footer &#123; height: 50px; &#125; .footer &gt;p &#123; position: absolute; left: 0;right: 0; background-color: #abcdef; outline: 9999px solid #abcdef; clip: rect(0 9999px 9999px 0); &#125;&lt;/style&gt;&lt;h1&gt;I am Jsonz.&lt;/h1&gt;&lt;div class="footer"&gt; &lt;p&gt;footer&lt;/p&gt;&lt;/div&gt; 层叠上下文什么是层叠上下文？ 层叠上下文，英文称作 stacking context，是 HTML 中的一个三维的概念。如果一个元素含 有层叠上下文，我们可以理解为这个元素在 z 轴上就“高人一等”。 层叠上下文生成规则: position 值为 relative/absolute flex 布局 opacity 值不是 1 transform 值不是 none filter 值不是 none -webkit-overflow-scrolling 设为 touch 层叠上下文的顺序: 如果不依赖z-index，则可以看成 z-index: 0 依赖z-index 则看 z-index 的值 textarea 宽度100%自适应效果1234567891011121314151617181920212223242526272829303132&lt;style&gt; /*父级*/ .box1 &#123; width: 280px; margin: 0 auto; padding: 10px 0; background-color: #abcdef; &#125; /* 模拟边框与padding */ .box2 &#123; padding: 9px 8px; border: 1px solid #d0d0d5; border-radius: 4px; background-color: #fff; &#125; /* 真实 textarea */ .box2&gt; textarea &#123; width: 100%; line-height: 20px; padding: 0; border: 0 none; outline: 0 none; background: none; resize: none; &#125;&lt;/style&gt;&lt;div class="box1"&gt; &lt;div class="box2"&gt; &lt;textarea &gt;&lt;/textarea&gt; &lt;/div&gt;&lt;/div&gt; 空元素选择器 :empty看《css世界》之后才知道有这么一个空元素选择器…绝对不是其他目的1234567&lt;style&gt; span:empty::after &#123; content: '是帅哥'; &#125;&lt;/style&gt;&lt;span&gt;Jsonz&lt;/span&gt;&lt;span&gt;&lt;/span&gt; 第一行要选择器:first-line同上，比较少用的选择器，但是感觉部分场景挺实用的12345&lt;style&gt;p:first-line &#123; color: red; &#125;p &#123; width: 40px; &#125;&lt;/style&gt;&lt;p&gt; 可乐鸡翅 &lt;/p&gt; 第一个字（母）选择器:first-letter需要注意的是，如果这里我用的是字（母）来描述选择器，意味着，如果第一个是符号的话，会找下一个直到找到符合条件的才会渲染成我们要的样式，否则都是默认样式。1234567&lt;style&gt;p:first-letter &#123; color: red; &#125;&lt;/style&gt;&lt;p&gt; !!!!反沙芋&lt;/p&gt;&lt;p&gt;!!!!!&lt;/p&gt; 动态loading打点效果这里主要利用了content 支持\A换行来实现，用dot是因为 是自定义的一个标签元素，除了简约、语义化明显123456789101112131415161718192021&lt;style&gt; dot &#123; display: inline-block; height: 1em; line-height: 1; text-align: left; vertical-align: -.25em; overflow: hidden;&#125;dot::before &#123; display: block; content: '...\A..\A.'; white-space: pre-wrap; animation: dot 3s infinite step-start both;&#125;@keyframes dot &#123; 33% &#123; transform: translateY(-2em); &#125; 66% &#123; transform: translateY(-1em); &#125;&#125;&lt;/style&gt;正在加载中&lt;dot&gt;...&lt;/dot&gt; 单行文字居中对齐，多行文字左对齐123456789101112131415&lt;style&gt;.box1 &#123; text-align: center; width: 200px; border: 1px solid ;&#125;p &#123; display: inline-block; text-align: left;&#125;&lt;/style&gt;&lt;div class="box1"&gt; &lt;p&gt;大家好&lt;/p&gt; &lt;p&gt;我是Jsonz，现在是一名小切图仔&lt;/p&gt;&lt;/div&gt; 字体使用系统字体这里个人有点疑惑~ 如果单纯是想使用系统默认字体，直接不设置 font 不就好了~ 多此一举设置个 menu…12html &#123; font: menu; &#125;body &#123; font-size: 16px; &#125; 书里更多的不是给我们展示这些小技巧，而是帮我们讲清楚很多概念与他的特性，这篇文比较没经验，效果图都是用的截图…下次有机会的话注意直接展示个demo可能看起来会更直观]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>CSS</tag>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器恢复滚动行为 —— history.scrollRestoration]]></title>
    <url>%2F2018%2F05%2Fhistory-scroll-restoration%2F</url>
    <content type="text"><![CDATA[直入主题。之前做移动端的需求时，经常遇到一种常见，就是:a页面是一个长列表，我们滑动到某个地方假设为 100px ，点击之后进入到b页面再从b页面回到a页面，这时候浏览器的滚动条会自动回到我们跳转前的位置，也就是 100px 的位置。 这种体贴的行为我是很喜欢的~ 但是有时候产品就非要抬杠，说 我就不想要这种行为，你给我回到顶部去(╯‵□′)╯︵┻━┻ 以前没办法就经常用什么 setTimeout 大法去手动处理这些东西 氮素!!! 如果只是说setTimeout大法的话，就没我什么事了。今天要说的是 history.scrollRestoration ，这个属性是实验性的属性，他的作用是: 允许Web应用程序在历史导航上显式地设置默认滚动恢复行为。此属性可以是自动的（auto）或者手动的（manual）。 说的很明白了，如果浏览器支持 history.scrollRestoration并且值为auto则会默认恢复滚动行为。如果设置为 manual则可以取消，这个行为不用去考虑兼容性的问题，如果有这个功能才会有恢复滚动，所以直接判断一下就可以了。无需多考虑 1window.history.scrollRestoration &amp;&amp; (window.history.scrollRestoration = 'auto'); 以后妈妈再也不用担心我被产品怼了 O(∩_∩)O~~ google-developers 资料mozilla-developer 资料]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>JavaScript</tag>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[create-react-app 源码解析之react-scripts]]></title>
    <url>%2F2018%2F05%2Fcreate-react-app-t%2F</url>
    <content type="text"><![CDATA[上一篇我们已经讲了 create-react-app里面创建package.json安装依赖并且拷贝可运行的demo等步骤。传送门 这一篇我们来讲一下 create-react-app里面的启动服务等部分，就是平时我们安装完依赖之后，启动开发服务:npm start。这一块涉及到太多关于webpack与配置的东西，加上第一篇觉得描述的太过冗余~所以这篇不会讲得很细，只是大概把他运转的逻辑思路写出来，具体源码会提供传送门。 推荐大家看第一篇的 项目初始化 和 断点调试 部分，这里就不在赘述。传送门 项目初始化断点调试部分 准备阶段这里我们讨论的create-react-app版本依旧是v1.1.4 既然这篇我们主要讲的是 create-react-app里面的webpack服务，那我们肯定要先新建一个项目。 npm install create-react-app -g 全局安装create-react-app create-react-app my-react-project 用create-react-app新建一个项目 12cd my-react-projectyarn start 新建完之后，终端提示了我们直接进入项目，跑 yarn(npm) start 就可以开发了。我们打开 package.json就可以看到 yarn start 跑的命令是 &quot;react-scripts start&quot; 那么这个 react-scripts 命令到底是哪一个呢？ 一般写在 package.json=&gt; scripts 的命令，都会先去 project_path(项目目录）/node_modules/.bin 查找，找不到再找全局安装的包。 那么 node_modules/.bin 里面的文件又是怎么来的呢？我们如果在包的 package.json 加上 bin 字段，npm就会自动帮我们映射到 node_modules/.bin 里面 npm bin文档传送门 我们直接打开 node_modules/react-scripts/package.json 能看到这么一行&quot;react-scripts&quot;: &quot;./bin/react-scripts.js&quot;,直接把命令指向node_modules/react-scripts/.bin/react-scripts.js，也验证了我们的观点。 还记得上一篇，我们在 create-react-app/packages 里面发现了有一个 react-scripts。其实是同一个东西来的，那么接下来的步骤就很明确了，直接用老办法，改下配置，然后用vscode跑断点调试阅读project_path/node_modules/react-scripts/.bin/react-scripts.js的源码 一探究竟。 vscode launch.json这里我们传入 start 作为参数,模拟在项目里跑 yarn start 的效果。1234567891011121314&#123; "version": "0.2.0", "configurations": [ &#123; "type": "node", "request": "launch", "name": "启动程序", "program": "$&#123;workspaceFolder&#125;/node_modules/react-scripts/bin/react-scripts.js", //调试的文件路径 "args": [ "start" // 传入 start 做为参数 ] &#125; ]&#125; ps:下面的react-scripts没有特殊说明，都代表project_path/node_modules/react-scripts目录方便阅读 react-scripts/.bin/react-scripts.js文件传送门这里我们还是老办法，先不看依赖 看主流程理解先，我们能看到这个文件也是一个入口文件，非常简短。 1234567const args = process.argv.slice(2);const scriptIndex = args.findIndex( x =&gt; x === 'build' || x === 'eject' || x === 'start' || x === 'test');const script = scriptIndex === -1 ? args[0] : args[scriptIndex];const nodeArgs = scriptIndex &gt; 0 ? args.slice(0, scriptIndex) : []; 首先处理传进来的参数，用script变量来获取我们跑的命令是哪一个，有[‘build’, ‘eject’, ‘start’, ‘test’]这么几种，分别对应 构建、暴露配置、开发、测试命令。然后再获取一起传入的其他的参数，比如npm test命令就会带一个额外的参数--env=jsdom。 1234567891011121314151617181920212223242526272829switch (script) &#123; case 'build': case 'eject': case 'start': case 'test': &#123; // 用 cross-spawn 去跑一个同步的命令 // 根据传入的命令来拼接对应的路径 用node去跑 const result = spawn.sync( 'node', nodeArgs .concat(require.resolve('../scripts/' + script)) .concat(args.slice(scriptIndex + 1)), &#123; stdio: 'inherit' &#125; ); if (result.signal) &#123; if (result.signal === 'SIGKILL') &#123; // 输出错误提醒日志 &#125; else if (result.signal === 'SIGTERM') &#123; // 输出错误提醒日志 &#125; process.exit(1); // 退出进程， 传1代表有错误 &#125; process.exit(result.status); break; &#125; default: // 这里输出匹配不到对应的命令 break;&#125; 然后根据获取到的命令，对应到react-scripts/scripts下面的文件去跑，比如 react-scripts start 就会去跑 react-scripts/scripts/start.js。 这里插几句讲一下一个项目上比较常见的类库解耦方式，我们可以看到这里的 spawn引用的是react-dev-utils/crossSpawn。而在react-dev-utils/corssSpawn里面也只是简简单单的几句，引入cross-spawn再把cross-spawn暴露出去。但是这么写就可以起到类库解耦的作用，比如以后这个库被爆出有重大的bug或者停止维护了，直接修改这个文件引入其他的类库，其他引用该文件的代码就不需要改动。 123456// react-dev-utils/corssSpawn'use strict';var crossSpawn = require('cross-spawn');module.exports = crossSpawn; react-scripts/scripts/start.js文件传送门 看过第一篇的人对这个文件夹应该不陌生，create-react-app 在安装完 react 等依赖之后，就会跑这个文件夹下面的init.js来拷贝模版文件，修改package.json等操作。 既然我们已经知道他要执行 start.js, 接下来我们把vscode调试文件修改为 start.js 文件&quot;program&quot;: &quot;${workspaceFolder}/node_modules/react-scripts/scripts/start.js&quot;, 之所以要修改是因为他这里不是引用js文件来运行，而是用终端来跑，所以不属于我们的项目调试范围~ 123456789process.env.BABEL_ENV = 'development';process.env.NODE_ENV = 'development';// Makes the script crash on unhandled rejections instead of silently// ignoring them. In the future, promise rejections that are not handled will// terminate the Node.js process with a non-zero exit code.process.on('unhandledRejection', err =&gt; &#123; throw err;&#125;); 文件的最开头设置了两个环境变量，因为 start 是用来跑开发的，所以这里的环境变量都是 development，然后再给 process 绑定一个错误监听函数，这个错误监听实质上是用来监听 一些没有被.catch的Promise。 具体可以看node的文档, 关于 Promise可以看一下之前写过的一篇介绍Promise的文章从用法和实现原理都有所涉及 接着引进一个 ../config/env， 看文件名猜应该是做一些关于环境配置的事情，找到文件断点进来 react-scripts/config/env.js12345const fs = require('fs');const path = require('path');const paths = require('./paths');// Make sure that including paths.js after env.js will read .env variables.delete require.cache[require.resolve('./paths')]; env.js 文件在引入 ./paths.js 之后，立即把他从cache中删除掉，这样下次如果有其他的模块引入paths.js，就不会从缓存里面去获取，保证了paths.js里面执行逻辑都会用到最新的环境变量。 1234567var dotenvFiles = [ // 举个例子：第一个元素在我的电脑路径是这样的 Users/jsonz/Documents/my-react-project/.env.development.local.js `$&#123;paths.dotenv&#125;.$&#123;NODE_ENV&#125;.local`, `$&#123;paths.dotenv&#125;.$&#123;NODE_ENV&#125;`, NODE_ENV !== 'test' &amp;&amp; `$&#123;paths.dotenv&#125;.local`, paths.dotenv,].filter(Boolean); 然后再根据paths给出的地址去拿其他的环境变量，这里paths.js会根据不同的情况给出不同的路径，我们讨论的是正常的创建项目情况。其他的几种情况有： 我们在已经创建的项目跑了 npm(yarn) eject，这时候 react-scripts会把配置都暴露到 project_path/config 方便我们去根据项目修改配置，这个操作是不可逆的。 我们正常创建项目，直接跑项目，这时候配置就存放在project/node_modules/react-scripts。 开发人员自己调试用的，这时候配置存放在create-react/packages/react-scripts/config。 拼装完路径之后，用dotenv-expand和dotenv来把文件里面的环境变量加载进来，这一块一般场景用不上。 1234567891011121314151617181920function getClientEnvironment(publicUrl) &#123; const raw = Object.keys(process.env) .filter(key =&gt; REACT_APP.test(key)) .reduce( (env, key) =&gt; &#123; env[key] = process.env[key]; return env; &#125;, &#123; NODE_ENV: process.env.NODE_ENV || 'development', &#125; ); const stringified = &#123; 'process.env': Object.keys(raw).reduce((env, key) =&gt; &#123; env[key] = JSON.stringify(raw[key]); return env; &#125;, &#123;&#125;), &#125;; return &#123; raw, stringified &#125;;&#125; 然后返回一个 getClientEnvironment函数，这个函数执行后会返回客户端的环境变量。 react-scripts/scripts/start.js(2)12345678910111213141516171819const fs = require('fs');const chalk = require('chalk');const webpack = require('webpack');const WebpackDevServer = require('webpack-dev-server');const clearConsole = require('react-dev-utils/clearConsole');const checkRequiredFiles = require('react-dev-utils/checkRequiredFiles');const &#123; choosePort, createCompiler, prepareProxy, prepareUrls,&#125; = require('react-dev-utils/WebpackDevServerUtils');const openBrowser = require('react-dev-utils/openBrowser');const paths = require('../config/paths');const config = require('../config/webpack.config.dev');const createDevServerConfig = require('../config/webpackDevServer.config');const useYarn = fs.existsSync(paths.yarnLockFile);const isInteractive = process.stdout.isTTY; 加载完各种环境变量之后，我们回到react-scripts/scripts/start.js，老规矩，一系列的依赖先跳过不看，后面用到再来看。还记得我们在env.js里面delet掉node.catch吗，这里conts paths = require(&#39;../config/paths)就不会从缓存里面去拿而是重新去加载。 123if (!checkRequiredFiles([paths.appHtml, paths.appIndexJs])) &#123; process.exit(1);&#125; 先判断一下我们两个入口文件有没有存在，分别是project_path/public/index.html和project_path/src/index.js，如果不存在给出提示结束程序。 12const DEFAULT_PORT = parseInt(process.env.PORT, 10) || 3000;const HOST = process.env.HOST || '0.0.0.0'; 然后设置默认的端口和host，如果有特殊的需求，可以从环境变量传进去改变，没有就会用默认的3000端口。 1choosePort(HOST, DEFAULT_PORT).then(...) // @return Promise 设置完默认的端口与host之后，开始判断这个端口有没有被其他的进程占用，有的话会提供下一个可用的端口，我们顺着choosePort去文件头找依赖，找到该方法位于依赖react-dev-utils/WebpackDevServerUtils。 1234567891011121314151617181920212223242526272829303132333435363738394041function choosePort(host, defaultPort) &#123; return detect(defaultPort, host).then( port =&gt; new Promise(resolve =&gt; &#123; if (port === defaultPort) &#123; return resolve(port); &#125; const message = process.platform !== 'win32' &amp;&amp; defaultPort &lt; 1024 &amp;&amp; !isRoot() ? `Admin permissions are required to run a server on a port below 1024.` : `Something is already running on port $&#123;defaultPort&#125;.`; if (isInteractive) &#123; clearConsole(); const existingProcess = getProcessForPort(defaultPort); const question = &#123; type: 'confirm', name: 'shouldChangePort', message: chalk.yellow( message + `$&#123;existingProcess ? ` Probably:\n $&#123;existingProcess&#125;` : ''&#125;` ) + '\n\nWould you like to run the app on another port instead?', default: true, &#125;; inquirer.prompt(question).then(answer =&gt; &#123; if (answer.shouldChangePort) &#123; resolve(port); &#125; else &#123; resolve(null); &#125; &#125;); &#125; else &#123; console.log(chalk.red(message)); resolve(null); &#125; &#125;), err =&gt; &#123; // 输出错误日志 &#125; );&#125; choosePort 里面用到detect-port-alt去检测端口占用，如果被占用了返回一个最接近的递增方向可用的端口，比如3000端口被占用,3001没被占用就返回回来。如果发现返回的可用端口不是默认的端口，给出一个交互式的命令询问用户是否要换一个端口去访问，交互式命令用的是inquirer这个包。这里如果用vsCode来调试，process.stdout.isTTY 返回的值是undefined。所以如果要测试这一块交互式命令，只能切回系统的终端去调试~ 文件传送门检测完可用端口之后，回到start.js。 前端处理一堆环境变量，还有加载一堆配置，全都用在这一块。这里主要做的就是把环境变量和配置组装起来，开个webpack本地调试服务。主要做的事情有: 如果没有找到可用的端口直接返回不继续执行下去 根据环境变量判断是否启用https，默认是http。 根据 host, protocol, port 拼装一系列的url，包括Browser的url与Terminal的url。 调用createCompiler 传入webpack，webpack配置，appName，第三步获取的url，还有是否使用Yarn等参数，生成一个 webpackCompiler。createCompiler负责的东西有:4.1 根据环境变量判断是否有冒烟测试的需求，如果有加一个 handleCompile，一有错误就中断程序。4.2 用传进来的配置和handleCompile生成一个webpackCompiler4.2 增加invalid钩子，一检测到更改文件，而且是交互式终端的话，先清空控制台，再输出日志4.3 增加done钩子，对webpack的输出日志整理统一输出 创建开发服务配置 具体的配置代码放在webpackDevServer.config.js 把4和5丢给 WebpackDevServer，生成一个 webpack 本地开发服务 大功告成，清除屏幕，打开调试连接 相关的代码执行写到注释里面去了，没办法每个方法配置都拎出来讲…不然篇幅会很长，这里面很多点一讲都可以是一个知识点。1234567891011121314151617181920212223242526272829303132choosePort(HOST, DEFAULT_PORT) .then(port =&gt; &#123; // 没有找到可用端口，直接return if (port == null) &#123; return; &#125; // 根据环境变量判断是否要用https const protocol = process.env.HTTPS === 'true' ? 'https' : 'http'; const appName = require(paths.appPackageJson).name; // 获取当前的 host, port, protocol 生成一系列url const urls = prepareUrls(protocol, HOST, port); // 创建一个webpack compiler const compiler = createCompiler(webpack, config, appName, urls, useYarn); // 加载代理的配置，在 project_path/package.json 里面加载配置 const proxySetting = require(paths.appPackageJson).proxy; const proxyConfig = prepareProxy(proxySetting, paths.appPublic); // 生成 webpack dev server 的配置 const serverConfig = createDevServerConfig( proxyConfig, urls.lanUrlForConfig ); const devServer = new WebpackDevServer(compiler, serverConfig); // 监听 devServer devServer.listen(port, HOST, err =&gt; &#123; // 一些日志输出 // 自动用默认浏览器打开调试链接 openBrowser(urls.localUrlForBrowser); &#125;); &#125;) .catch(err =&gt; &#123; // 错误处理 &#125;); react-dev-utils/WebpackDevServerUtils.js12345678910111213141516171819202122232425function createCompiler(webpack, config, appName, urls, useYarn) &#123; let compiler; try &#123; compiler = webpack(config, handleCompile); // handleCompile为冒烟测试的对应处理 &#125; catch (err) &#123; // 错误提示 &#125; compiler.plugin('invalid', () =&gt; &#123; // invalid 钩子，如果当前处于TTY终端，那么先清除控制台再输出 Compiling... if (isInteractive) &#123; clearConsole(); &#125; console.log('Compiling...'); &#125;); let isFirstCompile = true; compiler.plugin('done', stats =&gt; &#123; // 监听了 done 事件，对输出的日志做了格式化输出 // 正常情况下会直接输出 `Compiled successfully!` // 如果有错误则输出错误信息，这里对错误信息做一些处理，让其输出比较友好 &#125;); return compiler;&#125; 最后讲两句之前就一直好奇，这些脚手架是怎么清空我们的终端屏幕的。在看create-react-app的时候，瞄到有这么一个文件react-dev-utils/clearConsole.js。这个文件十分剪短，核心代码就那么一句: react-dev-utils/clearConsole.js1process.stdout.write(process.platform === 'win32' ? '\x1B[2J\x1B[0f' : '\x1B[2J\x1B[3J\x1B[H'); 然后好奇心特别重，不知道后面两串是什么意思，一直搜没有找到想要的答案。问了身边的同事，说是十六进制，而在我狭隘的认知里面一直以为十六进制只能转成数字….但是定睛一看，这有个J 明显不是十六进制。一个女装大佬和我说这是ASCII码，百度了一下ASCII码，看了 \x1B ASCII对应到 ESC。 但是后面的 [2J [3J [H 是什么意思还是不清楚…后面大佬又和我说找到可能是 Linux ANSI 控制码 找来找去折腾了挺久的后面才揭开神秘面纱~这几个命令大概的意思是:[2J 清除控制台[H 将光标移至最顶部[3J还是没有找到，应该是更高级的系统层级的清除控制台给出几个 Linux ANSI 控制码资料网站Ubuntu Manpage: 控制终端代码 - Linux 控制终端转义和控制序列控制终端代码 - Linux 控制终端转义和控制序列(转) - 木瓜脑袋 - 博客园 最后前端的小伙伴很多和我一样不是科班出身的，真的得加把劲补补一些计算机比较原理性或比较接近系统层级的知识~]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>github</tag>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-05-08面试记B]]></title>
    <url>%2F2018%2F05%2F2018-05-08%2F</url>
    <content type="text"><![CDATA[欧啦啦啦啦啦啦啦啦啦 记录下最近的面试等情况~~~ 简历投递情况2简历投递情况传送门据不完全统计:投 荔枝 技术面投 100教育 待沟通投 尚德教育 没面试机会 最最最最最开心的事情可能就是面了荔枝~ 虽然最后没有过 不过还是挺不错的一次体验 记录一下 首先流程是： 笔试 =&gt; 机试 =&gt; 两个人的技术面 笔试比较基础的问题，但是面试官会根据写的题问思路，而且会各种变形问，可以比较深了解基础的知识。 以下只是个人的面试记录，如果发现有不妥的联系即删。 荔枝笔试 作用域的问题 1234567891011121314151617181920212223242526272829303132333435function a() &#123; return t; function t()&#123;&#125; var t; t = 20;&#125;typeof a();// 还有各种变形function a() &#123; function t() &#123;&#125; var t; return t; t = 20;&#125;function a() &#123; function t() &#123;&#125; var t; return t; t = 20;&#125;function a() &#123; function t() &#123;&#125; var t; return t; t = 20;&#125;function a()&#123; return t; var t; t = 20;&#125; 兼容低版本浏览器模拟 Function.prototype.bind 1直接用 call || allpy 模拟，返回一个闭包，参数用 Array.prototype.slice.apple 去取即可~ 关于正则的比较简单~ 不写出来了 关于zIndex的，推荐直接看张鑫旭大佬的文章，超不过那个范围张鑫旭大佬传送门 实现一个宽高都是浏览器 40%的正方形 121. 用vw方案2. 用padding ( emmm 这个面试大佬提示了才想起 padding 是根据父级宽度的) a,b,c,d 四个接口，求最快 || 最慢的响应时间 1直接用 Promise.all || Promise.race 即可 笔试题还好，作用域那一题有点混 其他没什么问题，算是有惊无险 机试机试题二选一 一个是实现一个dialog 一个是实现一个验证表单选了 dialog 做的时候没有看题…有个功能点没有实现完全就跑去做验证题，验证题没有做完dialog 应该算是实现的不够及格线 引出了挺多优化方案的，比如 dom 处理，比如动画处理，里面有一个面试官暗示了好多次，但是没有想起来的一个api animationendanimationend demo 面试面试就根据前面做的两份题扩展去问思路等等 问题的套路是比较喜欢的，举个例子： Q: 左边自适应，右边固定有什么布局?A: flex布局, flex: 1 &amp;&amp; width: …Q: 浏览器这时候缩小会有什么情况？A: flex: 1 慢慢缩小，另一个不变（这个回答我模棱两可犹豫了，虽然知道是不变，但是好像项目中有遇过变的…扣分了)Q: 还有其他的吗?A: 浮动 float:left; overflow: autoQ: 清除浮动有哪些A: 委元素清除 &amp;&amp; BFCQ: BFC是什么，有什么作用，怎么设置BFCA: 块级格式化上下文，清除浮动或者消除master合并，可以用overflow(hidden,auto,scroll) || float(left,right) || display(inline-block) || position(absolute, fixed) 后面聊了下 工作的优化， webpack构建， react优化, 缓存机制(涉及http), pwa等等 还问了小程序和vue的东西，但是其实上一次做小程序已经是一年前了，说了vue和小程序的上手不应该成为一个问题所在。 然后问了下职业规划，说了最近是在看 create-react-app源码，接下来的规划是 专前端 通其他 荔枝结果工作优化可能不是很满意webpack构建优化应该还行，毕竟项目上用的比较多react也还好，虽然面试的是用vue和小程序pwa也有所了解主要是 http这块暴露了后台知识薄弱，没有形成一个比较全面知识体系 后面还被嫌弃了三年呆了三个公司太过频繁 最后让面试官给了一下面试的评价：1. css 概念不熟2. 浏览器api认识不全3. http、后端知识没有系统学习4. 跳槽过多~ 三年呆了三个公司 ╮(╯▽╰)╭哎 还闹了个乌龙，想说 《CSS世界》 说成 《css揭秘》 最近应该折腾完手上东西后，会比较系统的去看 切图写页面的这一块，比较 html+css 其实也是很重要的]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[create-react-app 源码解析]]></title>
    <url>%2F2018%2F05%2Fcreate-react-app-o%2F</url>
    <content type="text"><![CDATA[最近工作开始稳定下来，没有那么多加班，加上说投简历找面试一直没拿到面试机会…所以开始有空闲的时间 之前公司有个大佬写了个类似 create-react-app 的脚手架，用来创建公司的项目。一直不知道里面实现的原理，借此机会一探 create-react-app 源码，了解下里面运行的机制。 授人以鱼不如授人以渔，希望通过这篇文章之后，对大家以后看源码可以有所帮助。大家也不要一看到源码就害怕不敢去看，现在这么优秀项目都开源了，加上各种IDE支持很好，直接打个断点进去调试，很容易看出个大概。也可以用这种思路去了解其他的开源项目 快速了解对于想快速了解的直接浏览这一块即可create-react-app 其实就是用node去跑一些包安装流程，并且把文件模板demo考到对于的目录下。可以简单分为以下几个步骤: 判断Node版本 做一些命令行处理的初始化，比如输入 -help 则输出帮助内容 判断是否有输入项目名，有则根据参数去跑包安装，默认是yarn安装方式，eg: yarn add react react-dom react-scripts 修改package.json里面已安装的依赖版本，从精确版本16.0.0改为^向上兼容版本^16.0.0 并加入 start,build等启动脚本 拷贝 react-scripts下的 template 到目标文件，里面有public,src等文件夹，其实就是一个简单的可运行demo END~ 继续往下看的小伙伴可以跟着一步一步了解里面的实现逻辑，先例行交代下环境版本:create-react-app v1.1.4macOS 10.13.4node v8.9.4npm 6.0.0yarn 1.6.0vsCode 1.22.2 项目初始化先上github 拉项目代码，拉下来之后切换到指定的 tag git clone https://github.com/facebook/create-react-app.git git checkout v1.1.4 yarn //如果不需要断点调试，这一步可以跳过 这里可能yarn 版本太低的话，会报一系列错误，之前用的是 0.x版本的，升级到1.x就没问题了 下面我们用 root 代替项目的根目录，方便理解 首先我们打开项目能看到一堆的配置文件和两个文件夹：eslint配置文件、travis部署配置、yarn配置、更新日志、开源声明等等…这些我们全都可以不用去看，那我们要看的核心源码放在哪里呢 划重点: 如果项目不知道从哪里入手的话，首先从package.json文件开始root/package.json12345678910111213&#123; "private": true, "workspaces": [ "packages/*" ], "scripts": &#123; "start": "cd packages/react-scripts &amp;&amp; node scripts/start.js", &#125;, "devDependencies": &#123; &#125;, "lint-staged": &#123; &#125;&#125; 打开根目录 package.json 我们可以看到里面很简洁~ npm脚本命令，开发依赖，还有提交钩子，剩下的就是我们要关注的 workspaces 这里指向的是 &quot;packages/*&quot;，所以我们现在的重点就放在 packages 文件夹 packages 文件夹下面也有几个文件夹，这里文件夹命名很规范，一看就知道功能划分，所以还是老套路直接看 root/packages/create-react-app/package.json packages/create-react-app/package.json123456789101112131415161718&#123; "name": "create-react-app", "version": "1.5.2", "license": "MIT", "engines": &#123; &#125;, "bugs": &#123; &#125;, "files": [ "index.js", "createReactApp.js" ], "bin": &#123; "create-react-app": "./index.js" &#125;, "dependencies": &#123; &#125;&#125; 这时候没有 workspaces项， 我们可以看 bin bin的功能是把命令对应到可执行的文件，具体的介绍可以看package Document 这里可以简单理解成，当我们全局安装了 create-react-app 之后，跑 create-react-app my-react-app 系统会帮我们去跑 packages/create-react-app/index.js my-react-app 终于找到源码的入口了，对于简单的源码我们可以直接看，对于比较复杂的 或者想要看到执行到每一行代码时那些变量是什么值的情况，我们就要用IDE或其他工具来断点调试代码了。 配置断点调试对于vscode或node调试 比较熟悉的可以跳过直接看 开始断点阅读源码 vscode debug对于vscode用户来说，调试非常简单，点击侧边栏的小甲虫图标，点击设置然后直接修改 “program”的值，修改完点击左上角的绿色箭头就可以跑起来了，如果要在某一处断点，比如 create-react-app/index.js line39 断点，直接在行号的左边点一下鼠标就可以了launch.json 配置1234567891011&#123; "version": "0.2.0", "configurations": [ &#123; "type": "node", "request": "launch", "name": "启动程序", "program": "$&#123;workspaceFolder&#125;/packages/create-react-app/index.js", &#125; ]&#125; node 调试如果平时没有用vscode开发或者习惯chrome-devtool的，可以直接用node命令跑，然后在chrome里面调试首先保证node的版本的 6 以上然后在项目根目录下运行 node --inspect-brk packages/create-react-app/index.js在chrome地址栏输入 chrome://inspect/#devices 然后就可以看到我们要调试的脚本了关于node chrome-devtool 调试详细可以看这里 传送门 (ps：这里可以看出来node在模块化的实现是通过用一个函数包裹起来，然后把 exports, requestd等参数传进来以供使用) 开始断点阅读源码packages/create-react-app/index.js github文件传送门这个文件十分简单，只是做为一个入口文件判断一下 node版本，小于 4.x的提示并终止程序， 如果正常则加载 ./createReactApp 这个文件，主要的逻辑在该文件实现。 packages/create-react-app/createReactApp.js github文件传送门顺着我们的断点进入到 createReactApp.js 这个文件有750行乍一看很多，文件头又有十几个依赖引入，但是不要被吓到，一般这种高质量的开源项目，里面有一大半是注释和错误友好信息。 这里建议没有打断点调试的小伙伴试一下把代码复制到另一个js文件，然后先不看前面的依赖，下面用到再去 npm查一下是什么作用的。不要被绕进去看了一个又一个的依赖，核心代码反而没有看到。 然后看一部分之后就把那部分的代码删掉，比如我看了200行，就把前面200行删了，这样剩下500行看着就没有那么心虚了。当然还是建议用断点调试阅读，逻辑会比较清晰。 首先文件头部这一大串的依赖，我们暂时不去关注他们，等后面用到再去查createReactApp.js1234567891011121314const validateProjectName = require('validate-npm-package-name');const chalk = require('chalk');const commander = require('commander');const fs = require('fs-extra');const path = require('path');const execSync = require('child_process').execSync;const spawn = require('cross-spawn');const semver = require('semver');const dns = require('dns');const tmp = require('tmp');const unpack = require('tar-pack').unpack;const url = require('url');const hyperquest = require('hyperquest');const envinfo = require('envinfo'); commander 命令行处理程序接下来顺着我们的断点，第一行被执行的代码是 L56 createReactApp.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const program = new commander.Command(packageJson.name) .version(packageJson.version) // create-react-app -v 时输出 $&#123;packageJson.version&#125; .arguments('&lt;project-directory&gt;') // 这里用&lt;&gt; 包着project-directory 表示 project-directory为必填项 .usage(`$&#123;chalk.green('&lt;project-directory&gt;')&#125; [options]`) // 用绿色字体输出 &lt;project-directory&gt; .action(name =&gt; &#123; projectName = name; &#125;) // 获取用户传入的第一个参数作为 projectName **下面就会用到** .option('--verbose', 'print additional logs') // option用于配置`create-react-app -[option]`的选项，比如这里如果用户参数带了 --verbose， 会自动设置program.verbose = true; .option('--info', 'print environment debug info') // 后面会用到这个参数，用于打印出环境调试的版本信息 .option( '--scripts-version &lt;alternative-package&gt;', 'use a non-standard version of react-scripts' ) .option('--use-npm') .allowUnknownOption() // on('option', cb) 输入 create-react-app --help 自动执行后面的操作输出帮助 .on('--help', () =&gt; &#123; console.log(` Only $&#123;chalk.green('&lt;project-directory&gt;')&#125; is required.`); console.log(); console.log( ` A custom $&#123;chalk.cyan('--scripts-version')&#125; can be one of:` ); console.log(` - a specific npm version: $&#123;chalk.green('0.8.2')&#125;`); console.log( ` - a custom fork published on npm: $&#123;chalk.green( 'my-react-scripts' )&#125;` ); console.log( ` - a .tgz archive: $&#123;chalk.green( 'https://mysite.com/my-react-scripts-0.8.2.tgz' )&#125;` ); console.log( ` - a .tar.gz archive: $&#123;chalk.green( 'https://mysite.com/my-react-scripts-0.8.2.tar.gz' )&#125;` ); console.log( ` It is not needed unless you specifically want to use a fork.` ); console.log(); console.log( ` If you have any problems, do not hesitate to file an issue:` ); console.log( ` $&#123;chalk.cyan( 'https://github.com/facebookincubator/create-react-app/issues/new' )&#125;` ); console.log(); &#125;) .parse(process.argv); // 解析传入的参数 可以不用理会 这里用到了一个 commander 的依赖，这时候我们就可以去npm 搜一下他的作用了。官网的描述是 The complete solution for node.js command-line interfaces, inspired by Ruby&#39;s commander.API documentation 翻译过来是 node.js 命令行接口的完整解决方案，基本的功能看注释即可，大概了解一下有这么一个东西，后面自己要做的时候有门路即可。github传送门。 判断是否有传projectNamecreateReactApp.js1234567891011121314if (typeof projectName === 'undefined') &#123; if (program.info) &#123; // 如果命令行有带 --info 参数，输出 react,react-dom,react-scripts版本 然后退出 envinfo.print(&#123; packages: ['react', 'react-dom', 'react-scripts'], noNativeIDE: true, duplicates: true, &#125;); process.exit(0); &#125; ... 这里输出了一些错误提示信息 ... process.exit(1);&#125; 往下看是一个判断必须传入的参数 projectName，这里的 projectName 就是上面通过 .action(name =&gt; { projectName = name;}) 获取的。判断如果没有输入的话，直接做一些信息提示，然后终止程序。这里参数如果传入了 --info 的话， 会执行到envinfo.print。 日常npm 搜一下 envinfo 这是一个用来输出当前环境系统的一些系统信息，比如系统版本，npm等等还有react,react-dom,react-scripts这些包的版本，非常好用。这个包现在的版本和create-react-app的版本差异比较大，但是不影响我们使用~ envinfo npm传送门 如果是用我上面提供的 vscode debug配置的话，到这里程序应该就运行结束了，因为我们在启动调试服务的时候，没有给脚本传入参数作为 projectName，所以我们修改一下 vscode launch.json 加多个字段 &quot;args&quot;: [&quot;test-create-react-app&quot;] 忘记怎么设置的点这里~ 传入了 projectName 参数 然后重新启动调试服务加入projectName 后的 launch.json1234567891011121314&#123; "version": "0.2.0", "configurations": [ &#123; "type": "node", "request": "launch", "name": "启动程序", "program": "$&#123;workspaceFolder&#125;/packages/create-react-app/index.js", "args": [ "test-create-react-app" ] &#125; ]&#125; 隐藏的 commander 参数接着走判断完 projectName 之后，来到 Line140 createReactApp.js1234567const hiddenProgram = new commander.Command() .option( '--internal-testing-template &lt;path-to-template&gt;', '(internal usage only, DO NOT RELY ON THIS) ' + 'use a non-standard application template' ) .parse(process.argv); 可以看到这个是一个隐藏的调试选项，给出一个参数用于传入模版路径，给开发人员调试用的…没事不折腾他 createApp1234567createApp( projectName, program.verbose, program.scriptsVersion, program.useNpm, hiddenProgram.internalTestingTemplate); 接着往下就是调用了 createApp, 传入的参数对于的含义是：项目名，是否输出额外信息，传入的脚本版本，是否使用npm，调试的模板路径。接下来单步进入函数体看一下 createApp 到底做了什么事情。 createReactApp.js createApp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function createApp(name, verbose, version, useNpm, template) &#123; const root = path.resolve(name); const appName = path.basename(root); checkAppName(appName); // 检查传入的项目名合法性 fs.ensureDirSync(name); // 这里的fs用的是 fs-extra， 对node的fs提供一些扩展方法 // 判断新建这个文件夹是否是安全的 不安全直接退出 if (!isSafeToCreateProjectIn(root, name)) &#123; process.exit(1); &#125; // 在新建的文件夹下写入 package.json 文件 const packageJson = &#123; name: appName, version: '0.1.0', private: true, &#125;; fs.writeFileSync( path.join(root, 'package.json'), JSON.stringify(packageJson, null, 2) ); const useYarn = useNpm ? false : shouldUseYarn(); const originalDirectory = process.cwd(); process.chdir(root); // 如果是使用npm，检测npm是否在正确目录下执行 if (!useYarn &amp;&amp; !checkThatNpmCanReadCwd()) &#123; process.exit(1); &#125; // 判断node环境，输出一些提示信息, 并采用旧版本的 react-scripts if (!semver.satisfies(process.version, '&gt;=6.0.0')) &#123; // 输出一些提示更新信息 version = 'react-scripts@0.9.x'; &#125; if (!useYarn) &#123; // 检测npm版本 判断npm版本，如果低于3.x，使用旧版的 react-scripts旧版本 const npmInfo = checkNpmVersion(); if (!npmInfo.hasMinNpm) &#123; version = 'react-scripts@0.9.x'; &#125; &#125; // 判断结束之后，跑run 方法 // 传入 项目路径，项目名， reactScripts版本， 是否输入额外信息， 运行的路径， 模板（开发调试用的）, 是否使用yarn run(root, appName, version, verbose, originalDirectory, template, useYarn);&#125; createReactApp.js createApp 传送门这里我精简了一些东西，删除一些输出信息，加了一些注释createApp 主要做的事情就是做一些安全判断比如：检查项目名是否合法，检查新建的话是否安全，检查npm版本，处理react-script的版本兼容具体的执行逻辑写在注释里了，一系列的检查处理之后，调用 run 方法，传入参数为 项目路径，项目名， reactScripts版本， 是否输入额外信息， 运行的路径， 模板（开发调试用的）, 是否使用yarn。了解大概的流程之后，再一个函数一个函数进去看。 checkAppName() // 检查传入的项目名合法性isSafeToCreateProjectIn(root, name) // 判断新建这个文件夹是否是安全的shouldUseYarn() // 检查yarncheckThatNpmCanReadCwd() // 检查npmrun() // 检查完之后调用run执行安装等操作 checkAppName 检查projectName是否合法createReactApp.js checkAppName1234567891011function checkAppName(appName) &#123; const validationResult = validateProjectName(appName); if (!validationResult.validForNewPackages) &#123; // 判断是否符合npm规范如果不符合，输出提示并结束任务 &#125; const dependencies = ['react', 'react-dom', 'react-scripts'].sort(); if (dependencies.indexOf(appName) &gt;= 0) &#123; // 判断是否重名，如果重名则输出提示并结束任务 &#125;&#125; checkAppName 用于判断当前的项目名是否符合npm规范，比如不能大写等，用的是一个validate-npm-package-name的npm包。这里简化了大部分的错误提示代码，但是不影响口感。 shouldUseYarn 判断是否有装yarn 同理的有 checkThatNpmCanReadCwd 用来判断npmcreateReactApp.js shouldUseYarn12345678function shouldUseYarn() &#123; try &#123; execSync('yarnpkg --version', &#123; stdio: 'ignore' &#125;); return true; &#125; catch (e) &#123; return false; &#125;&#125; run前面的那些操作可以说都是处理一些判断与兼容逻辑，到run这里才是 真正的核心安装逻辑，开始安装依赖，拷贝模版等。 createReactApp.js run1234567function run(...) &#123; // 这里获取要安装的package，默认情况下是 `react-scripts`。 也可能是根据传参去拿对应的包 const packageToInstall = getInstallPackage(version, originalDirectory); // 需要安装所有的依赖， react, react-dom, react-script const allDependencies = ['react', 'react-dom', packageToInstall]; ...&#125; run 做的事情主要有这么几个，先根据传入的版本version 和原始目录originalDirectory 去获取要安装的某个 package。默认的 version 为空,获取到的 packageToInstall 值是 react-scripts, 然后将packageToInstall拼接到 allDependencies意为所有需要安装的依赖。这里说一下react-scripts其实就是一系列的webpack配置与模版，属于 create-react-app 另一个核心的一个大模块。传送门 createReactApp.js run1234567891011121314151617181920212223function run(...) &#123; ... // 获取包名，支持 taz|tar格式、git仓库、版本号、文件路径等等 getPackageName(packageToInstall) .then(packageName =&gt; // 如果是yarn,判断是否在线模式（对应的就是离线模式），处理完判断就返回给下一个then处理 checkIfOnline(useYarn).then(isOnline =&gt; (&#123; isOnline: isOnline, packageName: packageName, &#125;)) ) .then(info =&gt; &#123; const isOnline = info.isOnline; const packageName = info.packageName; /** 开始核心的安装部分 传入`安装路径`，`是否使用yarn`,`所有依赖`，`是否输出额外信息`，`在线状态` **/ /** 这里主要的操作是 根据传入的参数，开始跑 npm || yarn 安装react react-dom等依赖 **/ /** 这里如果网络不好，可能会挂 **/ return install(root, useYarn, allDependencies, verbose, isOnline).then( () =&gt; packageName ); &#125;) ...&#125; 然后如果当前是采用yarn安装方式的话，就判断是否处于离线状态。判断完连着前面的 packageToInstall 和 allDependencies 一起丢给 install 方法，再由install方法去跑安装。 run方法getInstallPackage(); // 获取要安装的模版包 默认是 react-scriptsinstall(); // 传参数给install 负责安装 allDependenciesinit(); // 调用安装了的 react-scripts/script/init 去拷贝模版.catch(); // 错误处理 installcreateReactApp.js install123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function install(root, useYarn, dependencies, verbose, isOnline) &#123; // 主要根据参数拼装命令行，然后用node去跑安装脚本 如 `npm install react react-dom --save` 或者 `yarn add react react-dom` return new Promise((resolve, reject) =&gt; &#123; let command; let args; // 开始拼装 yarn 命令行 if (useYarn) &#123; command = 'yarnpkg'; args = ['add', '--exact']; // 使用确切版本模式 // 判断是否是离线状态 加个状态 if (!isOnline) &#123; args.push('--offline'); &#125; [].push.apply(args, dependencies); // 将cwd设置为我们要安装的目录路径 args.push('--cwd'); args.push(root); // 如果是离线的话输出一些提示信息 &#125; else &#123; // npm 安装模式，与yarn同理 command = 'npm'; args = [ 'install', '--save', '--save-exact', '--loglevel', 'error', ].concat(dependencies); &#125; // 如果有传verbose， 则加该参数 输出额外的信息 if (verbose) &#123; args.push('--verbose'); &#125; // 用 cross-spawn 跨平台执行命令行 const child = spawn(command, args, &#123; stdio: 'inherit' &#125;); // 关闭的处理 child.on('close', code =&gt; &#123; if (code !== 0) &#123; return reject(&#123; command: `$&#123;command&#125; $&#123;args.join(' ')&#125;`, &#125;); &#125; resolve(); &#125;); &#125;);&#125; 我们顺着断点从run跑到install方法，能看到代码里根据是否使用yarn分成两种处理方法。if (useYarn) { yarn 安装逻辑 } else { npm 安装逻辑 }处理方法都是同个逻辑，根据传入的 dependencies 去拼接需要安装的依赖，主要有 react,react-dom,react-script 。再判断verbose和isOnline 加一些命令行的参数。最后再用node跑命令，平台差异的话是借助cross-spawn去处理的，这里不再赘述。具体逻辑见上面代码，去掉不重要的信息输出，代码还是比较易懂。 install根据传进来的参数判断用yarn还是npm拼装需要的依赖用cross-spawn跑命令安装 在install会返回一个Promise在安装完之后，断点又回到我们的run函数继续走接下来的逻辑。createReactApp.js run12345678910function run() &#123; ... getPackageName() .then(()=&gt; &#123; return install(root, useYarn, allDependencies, verbose, isOnline).then( () =&gt; packageName ); &#125;) ...&#125; 既然我们的install已经把开发需要的依赖安装完了，接下来我们可以开判断当前运行的node是否符合我们已经安装的react-scripts里面的packages.json要求的node版本。这句话有点绕，简单来说就是判断当前运行的node版本是否react-scripts这个依赖所需。 然后就把开始修改package.json我们已经安装的依赖(react, react-dom, react-scripts)版本从原本的精确版本eg(16.0.0)修改为高于等于版本eg(^16.0.0)。这些处理做完之后，我们的目录是长这样子的，里面除了安装的依赖和package.json外没有任何东西。所以接下来的操作是生成一些webpack的配置和一个简单的可启动demo。 那么他是怎么快速生成这些东西的呢？还记得一开始说了有一个 隐藏的命令行参数 --internal-testing-template 用来给开发者调试用的吗，所以其实create-react-app生成这些的方法就是直接把某一个路径的模板拷贝到对应的地方。是不是很简单粗暴hhhhh createReactApp.js run12345678910111213141516171819202122232425262728293031323334353637run(...) &#123; ... getPackageName(packageToInstall) .then(...) .then(info =&gt; install(...).then(()=&gt; packageName)) /** install 安装完之后的逻辑 **/ /** 从这里开始拷贝模板逻辑 **/ .then(packageName =&gt; &#123; // 安装完 react, react-dom, react-scripts 之后检查当前环境运行的node版本是否符合要求 checkNodeVersion(packageName); // 该项package.json里react, react-dom的版本范围，eg: 16.0.0 =&gt; ^16.0.0 setCaretRangeForRuntimeDeps(packageName); // 加载script脚本，并执行init方法 const scriptsPath = path.resolve( process.cwd(), 'node_modules', packageName, 'scripts', 'init.js' ); const init = require(scriptsPath); // init 方法主要执行的操作是 // 写入package.json 一些脚本。eg: script: &#123;start: 'react-scripts start'&#125; // 改写README.MD // 把预设的模版拷贝到项目下 // 输出成功与后续操作的信息 init(root, appName, verbose, originalDirectory, template); if (version === 'react-scripts@0.9.x') &#123; // 如果是旧版本的 react-scripts 输出提示 &#125; &#125;) .catch(reason =&gt; &#123; // 出错的话，把安装了的文件全删了 并输出一些日志信息等 &#125;);&#125; 这里安装完依赖之后，执行checkNodeVersion判断node版本是否与依赖相符。之后拼接路径去跑目录/node_modules/react-scripts/scripts/init.js，传参让他去做一些初始化的事情。然后对出错情况做一些相应的处理 /node_modules/react-scripts/script/init.js目标文件夹/node_modules/react-scripts/script/init.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687module.exports = function( appPath, appName, verbose, originalDirectory, template) &#123; const ownPackageName = require(path.join(__dirname, '..', 'package.json')) .name; const ownPath = path.join(appPath, 'node_modules', ownPackageName); const appPackage = require(path.join(appPath, 'package.json')); const useYarn = fs.existsSync(path.join(appPath, 'yarn.lock')); // 1. 把启动脚本写入目标 package.json appPackage.scripts = &#123; start: 'react-scripts start', build: 'react-scripts build', test: 'react-scripts test --env=jsdom', eject: 'react-scripts eject', &#125;; fs.writeFileSync( path.join(appPath, 'package.json'), JSON.stringify(appPackage, null, 2) ); // 2. 改写README.MD，把一些帮助信息写进去 const readmeExists = fs.existsSync(path.join(appPath, 'README.md')); if (readmeExists) &#123; fs.renameSync( path.join(appPath, 'README.md'), path.join(appPath, 'README.old.md') ); &#125; // 3. 把预设的模版拷贝到项目下，主要有 public, src/[APP.css, APP.js, index.js,....], .gitignore const templatePath = template ? path.resolve(originalDirectory, template) : path.join(ownPath, 'template'); if (fs.existsSync(templatePath)) &#123; fs.copySync(templatePath, appPath); &#125; else &#123; return; &#125; fs.move( path.join(appPath, 'gitignore'), path.join(appPath, '.gitignore'), [], err =&gt; &#123; /* 错误处理 */ &#125; ); // 这里再次进行命令行的拼接，如果后面发现没有安装react和react-dom,重新安装一次 let command; let args; if (useYarn) &#123; command = 'yarnpkg'; args = ['add']; &#125; else &#123; command = 'npm'; args = ['install', '--save', verbose &amp;&amp; '--verbose'].filter(e =&gt; e); &#125; args.push('react', 'react-dom'); const templateDependenciesPath = path.join( appPath, '.template.dependencies.json' ); if (fs.existsSync(templateDependenciesPath)) &#123; const templateDependencies = require(templateDependenciesPath).dependencies; args = args.concat( Object.keys(templateDependencies).map(key =&gt; &#123; return `$&#123;key&#125;@$&#123;templateDependencies[key]&#125;`; &#125;) ); fs.unlinkSync(templateDependenciesPath); &#125; if (!isReactInstalled(appPackage) || template) &#123; const proc = spawn.sync(command, args, &#123; stdio: 'inherit' &#125;); if (proc.status !== 0) &#123; console.error(`\`$&#123;command&#125; $&#123;args.join(' ')&#125;\` failed`); return; &#125; &#125; // 5. 输出成功的日志&#125;; init文件又是一个大头，处理的逻辑主要有 修改package.json，写入一些启动脚本，比如script: {start: &#39;react-scripts start&#39;}，用来启动开发项目 改写README.MD，把一些帮助信息写进去 把预设的模版拷贝到项目下，主要有 public, src/[APP.css, APP.js, index.js,....], .gitignore 对旧版的node做一些兼容的处理，这里补一句，在选择 react-scripts 时就有根据node版本去判断选择比较老的 @0.9.x 版。 如果完成输出对应的信息，如果失败，做一些输出日志等操作。 这里代码有点多，所以删了一小部分，如果对初始的代码感兴趣可以跳转到这儿看react-scripts/scripts/init.js 传送门 END~到这里 create-react-app 项目构建的部分大流程已经走完了，我们来回顾一下： 判断node版本如果小于4就退出，否则执行 createReactApp.js 文件 createReactApp.js先做一些命令行的处理响应处理，然后判断是否有传入 projectName 没有就提示并退出 根据传入的 projectName 创建目录，并创建package.json。 判断是否有特殊要求指定安装某个版本的react-scripts，然后用cross-spawn去处理跨平台的命令行问题，用yarn或npm安装react, react-dom, react-scripts。 安装完之后跑 react-scripts/script/init.js 修改 package.json 的依赖版本，运行脚本，并拷贝对应的模板到目录里。 处理完这些之后，输出提示给用户。 本来想把整个 create-react-app 说完，但是发现说一个创建就写了这么多，所以后面如果有想继续看 react-scripts的话，会另外开一篇来讲。大家也可以根据这个思路自己断点去看，不过 react-scripts 主要可能是webpack配置居多，断点帮助应该不大。 create-react-app系列第二篇传送门]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>github</tag>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-04-29面试记A]]></title>
    <url>%2F2018%2F04%2F2018-04-29%2F</url>
    <content type="text"><![CDATA[4.10号 已经在租租车呆了一周年，一直有个规律是 大概一年就要去外面找找虐。一方面是为了下外面的市场，看下有没有更好的机会另一方面是在一个地方待久了 可能会变得比较安逸，比较老油条，这时候去外面和其他公司前端面试沟通，可以了解外面的技术让自己更有目的性、更有动力去学习。 但是今年的情况有点出乎我意料，不知道是因为金三银四加上今年过年早的原因，所以基本企业单位坑都填满了，还是现在选择公司比较挑剔，高不成低不就。 规模太小不想去，二三线互联网公司，基本又要求本科…哎 学历的短板变得越来越大 简历投递情况据不完全统计:内推 YY 不合适内推 汇桔 目前只招5年的内推 路客 面试 也是目前唯一一个有面试机会的！！！ 但是薪资涨幅一般~投 广州银行信用卡 不合适 要求本科投 中兴 不合适 要求本科 = =吐槽一句 估计中兴现在也不敢招人了投 荔枝 被查看，没有联系 也是没戏了Boss直聘沟通 100教育 目前只招5年的沟通 拼多多 惨遭无视 也是要求本科 现在boss直聘，拉钩疯狂沟通 尚德机构 好像也没什么回应~ 要求也是本科，虽然说明了目前正在自考本科，但是自考时间最理想也要两年…哎哎 面试情况前同事推的 路客 是唯一的面试机会… 之所以想去是因为，当时看了他们的app 使用RN写的，个人比较有兴趣，而且体验的时候还觉得很不错。很少有公司会从零开始用RN写，一般都是比较边角的 表单提交啊 FAQ About 等等的页面采用原生内嵌RN实现。 面试没有问的很细，基本就是现在比较喜欢的面试方式 问项目经验，React生命周期，diff算法，微信开放平台，对vue掌握程度，有没有做过RN项目，离职原因等其中问到一个是 有没有系统学习23种设计模式我当时的回答是 没有系统学习过，不过平时工作有用到 工厂模式 单例模式 等比较常用的设计模式。想起之前看张容铭的《JavaScript设计模式》 学习计划现在工作三年，感觉反而没有刚开始工作那会基础知识牢固。以前刚入行，还不知道jq这种东西，写轮播图，写效果都是用原生js，还兼容ie~~~ 不能说特别叼，但是至少基础很牢固现在好像各类 mv* 库帮我们做了很多事情，所以我们除了一开始的 项目搭建，结构划分，路由配置等，剩下的主要精力都用来处理业务逻辑，更多的是想着如何去解决一个问题，而不是死记着那些东西，但是这边拿一块 那边拿一块会导致很难形成属于自己的东西。也没有很系统的学习一些东西，太过浮躁 目前学习计划是 看 create-react-app 源码，了解怎么实现，断点调试，输出文章 看 vue 源码，系统学习一下vue 用到项目上，而不是停留到 看过api的层次emmmm 想起vue刚出的时候，用了一个饿了么出的 移动端ui库 mint-ui 还贡献过一点点bug-request 有关于 node 后台的项目机会积极一点，硬着头皮上 以上~ emmmm 最后多投看看还有什么面试机会… 尚德没有得面试真是有点失落]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件重复绑定与stopImmediatePropagation]]></title>
    <url>%2F2018%2F04%2F%E4%BA%8B%E4%BB%B6%E9%87%8D%E5%A4%8D%E7%BB%91%E5%AE%9A%E4%B8%8EstopImmediatePropagation%2F</url>
    <content type="text"><![CDATA[在旧项目中，我们一般绑定事件都是用 $(&#39;selector&#39;).on(&#39;event&#39;, fn) || document.querySelector(&#39;selector&#39;).addEventListener(&#39;event&#39;, fn); 如果平时代码规范，这样写完全ojbk 点击.p 之后输出 test1demo1123456789&lt;div id="id"&gt; &lt;p class="p"&gt;test1&lt;/p&gt;&lt;/div&gt;&lt;script&gt; function add(selector, fn) &#123; document.querySelector(selector).addEventListener('click',fn); &#125; add('.p', e=&gt; console.log(e.currentTarget.innerHTML));&lt;/script&gt; 但是平时如果项目不规范，代码又写的比较乱….emmmm，很有可能出现一些逻辑上的低级错误，比如这种，在某个函数调了两次，所以这里就绑定了两次…点击之后会输出两次的 testdemo212345678910&lt;div id="id"&gt; &lt;p class="p"&gt;test1&lt;/p&gt;&lt;/div&gt;&lt;div class="p1"&gt;test2&lt;/div&gt;&lt;script&gt; function add(selector, fn) &#123; document.querySelector(selector).addEventListener('click',fn); &#125; function fn1() &#123; add('.p', e=&gt; console.log(e.currentTarget.innerHTML)); &#125;; fn1(); fn1();&lt;/script&gt; 这种情况平时工作不注意真的有可能发生，而且排查也只能说平时在看接口或改代码的时候 发现随手改 一般为了避免这种失误重复调用的操作，有几种方法： 把事件处理函数抽出来,这样就算重复绑定，浏览器检测到是同个函数引用，会做相应的优化，所以不会重复绑定到事件上 12345678&lt;script&gt; function add(selector, fn) &#123; document.querySelector(selector).addEventListener('click',fn); &#125; const evFn= e=&gt; console.log(e.currentTarget.innerHTML); function fn1() &#123; add('.p', evFn)&#125;; fn1(); fn1(); fn1();&lt;/script&gt; 使用 event.stopImmediatePropagation官方给出的说明是：如果某个元素有多个相同类型事件的事件监听函数,则当该类型的事件触发时,多个事件监听函数将按照顺序依次执行.如果某个监听函数执行了 event.stopImmediatePropagation()方法,则除了该事件的冒泡行为被阻止之外(event.stopPropagation方法的作用),该元素绑定的后序相同类型事件的监听函数的执行也将被阻止. 简单来说就是，执行了event.stopImmediatePropagation() 之后，后续的绑定在该dom上的相同类型事件都不再被响应，也不冒泡。 demo3 代码，点击 test1 之后，只会在控制台输出一行 test1，其他 该元素的点击事件，#id点击事件都不会被响应demo31234567891011&lt;div id="id"&gt; &lt;p class="p"&gt;test1&lt;/p&gt;&lt;/div&gt;&lt;script&gt; function add(selector, fn) &#123; document.querySelector(selector).addEventListener('click',fn); &#125; function fn1() &#123; add('.p', e=&gt; console.log(e.currentTarget.innerHTML)|| e.stopImmediatePropagation())&#125;; add('#id',e=&gt;console.log(1)); fn1(); fn1(); fn1();&lt;/script&gt; 在实际项目中，还是比较建议把事件处理逻辑抽出来当一个函数，毕竟在多人项目里面 stopImmediatePropagation 比较容易误伤队友…]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化功能测试流程方案]]></title>
    <url>%2F2018%2F04%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[Introduction得益于谷歌开源了 puppeteer 无界面版的 Chrome nodeJs api。现在前端可很方便快捷的开发一些脚本去跑浏览器端的操作，包括自动化测试，爬虫或其他比较机械化的操作。可以参见我上一篇文自动化测试 puppeteer 与qq空间 ps: 🤦‍ 早知道当时删微博就直接写一个脚本，人工去删还漏了一些被批斗了一顿 既然 puppeteer 可以拿来做这么多事情，那前端是不是可以整合出一套流程测试的方案？ 大概的流程是： 定时跑业务流程 成功则发送一条消息通知服务器 失败则 截图发送截图与其他信息 到达一定的阈值就通知相关人员排查问题 提供一个前端页面可以查询 任务情况 123456789101112131415161718192021222324252627282930313233 +-------------------+ +-----------------------------&gt; | 记录消息 | | success | | | +------+------------+ | |+-------+------+ || | v| 定时跑测试任务 | +-----+-----------+| | | || | | |+------+-------+ | 查看任务记录 | | | | | | | | +-----+-----------+ | ^ | | | error +-----+----------+ | | | +-------------------------------&gt; | 记录消息 | | | | | +-------+--------+ | | | 阈值 | +--------v---------+ | | | | | 通知人员 | | | | | +------------------+ 用到的技术栈自动化测试: puppeteer + axios + node-schedule后台: egg + mongoose前端界面: antd + dva 其实主要就 puppeteer + egg + mongoose 即可，前端界面只是刚好公司一个后台是用 antd-pro 写的 所以顺手带上去而已 = =# 本地一些环境：node 8.9.4, npm 5.6.0, oxs 10.13.3， 编辑器 vscodeeeeee 以下涉及到公司项目业务的 都会略过讲一下过程 不会出现具体代码或截图等… 自动化测试(auto_test)部分目录结构: 入口: app.js 主要处理一些获取自动化测试浏览器的对象， 项目启动， 定时任务启动app.js1234567891011121314151617181920212223const mMonitor = require('./scripts/m'); // m端测试脚本入口const xDate = require('xdate');const login = require('./scripts/login'); // 登录操作处理const &#123; scheduleDelPic &#125; = require('./scripts/schedule'); // 定时任务// 项目入口;(async()=&gt; &#123; // 因为公司项目需要一些前置的 操作才能访问，比如登录管理后台等操作， // 所以这里直接用一个文件把这一块抽出来，方便后面专心处理业务 不用关心用户登录 权限 测试账号等问题 // 处理完直接返回一个 browser 对象，后面的其他测试只需要在当前的 browser 新开一个tab去跑即可 const browser = await login(); // m端项目 mMonitor(browser); // 传入browser 对象 开始处理自动化测试 // 10分钟跑一次，这里也可以把间隔抽出来放到config里 // 多嘴说一句，用setInterval 有一个弊端就是，前面执行脚本堵塞，会造成 一个任务跑完 直接跑下一个，中间不是间隔10min。 看具体的业务需求，也可以用 setTimeout 或者递归等去执行 setInterval(() =&gt; mMonitor(browser), 1000 * 3600 * 1); // 其他的任务 定时任务等 // 这里是写了个定时清理图片 scheduleDelPic();&#125;)(); 前置处理: login.js (这里可以取其他名字)对于我这个项目来说 在开始跑之前要处理测试账号登录等问题，因为考虑到后面会有多个任务在跑的话，直接在 browser 对象 create new tab 可以同步跑，而不用每次都去处理登录问题。 login.js123456789101112131415const puppeteer = require('puppeteer');module.exports = async function () &#123; const browser = await puppeteer.launch(&#123; headless: false, devtools: true, slowMo: 100, ignoreHTTPSErrors: true, &#125;); // 处理一些其他的逻辑 // ... // 把处理完的 browser 返回回去 return browser;&#125; mMonitor 移动端测试任务主要处理的事情有： 调用其他的流程测试任务，比如我是： 公司项目的主流程下单任务 处理一些需要记录的信息，比如从什么时候跑，什么时候结束 处理与服务器的交互，成功调接口 失败截图保存用户信息等 传递给服务端 m.js1234567891011121314151617181920212223242526272829303132333435363738394041module.exports = async function mMonitor(browser) &#123; // 建立一个 page 的引用，方便后面可以调用方法 let page; try &#123; startTime = Date.now(); page = await browser.newPage(); // 把页面传入主流程的测试任务 // 这里面就有超级无敌大量的 业务代码... emmm 根据项目不同来写 完全没有参考意义就不写了 await mainProcess(page); // 测试任务执行成功的处理 const params = &#123; // 测试结果数据 &#125; // 调接口存数据 const data = await mRequest(params); console.log('上报success接口成功', params); &#125; catch(e) &#123; // 跑测试流程中错误的对应处理 const params = &#123; // 错误结果的数据， 比如 // 截图地址url // title // url // serviceCode 等等 &#125; const data = await mRequest(params); console.log('上报error 接口成功', params); &#125; finally &#123; // 关闭当前页面 page.close(); // 其他操作... &#125;&#125; schedule 定时任务这里的定时任务用的是 node-schedule 非常好用 支持 Cron-style。 schedule.scheduleJob(cronStyle) cronStyle 参数 传入对应的时间，既可按照传入的参数 定时去执行，具体可以看👆链接 1234567891011cronStyle: * * * * * *┬ ┬ ┬ ┬ ┬ ┬│ │ │ │ │ ││ │ │ │ │ └ day of week (0 - 7) (0 or 7 is Sun)│ │ │ │ └───── month (1 - 12)│ │ │ └────────── day of month (1 - 31)│ │ └─────────────── hour (0 - 23)│ └──────────────────── minute (0 - 59)└───────────────────────── second (0 - 59, OPTIONAL) 目前 auto_test 用到的定时任务只有一个1234567891011121314151617181920212223const schedule= require('node-schedule');const path = require('path');const fs = require('fs');//删除某个目录的一层文件function delPathFile(path) &#123; if (!fs.existsSync(path)) return; const files = fs.readdirSync(path); files.forEach(file =&gt; fs.unlinkSync(`$&#123;path&#125;/$&#123;file&#125;`));&#125;// 定时删除图片，每周一一次exports.scheduleDelPic = function() &#123; const initPath = path.join(process.cwd(), '/static/init'); const errorPath = path.join(process.cwd(), '/static/error'); const successPath = path.join(process.cwd(), '/static/success'); schedule.scheduleJob('* * * * * 1', function () &#123; delPathFile(initPath); delPathFile(errorPath); delPathFile(successPath); &#125;);&#125; 总的来说 auto_test 做的事情大概就是 启动 app.js， 项目就会 10分钟自动跑一次测试程序。 成功、失败后做出对应的操作。 每周清除一次本地的截图数据。 但是几个弊端 puppeteer 是模拟浏览器，所以你的所有行为都是模拟用户操作：选择dom，点击、填写、选择操作。这些都是很容易因为页面的dom变化而失效，比如本来是选了一个 #userId的文本框，后面迭代把 #userId改为#uuid 那你就选不到了。 所以业务测试代码(__mainProcess__模块) 做好模块拆分，后面跟项目迭代也方便调整。 因为网络或dom操作经常触发异步行为，所以业务测试代码里面充满各种 waitFor waitForSelector waitForNative 等…不注意可能就会操作到没有出现的元素，这块要做好控制，比如waitFor 时间久一点，或者在page上封装一个方法，比如 page._click:1234async _click(selector) &#123; await page.waitForSelector(selector, &#123; visible: true &#125;); return page.click(selector);&#125;, 在每次点击之前，先等待该元素出现再点击。这样可以避免很多运行时 没有找到元素的错误 模仿用户行为测试的话，意味着你要做一些前置的处理 如login.js， 要把账号密码等写到代码里面…虽然可以加密 不过还是会存在部分泄露风险… 自动化测试服务端(auto_test_backend)部分对比 auto_test 部分， auto_test_backend才是我最头疼的地方。毕竟不是科班出身的前端，对后端思想 以及数据库操作也没碰过= =emmm 做起来真的是超级无敌的费劲特别是 设计数据格式的时候，都是拍脑袋决定了。 咦 我加个字段， 咦 我改个字段 又不是很清楚怎么快捷操作…. 估计是不熟 mongoose 的原因…. 这个项目用的是 egg 框架，所以基本项目结构都是按着egg的规范来。 目录结构: egg 帮我们做了很多事情，开发的时候只要跑一下 npm run dev，就会启动一个默认端口为7001的服务 对我们现在来说，基本只是提供 RESTAPI。剩下的就简单啦，在app/router.js写对应的路由 如:router.post(&#39;/api/v1/monitor&#39;, app.controller.monitor.create); 这样如果有post请求:7001/api/v1/monitor 就会交由 monitor.create 这个 controller 处理。 路由配置 app/router.js目前路由配置比较简单，就配置了两个，一个用来处理接收 auto_test项目中测试结果；一个用来输出测试列表。 app/router.js12345678module.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; // post 请求交由app.controller.monitor.create处理 router.post('/api/v1/monitor', app.controller.monitor.create); // get 请求交由app.controller.monitor.get处理 router.get('/api/v1/monitor', app.controller.monitor.get);&#125;; controller 解析用户的输入，处理后返回相应的结果egg帮我们做了封装，直接在controller文件夹下起文件，写对应的数据，后面可以从全局对象app.controller.fileName.mothedName去获取对应的方法，比如现在有这个文件 app/controller/test，那么我可以在其他地方通过 app.controller.test去获取。 这里拿 app.controller.monitor.get 举例 monitor.get 方法要做的事情有 验证结构的请求参数规则 处理查询参数 处理分页的问题 调service 获取数据 处理数据 调用rest中间件发送数据 验证参数，这里用到的是 egg-validate插件，直接配置就可以用了 config/plugin.js1234exports.validate = &#123; enable: true, package: 'egg-validate',&#125;; app/controller/monitor.js12345678910111213141516171819202122232425262728293031323334353637383940414243const Controller = require('egg').Controller;module.exports = class MonitorController extends Controller &#123; const ctx = this.ctx; // 这里验证失败会抛出一个 422 的异常 ctx.validate(&#123; start: &#123; type: 'number', require: false&#125;, // end, state, pagination等等其他参数验证 &#125;); // 获取传过来的参数 const &#123; start, end, state, pagination: _pagination&#125; = ctx.query; // 根据自身业务 处理查询参数 (typeof state !== 'undefined') &amp;&amp; (params.state = state); if (start &amp;&amp; end) &#123; Object.assign(params, &#123; time: &#123; $gte: start, $lte: end, &#125; &#125;); &#125; // 处理分页参数 const paramsPagination = Object.assign(&#123; size: 20, page: 1 &#125;, JSON.parse(_pagination || '&#123;&#125;')); // 调 service 获取数据 // service也和 controller 一样，egg做了文件的映射，直接 ctx.service能很方便的去获取 const &#123; list, pagination &#125; = await ctx.service.monitor.find(&#123; params, ...paramsPagination &#125;); // 处理数据 list.forEach(item =&gt; &#123; item.img_url = `http://localhost:7001$&#123;item.img_url&#125;` &#125;); // 调 rest中间件 处理返回数据 ctx.rest(&#123; list, pagination, &#125;);&#125; service 处理一些和数据库交互的逻辑service和controller 一样，egg帮我们做了一些文件的映射，所以也是直接在app/service/monitor.js写对应的逻辑即可 这一块应该是最麻烦的， mongoose api 不熟，也不确定这么写会不会最优,合不合理等…有时间或者以后有机会 会去看《SQL必知必会》 学学数据库这一块软肋。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const Service = require('egg').Service;module.exports = class MoitorService extends Service &#123; async find(&#123;params, size, page&#125;) &#123; // 查复合条件的页数 const count = await this.app.model.Monitor .find(params).count(); // 处理分页 const monitors = await this.app.model.Monitor .find(params).sort('time').select('-__v') .skip(size * (page-1)) .limit(size).lean(); // 处理要返回的格式 return &#123; list: monitors, pagination: &#123; count, size, page, &#125; &#125;; &#125;&#125;``` ## middleware 中间件egg 其实基于koa实现的，所以对中间件形式和koa一样是洋葱圈模型。集成中间件也很简单，在`app/middleware/`下写对应的中间件，再在 `config/config.default.js`下配置即可启用。写中间件```javascript app/middleware/error_handler.jsmodule.exports = ()=&gt; &#123; return async function errorHandler(ctx, next) &#123; try &#123; await next(); &#125; catch (err) &#123; // 所有异常都在 app 上触发一个 error 事件 ctx.app.emit('error', err, ctx); const status = err.status || 500; // 生产环境时 500 错误的详细错误内容不返回给客户端，可能包含敏感信息 const error = status === 500 &amp;&amp; ctx.app.config.env === 'prod' ? 'Internal Server Error' : err.message; // 从 error 对象上读出各个属性 设置到响应中 ctx.body = &#123; error &#125;; if (status === 422) &#123; ctx.body.detail = err.errors; &#125; ctx.status = status; &#125; &#125;&#125; 添加配置app/config/config.default.js12345678910111213module.exports = appInfo=&gt; &#123; const config = &#123; // 中间件配置 middleware: ['errorHandler'], // errorHandler配置，只对 /api 开头的路由做处理 errorHandler: &#123; match: '/api', &#125; &#125; return config;&#125; 阈值发送邮件功能这一块要维护两个临时变量数组，三个配置参数1234567891011121314151617const temp = &#123;&#125;;temp.errorObj = &#123; errorArray: [], // 用来存每次错误上报的时间戳 sendArray: [], // 用来存每次发送的时间戳&#125;const errorConfig = &#123; maxCount: 5, // 单位时间超过n次就报警 unitTime: 30, // 单位时间为：n分钟 maxSend: 2, // 单位时间最多发n封邮件&#125;大概的逻辑是， 每次报错的时候， errorArray 塞入一个时间戳，然后判断：1. 判断是否到达发送阈值2. 根据当前的时间戳和配置来清理过期的数据3. 判断单位时间内是否达到发送阈值4. 判断单位时间内是否超过发送次数5. 构建发送内容， 🚀 处理后续的记录操作 用到的发邮件插件是 nodemailer 简单粗暴 用过都说好 and其实 auto_test_project 最麻烦的是在定义数据库格式的时候，经常定义少一些关键的字段（目前肯定也还存在这种情况的）。还有就是本来以为和 angular 一样，controller 会塞大量的业务逻辑， 等到后面有一个场景是要在某个 controller调用另一个controller 时才发现，原来 controller 主要的职责是负责处理路由和一些参数验证输出等比较对外的工作，对内的基本都写成了service。 前端的小伙伴很多人懂node 可能也只是懂node的语法层 要想真的写后台或者微全栈，还是有很多东西要学的。 列表展示(admin)项目列表展示相对简单，没什么好讲的。想用什么技术栈都比较随意，react,vue甚至hbs或者直接在js里面写html字符串循环都ok。 这里推一下一篇文章，介绍工作中的一个项目 react全家桶 &amp;&amp; dva最佳实践 end跑自动化测试脚本(auto_test)的log 自动化测试成功后提交数据(admin) 自动化测试失败后将数据上报(admin) 包含了标题，报错信息，链接，截图，标记等 文章作为学习的记录到此结束，这个项目主要学习了 egg,mongodb,puppeteer 等 还是挺有收获的.]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>github</tag>
        <tag>JavaScript</tag>
        <tag>work</tag>
        <tag>puppeteer</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目代码规范工作流——editor、prettier、eslint、git-check]]></title>
    <url>%2F2018%2F03%2F%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%B7%A5%E4%BD%9C%E6%B5%81%E2%80%94%E2%80%94editor%E3%80%81prettier%E3%80%81eslint%E3%80%81git-check%2F</url>
    <content type="text"><![CDATA[背景最近部门进了挺多新前端，有实习生 有应届生，人一多代码规范就不能完全依赖 “口口相传” 去约束了， 特别是看到一堆的 有分号，无分号，四缩进，二缩进等问题 对于有小小代码洁癖的我实在是受不了 于是终于在项目中 集成各种用来 规范（约束）的工具。 主要有： editorConfig 编辑器配置文件 Prettier 批量格式化代码 Eslint js、jsx 文件代码检查规范 Flow (暂未集成) lint-staged 提交到git之前跑一次代码检查 本地一些环境：node 8.9.4, npm 5.6.0, oxs 10.13.3， 编辑器 vscodeeeeee EditorConfigWhat is EditorConfig?官网给出的答案是：editorconfig帮助开发人员在不同的编辑器和ide之间定义和维护一致的编码风格。简单来说就是跨编辑器使用同一份代码缩进等配置 EditorConfig 集成起来十分简单， 大概就是创建配置文件，安装相应的编辑器插件即可。 创建 .editorconfig 文件 安装对应编辑器的插件 我用的是 vscode 直接安装这个 EditorConfig for vs code，安装完重启，编辑器就会根据配置文件里面的配置来控制代码缩进等行为 附上项目的配置文件.editorconfig123456789101112root = true[*]charset = utf-8end_of_line = lf # mac linux/unix 都用lf。 window 设置 cr 在 *nix 有问题indent_size = 4indent_style = spacemax_line_length = 120trim_trailing_whitespace = true[*.jsx]indent_size= 2 Prettier现在有了一些基本的配置，以后写的代码就可以比较规范一点点点，但是原来的旧代码怎么办呢？不可能一个文件一个文件去打开吧，不完全统计 项目有上千个编辑的文件….一个一个去手动打开不符合程序员的风格 so… Prettier就是为我们做这些事情的 安装: npm i --save-dev prettier 创建 .prettierrc配置文件该配置文件会继承editorConfig的配置 向package.json添加脚本: &quot;prettier&quot;: &quot;prettier --write ./*&quot; 我项目里面用的是 &quot;prettier&quot;: &quot;prettier --write &#39;./src/**/*.js&#39; &#39;./src/**/*.jsx&#39; &#39;./src/**/*.css&#39; &#39;./src/**/*.scss&#39;&quot;, 创建 .prettierignore 文件，用来忽略一些文件 &amp;&amp; 目录 一切准备就绪之后 !!!! npm run prettier 呼呼 看到提示一千个文件更改记录 哈哈哈 附上配置文件:.prettierrc.js123456789// https://prettier.io/docs/en/options.htmlmodule.exports = &#123; trailingComma: "es5", // 数组 对象尾随逗号 [arr, ] &#123; obj, &#125; // bracketSpacing: true, // 对象空格 &#123; foo: bar &#125;, false=&gt; &#123;foo:bar&#125;// jsxBracketSameLine: false, // jsx闭标签是否另起一行 &lt;Test&gt;&lt;/Test&gt;// arrowParens: 'avoid', // 箭头函数是否省略括号 a=&gt; a, (a)=&gt; a singleQuote: true, // 单引号&#125; .prettierignore1234/node_modules/dist/src/lib//src/global/fonts Eslint有了上面介绍的 editor、prettier还是远远不够的，因为 js语法 不是很严格，比如有没有分号啊 之类的问题还是要用 eslint 来约束的。 在很多年前，我是特别反感 Eslint 的，因为经常写得一点不规范，直接就报 error 整个项目跑不起来。但是 存在即合理，现在觉得这东西贼好用。 安装 eslint: npm i --save-dev eslint 启动引导脚本: ./node_modules/.bin/eslint --init 配置 .eslintrc。 这里可以直接选 Use a popular style guide 然后选行业比较看好的规范 airbnb的，原先是打算选这个，但是后面发现和项目现有的规范很不相同，所以后面就走回答问题选项。 向 package.json 添加脚本: &quot;eslint&quot;: &quot;eslint --fix ./&quot; 我写的是 &quot;eslint&quot;: &quot;eslint --fix &#39;./src/**/*.{jsx, js}&#39;&quot;, 创建 .eslintignore 文件，并向其添加需要忽略的文件或目录。 安装 编辑器 eslint 插件 配置编辑器，我这里用的是 vscode “eslint.autoFixOnSave”: true 开启eslint 检查 “javascript.validate.enable”: false 关闭vscode自带的js检查 eslint插件会智能检查编辑状态的 JS 文件，并自动修复；npm run eslint 脚本可以检查和智能修复“对应的文件”。 不过亲测修复的效果比较一般，更多的报错需要手动去处理 在配置eslint的时候 遇到了几个比较郁闷的地方 可以先把一些报错项改为 警告项，慢慢迭代 免得一上eslint 要停几天来修改原来的文件一些简单的处理可以写脚本去做比如说之前项目写的比较不规范，出现了很多类似：export default from &#39;file-path&#39;的语句，但是eslint不认，觉得这是不符合规范的，需要改为 export { default } from &#39;file-path&#39; 这点我也比较认同，但是 这么多个文件，一个一个改是不存在的，所以写了个短脚本去处理 fix-export-default123456789101112131415161718192021222324252627282930313233const fs = require('fs');const path = require('path');function scan(&#123;dirPath&#125;) &#123; const isDirectory = fs.statSync(dirPath).isDirectory(); if (isDirectory) &#123; const childs = fs.readdirSync(dirPath); childs.forEach(child=&gt; &#123; const nextPath = path.join(dirPath, child); const stat = fs.statSync(nextPath); const isDirectory = stat.isDirectory(); const isFile = stat.isFile(); const extname = isFile &amp;&amp; path.extname(child); // 文件夹类型 递归 if (isDirectory) scan(&#123;dirPath: nextPath&#125;); // 排除不是 js jsx 的文件 if (!['.js', '.jsx'].includes(extname)) return; // 开始读文件 let fileStr = fs.readFileSync(nextPath) +''; const exg = /export default from/gi; if (exg.exec(fileStr)) fileStr = fileStr.replace('export default from', 'export &#123;default&#125; from'); fs.writeFileSync(nextPath, fileStr, &#123;encoding: 'utf-8'&#125;); &#125;); &#125;&#125;scan(&#123; dirPath: path.join(process.cwd(), '/src'),&#125;); webpack别名引用 路径报错问题安装对应的 eslint 处理插件: npm i --save-dev eslint-import-resolver-webpack eslint-plugin-import 在 .eslint.js 里面加这段配置 1234567"settings": &#123; 'import/resolver': &#123; webpack: &#123; config: getWebpackConfig, // 这里是webpack配置路径 &#125; &#125;,&#125;, 其他注意问题项目是在 浏览器运行， 又是 es6语法， 又有一些node脚本，会有一些全局的变量引用提示报错，怎么办？改配置!12345"env": &#123; browser: true, es6: true, node: true,&#125;, 项目是后端模版渲染的，会有一些全局变量，eslint报错怎么办？改配置!123456789101112131415"globals": &#123; __DEV__: true, __HTTPS__: true, FB: true, ga: true, $: true, ercjs: true, google: true, IS_APP: true, i18n: true, Zepto: true, AdjustEvent: true, Adjust: true, fbq: true,&#125;, 项目用了很多新语法 eslint 不识别, 用了 react 怎么办？改配置…具体的 谷歌一下 一堆答案 不再赘述 FlowFlow可以理解为 很轻量型 无侵入的 静态类型检查项目暂时没有考虑集成，所以这里不做过多介绍 git-check既然我们 有了编辑器的配置， js编辑实时检查， 但是如果有些小伙伴不遵守规则 搞事情怎么办呢？这时候我们可以在最后一个流程加上验证的部分， 在git 提交的时候跑一些脚本去验证，如果通过就给提交，不通过就提示错误 lint-staged 可以帮我们做这些事情 安装 lint-staged husky: npm i --save-dev lint-staged husky 向 package.json 添加运行脚本 &quot;precommit&quot;: &quot;lint-staged&quot; 这时候在git commit 之前会跑 lint-staged的东西 再向 package.json 添加内容: 注意，这时候不是加在 scripts里面，而是加在同级&quot;lint-staged&quot;: { // 上面提供的“自动化脚本” &quot;*.js&quot;: [&quot;eslint --fix&quot;, &quot;git add&quot;], &quot;*.json&quot;: [&quot;prettier --write&quot;, &quot;git add&quot;], &quot;*.css&quot;: [&quot;prettier --write&quot;, &quot;git add&quot;], &quot;*.scss&quot;: [&quot;prettier --write&quot;, &quot;git add&quot;], &quot;*.md&quot;: [&quot;prettier --write&quot;, &quot;git add&quot;] } 因为项目是本地打包再推远程，所以我的配置是指定了 src下的&quot;src/**/*.js&quot;: [ &quot;eslint --fix&quot;, &quot;git add&quot; ], &quot;src/**/*.jsx&quot;: [ &quot;eslint --fix&quot;, &quot;git add&quot; ], &quot;src/**/*.css&quot;: [ &quot;prettier --write&quot;, &quot;git add&quot; ], &quot;src/**/*.scss&quot;: [ &quot;prettier --write&quot;, &quot;git add&quot; ] 这样在提交之前就会对 新增的(git add) .js 文件执行 &quot;eslint --fix&quot; 脚本， 以此类推… Endemmmmmmmmmmmmmmmmmmmmmmmmm 虽然看起来挺简单的，但是整套结合项目去折腾下来 挺多坑的。特别是eslint这块的配置 第一次跑 airbnb 的项目： 目前项目配置官方推荐的 esling 之后: 把error改为 warn保证项目能跑起来: git提交检查失败: 最后附上eslint配置.eslint.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const getWebpackConfig = require('./config/webpack.dev.config')(process.cwd());module.exports = &#123; "parser": "babel-eslint", "extends": ['eslint:recommended', "plugin:react/recommended", "prettier"], "parserOptions": &#123; "ecmaVersion": 8, "sourceType": "module", "ecmaFeatures": &#123; "jsx": true, "modules": true, "experimentalObjectRestSpread": true &#125; &#125;, "plugins": ["react"], "settings": &#123; 'import/resolver': &#123; webpack: &#123; config: getWebpackConfig, &#125; &#125;, "react": &#123; "pragma": "React", "version": "16.1.1" &#125; &#125;, "env": &#123; browser: true, es6: true, node: true, &#125;, "globals": &#123; __DEV__: true, __HTTPS__: true, FB: true, ga: true, $: true, ercjs: true, google: true, IS_APP: true, i18n: true, Zepto: true, AdjustEvent: true, Adjust: true, fbq: true, &#125;, "rules": &#123; "sort-imports": 0, "import/first": 0, "import/no-named-as-default": 0, "import/no-named-as-default-member": 0, "import/extensions": 0, "prefer-destructuring": 0, "no-new": 0, "react/jsx-filename-extension": 0, "no-plusplus": 0, "func-names": 0, "no-console": 0, "no-useless-escape": 0, "semi": 2, // 这些规则后面会改为错误，暂时先警告 "no-unused-vars": 1, "react/prop-types": 1, "react/no-string-refs": 1, "react/jsx-key": 1, "react/no-unescaped-entities": 1 &#125;&#125;]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化测试 puppeteer 与qq空间]]></title>
    <url>%2F2018%2F03%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95puppeteer-%E4%B8%8Eqq%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[项目背景emmmm 前几天女朋友想加我qq。才想到 万年没用的qq里面qqZone 遗留着千年前的一堆中二留言 &amp;&amp; 中二说说。 刚好最近有接触到 自动化测试 puppeteer 框架， 就想着写个脚本去自动删掉留言板和说说。 整个项目基于 node8 运行 用的 async await语法。 概述首先 puppeteer 可以理解为 是谷歌出的一个无UI版本的Chrome。 先从 puppeteer 实例化出一个 Browser， 根据 Browser去new 一个 Page。这个Page可以理解成 我们平时浏览器的一个 tab。 一般操作都是基于 Page去实现的 Page 提供了很多简单易用的api用于操作网页元素， 基本都是异步操作，所以直接用 async/await 非常方便快捷简单易懂。 比如获取元素: page.$(&#39;#switcher_plogin&#39;) 在输入框填入特定信息，每次输入间隔100毫秒模拟输入: page.type(&#39;#mytextarea&#39;, &#39;World&#39;, {delay: 100}); 选择下拉框: Page.select(&#39;select#colors&#39;, &#39;blue&#39;); 项目细节项目初始化与登录步骤首先我们要打开 qq空间 的页面 并登录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 常用操作的工具函数function pageTool(page) &#123; const _page = &#123; async _click(selector) &#123; await page.waitForSelector(selector, &#123; visible: true &#125;); return page.click(selector); &#125;, async _waitForNavigation(opts = &#123;&#125;) &#123; return await page.waitForNavigation(&#123; waitUntil: 'domcontentloaded', ...opts &#125;); &#125;, &#125; Object.assign(page, _page); return page;&#125;(async () =&gt; &#123; const browser = await puppeteer.launch(&#123; headless: true, // 是否显示界面 devtools: true, // 是否显示开发者工具 slowMo: 100, // 延迟每一次操作的毫秒数 ignoreHTTPSErrors: true, // 是否忽略HTTPS错误 &#125;); const loginPage = await browser.newPage(); // 打开新tab 获取当前tab的实例 const page = loginPage; // 仿真 设置窗口大小与 UA 信息。 这里可以设置为 移动端的。 // puppeteer 内置了一些设备可供选择 可以通过以下获取： // const devices = require('puppeteer/DeviceDescriptors'); // const iPhone = devices['iPhone 6']; loginPage.emulate(&#123; viewport: &#123; width: 1280, height: 800 &#125;, userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3347.0 Safari/537.36' &#125;); // 打开特定链接，并等待3秒钟 // PS: 一般是用 page.waitForNavigation 去等待页面加载，这里网络问题经常会出现卡住 所以简单设置为等3s await loginPage.goto('https://i.qq.com/?s_url=http%3A%2F%2Fuser.qzone.qq.com%2F847691625%2Finfocenter&amp;rd=1'); await loginPage.waitFor(3000); // 这里封装了一点点常用的操作 pageTool(loginPage); // 打开成功之后 我们开始走登录的步骤了 (async () =&gt; &#123; // QQ空间里面是用一个 iframe 去装登录的部分，所以这里要先获取 登录iframe对象再进行操作 const iframeDom = await loginPage.frames().filter(iframe =&gt; iframe._name === 'login_frame')[0]; // 如果有登录qq的话，可以使用快捷登录模式 const iframeLoginBtn = await iframeDom.$('#img_out_847691625'); if (iframeLoginBtn) &#123; await iframeLoginBtn.click(); &#125; else &#123; // 如果没有登录qq 直接读配置里面的信息去用账户密码登录 if (data.qq === '你的qq账号') throw new Error('先在a.js 输入qq账号和密码'); // 密码模式 const plogin = await iframeDom.$('#switcher_plogin'); await plogin.click(); //点击账户密码登录的按钮 const userName = await iframeDom.$('#u'); await userName.type(data.qq); // 填入账户 const pw = await iframeDom.$('#p'); await pw.type(data.pw); // 填入密码 const loginBtn = await iframeDom.$('#login_button'); await loginBtn.click(); // 点击登录 &#125; console.log('登录完成'); // 到这里 登录步骤已经完成 大概涵盖了整个项目的80%操作 其他都是类似的dom操作 &#125;)(); /** 删除留言板模块代码，见下一个栏目 **/ /** 删除说说模块代码，见下下个栏目 **/&#125;)(); 删除留言板的功能模块1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556async function delCommit() &#123; // 等待一个 .head-nav-menu a[title="留言板"] 的元素 css选择器 await page.waitForSelector('.head-nav-menu a[title="留言板"]'); await page.waitFor(1000); await page._click('.head-nav-menu a[title="留言板"]'); await page.waitForSelector('.app_canvas_frame'); console.log('留言板iframe加载完成'); // 这里重新获取一个 ifrmae 留言板也是用一个iframe 嵌套进来的....没想到整个qq空间是由一堆的ifrmae堆起来 const iframeDom = await page.frames().filter(iframe =&gt; iframe.url().includes('qzs.qq.com/qzone/msgboard/msgbcanvas.html'))[0]; await page.waitFor(1000); console.log('留言板iframe 获取完成 ', iframeDom); const btnBatchBottom = await iframeDom.$('#btnBatchBottom'); await btnBatchBottom.click(); console.log('批量点击成功 ', btnBatchBottom); let delTime = 1; // 一次完整的删除逻辑 async function delOnes() &#123; console.log(`第$&#123;delTime&#125;次 删除 开始执行`); await page.waitFor(1000); const $chkSelectAllBottom = '#chkSelectAllBottom'; const chkSelectAllBottom = await iframeDom.$($chkSelectAllBottom); await chkSelectAllBottom.click(); if (delTime !== 1) await chkSelectAllBottom.click(); console.log(`第$&#123;delTime&#125;次 删除 点击全选`, chkSelectAllBottom); const $delAll = '#btnDeleteBatchBottom'; const delAll = await iframeDom.$($delAll); await delAll.click(); console.log(`第$&#123;delTime&#125;次 删除 点击删除`, delAll) const $sureBtn = '.qz_dialog_layer_btn.qz_dialog_layer_sub span'; await page._click($sureBtn); console.log(`第$&#123;delTime&#125;次 删除 点击确定`) await page.waitFor(3000); console.log(`第$&#123;delTime&#125;次 删除 执行结束`); delTime++; // 递归 const hasCommit = await iframeDom.$('#ulCommentList .bor3'); if (hasCommit) &#123; await delOnes(); &#125; &#125; await delOnes();&#125;;// delCommit(); 删除说说模块12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364async function delEmotion() &#123; await page.waitForSelector('.head-nav-menu a[title="说说"]'); await page.waitFor(1000); await page._click('.head-nav-menu a[title="说说"]'); await page.waitForSelector('.app_canvas_frame'); await page.waitFor(1000); console.log('说说iframe加载完成'); const iframeDom = await page.frames().filter(iframe =&gt; &#123; console.log(iframe.url()); return iframe.url().includes('qzs.qq.com/qzone/app/mood_v6/html/index.html'); &#125;)[0]; console.log('说说iframe 获取完成 ', iframeDom); let delTime = 1; async function delOnes() &#123; try &#123; console.log(`第 $&#123;delTime&#125;次删除 开始执行`); const moreBtn = await iframeDom.$('.dropdown-trigger.c_tx'); await moreBtn.hover(); console.log(`第 $&#123;delTime&#125;次删除 展示删除按钮`); const delBtn = await iframeDom.$('.del.del_btn.author_display'); await delBtn.click(); console.log(`第 $&#123;delTime&#125;次删除 点击删除按钮`); await page.waitForSelector('.qz_dialog_layer_btn.qz_dialog_layer_sub span'); const delBtnSure = await page.$('.qz_dialog_layer_btn.qz_dialog_layer_sub span'); await delBtnSure.click(); await page.waitFor(1000); console.log(`第 $&#123;delTime&#125;次删除 点击确定按钮`); console.log(`第 $&#123;delTime&#125; 次删除 执行结束`); if (delTime % 10 === 0) await nextPage(); await page.waitFor(1000); delTime++; await delOnes(); &#125; catch (e) &#123; console.log(e, '报错了 尝试方案'); await delOnes(); &#125; &#125; try &#123; await delOnes(); &#125; catch (e) &#123; console.log(`第$&#123;delTime&#125;次 出错 重新try 一遍`) await delOnes(); &#125; async function nextPage() &#123; console.log(`第$&#123;delTime&#125;次执行 遇到跳转`); const nextBtn = await iframeDom.$('a[title="下一页"]'); nextBtn.click(); console.log(`第$&#123;delTime&#125;次执行 点击跳转`); await page.waitFor(5000); console.log(`第$&#123;delTime&#125;次执行 跳转结束`); &#125;&#125; 项目总结大概代码都丢👆了 ，附上 源码地址 在 a.js 填上账号密码。再打开源码里面的 // await delCommit(); 或者 // await delEmotion(); 来删除 留言板或说说。没有做并发操作 所以只能执行一种功能。修改完之后npm install &amp;&amp; node app.js 就可以跑了。 项目中遇到几个问题： page.waitForNavigation(options) 一直等不到完成状态, 30s 超时报错可能是一直有一些脚本挂掉或者在loading。所以后面换成 等待3秒 虽然比较 low。。。但是可行 iframe 里面的dom元素不能直接通过 page.$ 获取，需要先获取 iframe 再通过这个 iframe去获取想要的dom元素 就算是浏览器执行 模拟人为删除，但是连续删除太多行数据的时候， 还是会触发 腾讯的验证码机制。原本用 puppeteer 截图api 去获取验证码，然后用 Tesseract 去识别验证码。但是发现说 识别的有效率极低… 也没有去折腾数据训练。 后面就放弃验证码这一块的技术识别，出了验证码就先不跑 隔断时间再跑。 最后给出完整的项目演示 删除留言板功能演示 删除留言板功能演示 删除说说功能演示 删除说说功能演示 日志输出 源码地址]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>github</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react全家桶 + dva 实践整理总结]]></title>
    <url>%2F2018%2F02%2Freact%E5%85%A8%E5%AE%B6%E6%A1%B6-dva-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[项目背景最近接手组内一个前端大牛的项目，大概理清了里面的总理逻辑与数据流向等， 写个总结 方便以后可以查阅参考。 在之前做的后台管理平台里面，就有用到 dva+antd， 到后面直接用 antd-pro 重新整合了一遍，不得不说 antd-pro 真的是开箱即用 优雅粗暴。 但是里面可能很多和我们平时使用习惯有所不同， 所以这次接触的项目是基于 dva 自己再重组了一下 model router 目录结构等。 使得页面更加的模块化，既 models, routes 不是在一个文件目录里，而是直接按照页面级别来组合。有一个好处就是 本来 models,routes 这些几乎就是不能公用的，那直接按着页面去分 方便问题定位与维护。 目录结构12345678910111213141516171819202122232425262728293031323334353637.├── README.md├── config # 一些关于 webpack babel dll 等项目构件的配置│ ├── babel-plugin-wrap-source.js│ ├── babel-plugin-wrap.js│ ├── build.log│ ├── dist.js│ ├── dll│ ├── server.js│ ├── ssr-middleware.js│ ├── theme.config.js│ ├── webpack.config.common.js│ ├── webpack.config.dll.js│ └── webpack.config.prod.js├── dist # 打包好的文件│ ├── css│ ├── index.html│ └── js├── package-lock.json├── package.json├── src│ ├── assets # 放一些静态资源，如 全局一些 less 文件等│ ├── common # 公共文件， 如 config request utils 等│ ├── components # 通用组件, 如 editor loading 等，用了 antd 之后，这个文件夹的文件较少│ ├── index-ssr.js│ ├── index.js # 项目入口文件│ ├── mock # mock文件│ ├── modules # 业务页面文件夹 代码的绝大部分放在此处│ └── activity # 业务页面 每个业务页面起一个文件夹│ ├── index.js # 当前页面的路由及动态加载文件的配置文件│ ├── model.js # 当前页面的 dva model│ ├── businessUtil.js # │ └── view # 当前页面的 view 文件│ └── index.js│ ├── router.js # 总路由入口│ └── services # 后台接口服务└── webpack.config.js # webpack 配置 项目剖析index.js和其他项目一样 index.js 处理的东西很简单 进行一些关于 dva 的配置初始化 加载配置app model require(modules/app/model) 加载配置app router require(&#39;./router&#39;).default &amp;&amp;&amp;&amp;&amp;&amp;&amp; 启动应用 这里就引出两个分支， model &amp;&amp; router 前端架构中比较关心的两个。 router 管理在 router.js 里面 定义了主 Component 与默认 url router.childRoutes 也是使用模块的方式，只引用了几个大模块，如 require(&#39;modules/activity&#39;)(app), 1234567891011121314151617const Routers = function (&#123; history, app &#125;) &#123; const routes = getRoutes(app); return &lt;Router history=&#123;history&#125; routes=&#123;routes&#125; render=&#123;applyRouterMiddleware(useScroll())&#125; /&gt;;&#125;;function getRoutes(app) &#123; return [ &#123; path: '/', component: App, childRoutes: [ require('modules/activity')(app), ], &#125;, ];&#125; 在 modules/activity/index.js 再去加载构建他的子级路由 1234567891011121314export default app=&gt;(&#123; path: 'url', getComponent (nextState, cb) &#123; require.ensure([], (require) =&gt; &#123; app.model(require('./model')); // 加载当前模块的model cb(null, require('./view')); // 记载当前模块的view &#125;, '模块名'); &#125;, childRoutes:[ require('modules/child1')(app), require('modules/child2')(app) ], ...其他配置&#125;) 就这样一层一层的构建自己的路由， 根据页面去配置也可以更加的细腻可控。不会写成长长的一坨。 modelmodel层用的是 dva 那套， 帮我们整合了 redux, redux-sage and react-router 十分超级好用。 这里只是把目录结构也调整为 页面级别里面，与页面的 路由配置同级。 也是出于更好的定位问题与维护。 一般与model 相关的文件还有各个页面级别文件夹（即modules/activity)里面的 businessUtil.js 文件。 这个文件主要用来辅助处理一些和 model 有关的事情，一般会有三个方法 export { getInitState, convertProps2Params, convertParams2Props }。 分别处理 初始化state, server 端数据与组件 props 之间的差异转换。 mock 数据mock 数据，用了 dva 自带的那套。 我们平时写接口的时候，会在 services/ 下面起一个文件 里面带有某个接口地址 用来请求数据接口的然后在 mock/ 下面也会起一个文件 相同的也会带有一个接口地址这样我们如果这个接口地址改变，岂不是要改两个地方？ 为此，我们在 services/ 下面的文件，只是简单的写了一些原始数据，如 url, method 等 services/feature1123456//@wrapFunction: common/request// @1 上面那行注释是干什么用的呢？export default &#123; url:'api/feature1', method:'POST'&#125; 这样在 mock/ 下面就可以直接引入 services/feature1 就可以拿到相同的url， 接口地址改动的话也只需要改动 services 下的文件。 但是如果只是简单的返回一些原始数据，那和一个 config 文件有何区别，这样完全没有放在 services 下面的必要啊。。。 所以我们用了一行注释来做一些操作 大概的原理是 写了一个 babel 插件，用来处理一些操作。如果匹配到 //@wrapFunction: 则用后面的链接 require 一个方法来包着页面上的代码。 这样就能起到，前端跑代码的时候 feature1 是一个接口功能的文件， mock 的时候是一个单纯的数据输出文件. babel 插件自动处理 services/*.js在上面一小节讲到我们用 babel插件来处理差异化，这里我们具体讲一下是怎么处理的 因为项目用的是 roadhog 搭建的， 所以我们在 .roadhogrc.js 里面配置一下 babel 插件，引进自己插件的文件。 这里我们的插件放置在 /config/babel-plugin-wrap.js; 在 services/*.js 里面添加一行注释代码用作 babel 识别的标识 判断页面上有无对应注释 获取注释与目标路径， 把export default 的输出用函数调用表达式替换掉 具体的 babel插件编写方式可以看官网 https://babeljs.cn/docs/plugins/ 了解编译器原理可以参考 上一篇文一步步实现极简编译器 —— 了解编译器原理 结语剩下的 dll 打包， ssr 以后有用到再去了解。emmm 最近阿里刚出了一个 umiJs 想起知乎上一个评价 用这一时爽 改起来火葬场。在用 antd-pro 的时候就深有体会了。 所以建议如果不是比较小的项目或者灵活性要求高的项目， 还是不要上 antd-pro的好。。。]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[划水]]></title>
    <url>%2F2018%2F02%2F%E5%88%92%E6%B0%B4%2F</url>
    <content type="text"><![CDATA[2.21 《数学之美》2.10 《水形物语》2.11 《至暗时刻》5.19 《css世界》5.21 《白金数据》5.22 《http小书》]]></content>
      <categories>
        <category>live</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一步步实现极简编译器 —— 了解编译器原理]]></title>
    <url>%2F2018%2F01%2F%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%AE%9E%E7%8E%B0%E6%9E%81%E7%AE%80%E7%BC%96%E8%AF%91%E5%99%A8-%E2%80%94%E2%80%94-%E4%BA%86%E8%A7%A3%E7%BC%96%E8%AF%91%E5%99%A8%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[welcome今天在看 babel 的时候，无意中被引到一个外链 关于编译器的优秀/简单的教程，请查看 the-super-tiny-compiler ，同时它也从宏观角度上解释了 Babel 本身是如何工作的。 觉得挺感兴趣的，加上代码也不多，就跟着思路自己理解敲了一遍。 本文主要是帮助理解编译器的原理 不做过多的其他扩展 编译器的基本组成一般简单的编译器可以由以下几部分组成: tokenizer 词法分析器 把代码或文本按类型分开，返回: tokens parser 语法剖析器 对分析后的文本按照语法分析转换成 抽象语法树 返回：ast transformer 语法转换器 把语法剖析后的抽象语法树转换成我们想要的: newAst codeGenerator 代码生成器 把AST 转换为 目标代码 babel 初始阶段并没有做任何事，基本上等于 const babel = code=&gt; code;先 tokenizer， parser 解析代码，再 transformer 的时候，完全不改动原来的 ast 接下来以最简单的编译器组成 一个环节一个环节走下去 tokenizer 词法分析器词法分析器其实可以理解为简单的将文本切割，然后将有价值的按照相邻同等类型的 文本组合一起输出。ps:无价值指对代码生成没有影响的部分，比如js里面非文本 一个空格和一百个空格对编译器来说是没有区别的 实现思路： 有一个值存着当前的光标 current 有一个数组用来存放按类型分出来的值 tokens 对文本进行循环， 取 current 的值做 分类型处理 ( ) 空格 数字 字符串 方法名 将处理后的值存进数组 token 并返回 tokenizer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778function tokenizer(input) &#123; let current = 0; const tokens = []; while (current &lt; input.length) &#123; let char = input[current]; if (char === "(" || char === ")") &#123; tokens.push(&#123; type: 'paren', value: char &#125;); current++; continue; &#125; const WHITESPACE = /\s/; if (WHITESPACE.test(char)) &#123; current++; continue; &#125; const LETTERS = /[a-z]/i; if (LETTERS.test(char)) &#123; let name = ""; while (LETTERS.test(char)) &#123; name += char; current++; char = input[current]; &#125; tokens.push(&#123; type: 'name', value: name &#125;); continue; &#125; const NUMBERS = /[0-9]/; if (NUMBERS.test(char)) &#123; let numbers = ""; while(NUMBERS.test(char)) &#123; numbers += char; current++; char = input[current]; &#125; tokens.push(&#123; type: 'number', value: numbers &#125;); continue; &#125; if (char === '"') &#123; let string = ''; current++; char = input[current]; while(char !== '"') &#123; string += char; current++; char = input[current]; &#125; tokens.push(&#123; type: 'string', value: string &#125;); current++; continue; &#125; throw new TypeError('不知道你输入的是什么鬼东西 ' + char); &#125; return tokens;&#125; 123456789101112131415const input = '(add 2 (subtract 4 2 "djwaqp"))';tokenizer(input);// 输出/*[&#123; type: 'paren', value: '(' &#125;,&#123; type: 'name', value: 'add' &#125;,&#123; type: 'number', value: '2' &#125;,&#123; type: 'paren', value: '(' &#125;,&#123; type: 'name', value: 'subtract' &#125;,&#123; type: 'number', value: '4' &#125;,&#123; type: 'number', value: '2' &#125;,&#123; type: 'string', value: 'djwaqp' &#125;,&#123; type: 'paren', value: ')' &#125;,&#123; type: 'paren', value: ')' &#125;];*/ parser语法剖析器就是把 tokens 解析，转化为抽象语法树(AST)🌲🌲🌲，方便后续的处理。 1[&#123; type: 'paren', value: '(' &#125;, ...] =&gt; &#123; type: 'Program', body: [...] &#125; 实现思路： 首先也要有一个 current 对 tokens 进行遍历，每一项 token 进行分析处理 有一棵树，顶级结构为 {type: &#39;Program&#39; , body: [...]} 根据 token.type 进行相应的归类处理: number： 直接返回 {type: &#39;NumberLiteral&#39;, value, } string： 直接返回 {type: &#39;StringLiteral&#39;, value, } paren ( ： 对下一个进行递归，直到出现 paren ) 将处理后的 ast 返回 parser12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function parser(tokens) &#123; let current = 0; const ast = &#123; type: 'Program', body: [] &#125;; function walk() &#123; let token = tokens[current]; if (token.type === 'number') &#123; current ++; return &#123; type: 'NumberLiteral', value: token.value &#125; &#125; if (token.type === 'string') &#123; current ++; return &#123; type: 'StringLiteral', value: token.value &#125; &#125; if (token.type === 'paren' &amp;&amp; token.value === '(') &#123; token = tokens[++current]; let node = &#123; type: "CallExpression", name: token.value, params: [] &#125; token = tokens[++current]; while ((token.type !== 'paren') || (token.type === 'paren' &amp;&amp; token.value !== ')')) &#123; node.params.push(walk()); token = tokens[current]; &#125; current++; return node; &#125; throw new TypeError(token.type); &#125; while(current &lt; tokens.length) &#123; ast.body.push(walk()); &#125; return ast;&#125; 12345678910111213141516171819202122232425262728293031323334353637input:[&#123; type: 'paren', value: '(' &#125;,&#123; type: 'name', value: 'add' &#125;,&#123; type: 'number', value: '2' &#125;,&#123; type: 'paren', value: '(' &#125;,&#123; type: 'name', value: 'subtract' &#125;,&#123; type: 'number', value: '4' &#125;,&#123; type: 'number', value: '2' &#125;,&#123; type: 'string', value: 'djwaqp' &#125;,&#123; type: 'paren', value: ')' &#125;,&#123; type: 'paren', value: ')' &#125;]=&gt;output:&#123; "type": "Program", "body": [&#123; "type": "CallExpression", "name": "ADD", "params": [&#123; "type": "NumberLiteral", "value": "2" &#125;, &#123; "type": "CallExpression", "name": "subtract", "params": [&#123; "type": "NumberLiteral", "value": "4" &#125;, &#123; "type": "NumberLiteral", "value": "2" &#125;, &#123; "type": "StringLiteral", "value": "djwaqp" &#125;] &#125;] &#125;]&#125; transformertransformer 顾名思义，为转换部分，最复杂 也最常用。.babelrc 添加的插件，也只是在这个环节进行操作，将原本的 ast( es6 ) 转换为目标的 newAst (es5)。 1ast &#123; type: 'Program', body: [...] &#125; =&gt; newAst &#123; type: 'Program', body: [...] &#125; 实现思路： 首先，要有一颗树，和 ast 一样。 顶级结构为 { type: &#39;Program&#39;, body: [...] } 在 ast 上建一个引用_context到 newAst.body; 对 ast 树进行处理, 直接处理 _context 对 ast 上 每个类型都做 enter 处理与 exit处理的钩子 Number 或 String 直接处理并添加到树节点上即可 CallExpression 则要创建一个数组去存参数 对类型为：Program 或 CallExpression 对子级进行 递归 4 处理 将处理后的 newAst 返回 transformer 部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495function traverser(node, visitor) &#123; function traverseArray(nodeArr, parent) &#123; nodeArr.forEach(child =&gt; traverseNode(child, parent)); &#125; function traverseNode(node, parent) &#123; const methods = visitor[node.type]; if (methods &amp;&amp; methods.enter) &#123; methods.enter(node, parent); &#125; switch (node.type) &#123; case 'Program': traverseArray(node.body, node); break; case 'CallExpression': traverseArray(node.params, node); break; case 'NumberLiteral': case 'StringLiteral': break; default: throw new TypeError(node.type); &#125; if (methods &amp;&amp; methods.exit) &#123; methods.exit(node, parent); &#125; &#125; traverseNode(node, null);&#125;function transformer(ast) &#123; const newAst = &#123; type: 'Program', body: [] &#125;; ast._context = newAst.body; traverser(ast, &#123; NumberLiteral: &#123; enter(node, parent) &#123; parent._context.push(&#123; type: 'NumberLiteral', value: node.value &#125;); &#125; &#125;, StringLiteral: &#123; enter(node, parent) &#123; parent._context.push(&#123; type: 'StringLiteral', value: node.value, &#125;); &#125; &#125;, CallExpression: &#123; enter(node, parent) &#123; let expression = &#123; type: 'CallExpression', callee: &#123; type: 'Identifier', name: node.name &#125;, arguments: [] &#125; node._context = expression.arguments; if (parent.type !== 'CallExpression') &#123; expression = &#123; type: 'ExpressionStatement', expression: expression &#125; &#125; parent._context.push(expression); &#125; &#125; &#125;); return newAst;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960input:&#123; "type": "Program", "body": [&#123; "type": "CallExpression", "name": "ADD", "params": [&#123; "type": "NumberLiteral", "value": "2" &#125;, &#123; "type": "CallExpression", "name": "subtract", "params": [&#123; "type": "NumberLiteral", "value": "4" &#125;, &#123; "type": "NumberLiteral", "value": "2" &#125;, &#123; "type": "StringLiteral", "value": "djwaqp" &#125;] &#125;] &#125;]&#125;=&gt;output:&#123; "type": "Program", "body": [&#123; "type": "ExpressionStatement", "expression": &#123; "type": "CallExpression", "callee": &#123; "type": "Identifier", "name": "ADD" &#125;, "arguments": [&#123; "type": "NumberLiteral", "value": "2" &#125;, &#123; "type": "CallExpression", "callee": &#123; "type": "Identifier", "name": "subtract" &#125;, "arguments": [&#123; "type": "NumberLiteral", "value": "4" &#125;, &#123; "type": "NumberLiteral", "value": "2" &#125;, &#123; "type": "StringLiteral", "value": "djwaqp" &#125;] &#125;] &#125; &#125;]&#125; codeGenerator最后一步就是 codeGenerator， 用 newAst 递归调用，根据 node 与一系列规则去生成一个 string。 1newAst &#123; type: 'Program', body: [...] &#125; =&gt; call(argumentsA, ...argumentsN); 实现思路： 根据 node.type 做对应逻辑： Program =&gt; 对 node.body 进行递归 ExpressionStatement=&gt; 对 node.expression 进行处理 CallExpression =&gt; 对 node.callee 与 node.arguments 进行处理 Identifier &amp;&amp; NumberLiteral &amp;&amp; StringLiteral 直接返回对应的字段 codeGenerator123456789101112131415161718192021222324function codeGenerator(node) &#123; switch (node.type) &#123; case 'Program': return node.body.map(codeGenerator).join('\n'); case 'ExpressionStatement': return codeGenerator(node.expression) + ';'; case 'CallExpression': return (codeGenerator(node.callee) +'(' + node.arguments.map(codeGenerator).join(', ') + ')'); case 'Identifier': return node.name; case 'NumberLiteral': return node.value; case 'StringLiteral': return '"' + node.value + '"'; default: throw new TypeError(node.type); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637input:&#123; "type": "Program", "body": [&#123; "type": "ExpressionStatement", "expression": &#123; "type": "CallExpression", "callee": &#123; "type": "Identifier", "name": "ADD" &#125;, "arguments": [&#123; "type": "NumberLiteral", "value": "2" &#125;, &#123; "type": "CallExpression", "callee": &#123; "type": "Identifier", "name": "subtract" &#125;, "arguments": [&#123; "type": "NumberLiteral", "value": "4" &#125;, &#123; "type": "NumberLiteral", "value": "2" &#125;, &#123; "type": "StringLiteral", "value": "djwaqp" &#125;] &#125;] &#125; &#125;]&#125;=&gt; output:add(2, subtract(4, 2, "djwaqp")); compiler至此，编译器所需的几个步骤： 词法分析，解析，转换，生成都已经完成。 compiler123456789function compiler(input) &#123; const tokens = tokenizer(input); const ast = parser(tokens); const newAst = transformer(ast); const output = codeGenerator(newAst); return output;&#125;const input = '(add 2 (subtract 4 2 "djwaqp"))';const output = compilter(input); // 'add(2, subtract(4, 2, "djwaqp"));' babelbabel 的工作原理可以理解成就是一个简单的编译器：分析 =&gt; 转换 =&gt; 生成代码 bable 的篇幅太多，下面直接给出 demo源码。具体可以看 官方插件手册 babel-handbook 我们写的babel 插件，都是在转换的部分运行自定义插件 babel-plugin-jsonz12345678910111213141516171819const t = require('babel-types');module.exports= function() &#123; // plugin contents return &#123; visitor: &#123; // visitor contents BinaryExpression(path, state) &#123; // 如果操作符不是 === 则返回 if (path.node.operator !== '===') &#123; return; &#125; // 操作符的左边替换为 sebmck, 右边替换为 dork path.node.left = t.identifier('"sebmck"'); path.node.right = t.identifier('"dork"'); &#125; &#125; &#125;;&#125;; 目标代码./src/test1.js123function demo() &#123; return 1===2;&#125; 安装相关依赖:npm i babel-cli babel-types --save-dev 运行脚本: babel src/ -d build/ 生成后的代码 ./build/test2.js123function demo() &#123; return "sebmck" === "dork";&#125; 最后再推一波关于学习中看到的好网站 源码esprima 解析语法树🌲AST Explorerast名词解释babel-plugin-handbook]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>github</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析Promise (一)]]></title>
    <url>%2F2017%2F12%2F%E6%B5%85%E6%9E%90Promise%2F</url>
    <content type="text"><![CDATA[ppt在此源码 参照 lie 背景在ES6流行之前，我们处理异步的方法一般有 事件模式， 回调模式等。 事件模式用户点击按钮或按下键盘上的按钮会触发类似 onClick这样的事件，他会向任务队列添加一个新任务来响应用户的操作。直到事件触发时才执行事件处理程序，且正常执行时上下文与定义时相同demo11234let btn = document.getElementById('btn1');btn.onclick = function(event) &#123; console.log(event);&#125; demo212345import iEvent from 'event';iEvent.on('click', function() &#123; console.log(1);&#125;)iEvent.emit('click'); 事件模型适用于处理简单的交互，如果多个独立的异步调用连接在一起会使应用变得更加复杂。而且要追踪每个事件的事件目标，比如 我先点击 btn1 再给 btn1绑定事件，或者先 emit 再 on 都会不起作用。 回调模式为Java打Call为PHP打Call为javascript打CallBack 为Go打Call… demo1123456789method1(function(data) &#123; method2(function(data) &#123; method3(function(data)) &#123; method4(function(data)) &#123; console.log('金字塔'); &#125; &#125; &#125;);&#125;); 回调模式虽然是js的一大精髓，但是写着写着可能会因为嵌套太多的回调函数，陷入回调地狱 —— 超级金字塔 而且如果要处理类似 两个操作都执行完通知你 或者有一个操作执行完就通知你 那么情况可能会变得比较麻烦 基础知识简单使用demo112345678910111213const promise = new Promise((res, rej)=&gt; &#123; setTimeout(function() &#123; const random = Math.random() if ( random&gt; .5) res(random) else rej(random) &#125;, 1000)&#125;)promise.then(val=&gt; (console.log(val), ++val)) .then(val=&gt; console.log(val)) .catch(error=&gt; console.warn(error))// 输出 random &amp;&amp; random+1 or warn(random) Promise 规范 Promise 规范有很多，如 Promise/A，Promise/B，和Promise/A升级版 =&gt; Promise/A+在这里统一一下 以下所有 resolved 都指fulfilled。 Promise 本质是一个状态机。每个 promise 只能是 3 种状态中的一种：pending、resolved 或 rejected。状态转变只能是 pending -&gt; resolved 或者 pending -&gt; rejected。状态转变不可逆。 then 方法可以被同一个 promise 调用多次。 then 方法必须返回一个 新 promise。 三个状态，状态是不可逆的可以在 chrome 控制台看到内部属性 [[PromiseStatus]] 状态值 pending： Promise的初始状态，也就是未被fulfilled或者rejected的状态。 resolved： 意味着promise代指的操作已经成功完成。 rejected：意味着promise代指的操作由于某些原因失败。 then所有的 Promise 都有 then(onResolve, onReject) 方法，接受两个参数，第一个是当Promise 状态变为 resolved 时调用的函数，与异步操作相关的值会传递给该函数第二个是当Promise 状态变为 rejected 时调用的函数，与失败状态相关（报错）会传递给该函数 then方法可以被同个promise调用多次1234const promise = new Promose(res=&gt; res(1))promise.then(val=&gt; console.log(++val))promise.then(val=&gt; console.log(++val))promise.then(val=&gt; console.log(++val)) then方法必须返回一个新的promise12345const promise = new Promise(res=&gt; res(1))const promiseA = promise.then(val=&gt; ++val)const promiseB = promiseA.then(val=&gt; ++val)const promiseC = promise.then(val=&gt; ++val)console.log( promiseA == promiseB, promiseC == promiseA, promiseB == promiseC); 因为promise每次都会返回一个新的promise 所以支持链式写法，上一个 then 的返回值会当成 下一个then的参数then链式1new Promose(res=&gt; res(1)).then(val=&gt; ++val).then(val=&gt; ++val).then(val=&gt; ++val) 错误情况 在 Promise(fn) fn执行错误 每个执行器内部都隐含一个 try...catch...块demo11234const promise = new Promise(function(res, rej) &#123; throw new Error('喵喵喵')&#125;)promise.catch(err=&gt; console.warn(err)) 以上代码等同于demo212345678const promise = new Promise(function(res, rej) &#123; try &#123; throw new Error('喵喵喵') &#125; catch(ex) &#123; rej(ex) &#125;&#125;)promise.then(null, err=&gt; console.warn(err)) 此处可以看出 promise.catch 其实是 promise.then(null, catchFn) 的一个语法糖 then 函数内部错误 demo1123const promise = new Promise(res=&gt; res(1))promise.then(val=&gt; val+val1) .catch(err=&gt; console.warn(err)) 这里可以简单的理解为 then 内部会生成一个 Promise 示例，把函数体丢到Promise 里去执行，执行完结果当成 res 方法的参数，出错则调用 rej 伪代码12345678910const promise = new Promise(res=&gt; res(1))promise.then(val=&gt; new Promise((res, rej)=&gt; &#123; try &#123; res(val + val1) &#125; catch(e) &#123; rej(e); &#125; &#125;)).catch(err=&gt; console.warn(err)) .catch &amp;&amp; then(null, catchFn) 不能对后续的报错进行捕获 123456const promise = new Promise(res=&gt; res(1))promise.then(val =&gt; ++val).catch(e=&gt; console.warn(e)).then(val=&gt; console.log(val+val1))// 此处会抛错，因为在抛出错误之后 没有一个 catch来处理这个错误 所以一般会在 Promise 的最末端添加一个 catch 对前面可能出现的问题进行处理 thenable上面说了那么多关于 then 的使用，其实只要实现了上述 then 功能的对象都可以叫 thenable。所有的 Promise 都是 thenable 但是不一定所有有then 方法的对象都叫 thenable。12345var thenable = &#123; then: function(res, rej) &#123; res(1) &#125;&#125; 至于 thenable 有什么用 请往下看 resolve上述说到的 Promise 用法，都是 创建一个未完成状态，执行一些操作之后才从 pending 转变为 resolved 或 rejected那么可以直接创建一个完成状态的 Promise 吗？ 这里就要用到 静态方法上面的 resolve。 Promise.resolve(promise); Promise.resolve(thenable); Promise.resolve(object); 参数为 promise 时，返回的也是该promisedemo1123const promise = new Promise(()=&gt; &#123;&#125;)const promiseA = Promise.resolve(promise)promise === promiseA 参数为thenable 时，返回标准的promise对象，这个对象有then方法这里是 resolve 方法用的最多的地方了平时工作用到最多的 thenable 恐怕就是 jQ 或 zepto 的 ajax那么我们如果要把他转为标准的 promise 怎么办呢？ 比如 zepto 的 ajax 返回的就没有 .catche 方法，而是 .fail 这里如果有必要 我们可以做一层封装，把他转变为标准的格式 拥抱未来！！！demo21234const ajax = $.ajax(&#123; url, data &#125;)Promise.resolve(ajax) .then(response=&gt; &#123;&#125;) .catch(err=&gt; console.warn(err)) 参数是其他值的情况，会返回一个状态为 resolved 的 promise。终值为传入的值demo312Promise.resolve(&#123;name: "Jsonz"&#125;) .then(val=&gt; console.log("帅哥是 " + val)) rejectPromise.reject 用法与 Promise.resolve 类似 这里不再赘述 多个情况处理开头的时候说了，如果要处理两个及以上的异步操作： 多个都完成时通知你 有一个完成时通知你那么回调就显得很尴尬，这里 Promise 提供了两个方法来满足你这种小需求 all业务上经常会有情况是 要等a接口与b接口的数据一起回来才做操作 那么可以用到静态方法 Promise.all Promise.all 会接受一个 Array 类似的参数，里面是Promise 类型， 返回一个新的Promise 这里取名 PromiseAll当所有的Promise 都变成 resolved 时，会将 PromiseAll 的状态改为 resolved 参数为每个 promise 的终值如果有一个Promise 为 rejected， 那么 PromiseAll 会直接变为 rejected 状态 参数为 首个变为 rejected 状态的错误信息 demo1123456789101112const p1 = new Promise(res=&gt; res(1))const p2 = new Promise(res=&gt; res(2))const p3 = new Promise((res, rej)=&gt; rej(2))const p4 = Promise.all([p1, p2]);p4.then(val=&gt; &#123; console.log(Array.isArray(val)) val.forEach(item=&gt; console.log(item))&#125;)const p5 = Promise.all([p1, p3])p5.then(v=&gt; console.log(v), err=&gt; console.log(err)) racePromise.race 对应的是 有一个完成时通知你 这种状态，用法与参数与 all 类似但是 Promise.race 的参数为第一个转为 resolved 状态的终值 继承Promise改造如果我们要对原生的 Promise 进行改造，比如添加 success() 或 failure() 方法，那么我们可以直接继承他创建一个新的 JsonzPromise12345678910class JsonzPromise extends Promise &#123; success(resolve, reject) &#123; return this.then(resolve, reject) &#125; failure(reject) &#123; return this.catch(reject) &#125;&#125;new JsonzPromise((res, rej)=&gt; res(1)) .success(val=&gt; console.log(val)); 全局的rejected状态处理123456window.onunhandledrejection = function(e) &#123; console.log(e)&#125;window.onrejectionhandled = function(e) &#123; console.log(e)&#125; node 则是在 process 绑定监听氮素！！！！ 不知道为何还没跑过成功的demo…. 后记emmmmmm 贴出一些比较好的教程吧 深入理解ES6 - Promise 篇章](https://www.amazon.cn/dp/B071GW3JDP/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1514389776&amp;sr=1-1&amp;keywords=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3es6)javascript - Promise 迷你书 Promise/A+ 规范中文 第二期实现自己的 Promise 参考1 参考2 参考3 参考4]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http与https杂谈]]></title>
    <url>%2F2017%2F12%2Fhttp%E4%B8%8Ehttps%E6%9D%82%E8%B0%88%2F</url>
    <content type="text"><![CDATA[http &amp;&amp; https https://www.zhihu.com/question/19577317 http://www.alloyteam.com/2016/07/httphttp2-0spdyhttps-reading-this-is-enough/ https://juejin.im/entry/58d7635e5c497d0057fae036 http://www.jianshu.com/p/37654eb66b58 http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html https优点http://www.codeceo.com/article/why-http-better-than-https.html SSL/TSL 协议运行机制http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html https 从第一s发生的事情http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html 彭彭的文章，名词解释器http://172.16.30.58:8000/index.php/2017/11/22/http-https-tcp-dns/ 说的是项目的东西 不大沾边http://172.16.30.58:8000/index.php/2017/12/02/local-https-principle/ 说的是代理http://172.16.30.58:8000/index.php/2017/11/29/local-https-proxy/ `http 与 https 页面资源互相访问 https证书获取的方法，自签，机构认证之类的 HTTP 相关常见协议头的分析, 比如下面的头对 GET POST 的影响、对传递参数的影响 “content-type”: “application/x-www-form-urlencoded” “content-type”: “multipart/form-data” HTTP访问控制（CORS）的分析 跨域是什么 为什么有跨域 如何解决 GET 和 POST 的真正区别session 机制缓存机制（跟缓存相关的协议头）想屌点的就加一个简单的实例分析演示；抓包演示等 感觉上面建议这些点，比单纯的罗列 HTTP 的理论会更有意义` 理论篇https = http + ssl/tls ssl =&gt; 安全套接层tls =&gt; 传输层安全性协议 https 作用http 窃听风险：第三方获取通信内容 篡改风险：第三方可以修改通信内容 冒充风险：第三方可以冒充他人身份参与通信 SSL/TLS 所有信息加密传输 无法窃听 校验机制 篡改会被发现 配证书 防止被冒充 SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。 如何保证公钥不被篡改：将公钥放在数字证书中，证书可信你的公钥就是可信 公钥加密计算量太大，如何减少耗用的时间？每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。 （1） 客户端向服务器端索要并验证公钥。（2） 双方协商生成”对话密钥”。（3） 双方采用”对话密钥”进行加密通信。]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex:1在iOS10.2导致flex-wrap 不起作用]]></title>
    <url>%2F2017%2F08%2Fflex-1%E5%9C%A8iOS10-2%E5%AF%BC%E8%87%B4flex-wrap%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8bug%2F</url>
    <content type="text"><![CDATA[实际上是 flex-basis 的默认值在 iOS10.2及以下为 0 而不是 auto 导致的。 背景项目上有一个列表要有这种效果： 只有一个的情况是一个占一排 有两个的情况是 各占50% 有三个或以上的情况是 每个占 1/3所以这时候用flex是最容易的。大于三个的直接补全至3的倍数即可代码大致思路：12345678910.demo &#123; display: flex; flex-wrap: wrap; height: 100px;&#125;.demo div &#123; border: 1px solid red; flex: 1; min-width: 30%;&#125; 1234567891011121314151617&lt;div class="demo"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="demo"&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="demo"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 本来是完美无缺的，但是在测试过程中，发现说 iOS 10.2 及以下版本会出现 flex-wrap没有正确换行的情况，就算大于三个的情况 全部也都会挤在同一行。 该bug在 10.3不会重现。 解决方案本来有考虑不用 flex 而是用 inline-block 或 float 来解决，但是还是觉得 flex 解决比较优雅一点。所以多番尝试后发现说，不写 flex:1 而是写成 flex:1 1 auto就没问题。 在safari调试了一下，发现 iOS10.2及以下 flex-basis 属性的默认值为 0 而不是 auto.所以所有的项都变成挤在一起。 所以在原来代码上加多一行 flex-basis: auto; 重置掉 flex-basis: 0; 带来的问题即可。 在线demo]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>work</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器css滚动回弹效果 overflow-scrolling]]></title>
    <url>%2F2017%2F08%2F%E6%B5%8F%E8%A7%88%E5%99%A8css%E6%BB%9A%E5%8A%A8%E5%9B%9E%E5%BC%B9%E6%95%88%E6%9E%9C-overflow-scrolling%2F</url>
    <content type="text"><![CDATA[前几天做全屏fixed布局弹窗的时候，去参考了一下淘宝的布局。 无意中发现里面用到一个没见过的css属性 -webkit-overflow-scrolling 该属性控制元素在移动设备上是否使用滚动回弹效果,会有种拟原生的效果 是属于Safari自己实现的css属性 兼容性支持 iOS 5.0 以上。 123-webkit-overflow-scrolling: touch; /* 当手指从触摸屏上移开，会保持一段时间的滚动 */-webkit-overflow-scrolling: auto; /* 当手指从触摸屏上移开，滚动会立即停止 */ 在线demo 示例demo 只在ios手机上有效 浏览器看不出效果12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div &#123; height: 200px; overflow: auto; &#125; .scrolling1 &#123; background-color: red; -webkit-overflow-scrolling: auto; &#125; .scrolling2 &#123; background-color: yellow; -webkit-overflow-scrolling: touch; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;-webkit-overflow-scrolling: auto;&lt;/h1&gt; &lt;div class="scrolling1"&gt;&lt;/div&gt; &lt;h1&gt;-webkit-overflow-scrolling: touch;&lt;/h1&gt; &lt;div class="scrolling2"&gt;&lt;/div&gt; &lt;script&gt; const divList = Array.from(document.querySelectorAll('div')) let str = '' for (let i= 0;i&lt; 100; i++) &#123; str += `&lt;p&gt;$&#123;i&#125;&lt;/p&gt;` &#125; divList.forEach(item=&gt; &#123; item.innerHTML = str &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参考资料 MDN Safari CSS]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8月伊始牢骚]]></title>
    <url>%2F2017%2F08%2F8%E6%9C%88%E7%AC%AC%E4%B8%80%E5%91%A8%E7%9A%84%E7%89%A2%E9%AA%9A%2F</url>
    <content type="text"><![CDATA[看了一下 上一次 commit 的时间。jun 25, 2017从去兰卡威玩之前就开始没写博客了。回来之后又一直很懒散 加上工作实在饱和 差点丢了这个习惯 不好 不好 7月的加班时长，平均时长是 11.30 小时 排公司技术第五 七月尾八月初有个小机会 可以用上react全家桶做一个前端的后台管理系统 [前端性能检测后台 sp] 从只自己捣鼓过 react-native 的小菜鸟 一下子要上手全家桶 真的很蛋疼，好几天都在看 文档api demo 幸亏其毅大哥 此处应该有掌声 整天做我的小 Google GoGoGo react/redux/redux-sage/react-router/react-redux-router/antd/dva 期间做热力图的内嵌 第一次用了 postMessage。 然后意外发现 不知道是 redux-tool还是redux 用了 web-worker 来做计算线程。 跟发现新大陆一样 这周五排到我分享，打算把 postMessage 简单说一下，下次有机会的时候 说一下 sp后台和 dva的大概思路 8.26号第一次参加 FEDAY 挺开心的 可以去北京。 加油 Jsonz 加油P3]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[postMessage 消息传递]]></title>
    <url>%2F2017%2F08%2FpostMessage-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[背景最近捣鼓一个小项目， 做了一个后台管理平台 里面要对线上项目做一个操作 显示热力图。所以只能采用 iframe 去嵌套，再做其他操作。包括 加载相对的js脚本（热力图脚本 称heatmap.js)， 在后台筛选日期 地点时 heatmap.js 要做对应的操作因为后台的域和前端不一致 所以跨域操作 首选用 postMessage postMessage api12345678910otherWindow.postMessage(message, targetOrigin, [transfer] )otherWindow: 其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。message: 将要发送到其他 window的数据。它将会被结构化克隆算法序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。targetOrigin: 通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串"*"（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的orign属性完全一致，来防止密码被恶意的第三方截获。如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是*。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。transfer 可选是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 需要注意的是 message 不可以包含 dom对象, 可以把验证或校对信息放置在 message 一并发送出去 小demoa.html123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe src="./demo1.html" frameborder="0" name="iframe1"&gt;&lt;/iframe&gt; &lt;script&gt; const iframeWindow = document.iframe1 iframeWindow.addEventListener('load', function() &#123; iframeWindow.postMessage(&#123; type: 'script', evalFn: 'alert(1)' &#125;, '*') &#125;) window.addEventListener('message', ()=&gt; &#123; console.log('parent message ') &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; b.html1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;script&gt; window.addEventListener('message', event=&gt; &#123; console.log(event) const &#123; evalFn, type &#125; = event.data const &#123; source &#125; = event console.log(type, evalFn) if (type === 'script') eval(evalFn) source.postMessage('bilibili', '*') &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实际应用小例子admin-iframe/index.js123456789101112131415161718...const iframeWindow = iframe.contentWindowthis.initMessenger = new postMessage(iframeWindow, 'initPostMessage')this.initMessenger.send(&#123;type: 'asyncLoadScript', data: &#123;src: config.heatmapJs&#125;&#125;)// heatmapMessage 处理与heatmap-show相关的事件this.heatmapMessenger = new postMessage(iframeWindow, 'heatmap')// 每次跳转页面或load 都重新在state 更新事件到heatmap-showthis.targetMessenger.listen('loadSuccess', ()=&gt; &#123; const &#123; startTime, endTime, site, continent, isHeatmap &#125; = this.props.heatmap this.heatmapMessenger.send(&#123;type: 'initFilter', data: &#123; date: [startTime, endTime], site, isHeatmap &#125;&#125;)&#125;)... postMessage.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* * @Author: Jsonz * @Date: 2017-08-05 15:42:15 * @Last Modified by: Jsonz * @Last Modified time: 2017-08-05 16:15:44 * * const messenger = new Messenger(window, 'heatmap') * messenger.send(&#123; type: 'changeType', data: &#123; &#125; &#125;) * messenger.listen(&#123; type: 'changeType', cb: ()=&gt; &#123;&#125; &#125;) */class Messenger &#123; constructor(target, prefix) &#123; this.target = target this.prefix = prefix this.listenFunc = [] this.initListen() &#125; send(msg) &#123; if (!msg.type) throw new Error('postMessage send 没有传type') msg.type = this.prefix + '__' + msg.type this.target.postMessage(msg, '*') &#125; listen(type, cb) &#123; const len = this.listenFunc.length type = this.prefix + '__' + type let cbIsExist = false for (let i= 0; i&lt; len; i++) &#123; if (this.listenFunc[i].type === type) &#123; cbIsExist = true break &#125; &#125; if (!cbIsExist) this.listenFunc.push(&#123; cb, type &#125;) &#125; initListen() &#123; const cb= event=&gt; &#123; let messageObj if (typeof event === 'object' &amp;&amp; event.data) messageObj = event.data if (!messageObj.type || !messageObj.type.includes('__')) return for (let i= 0; i&lt; this.listenFunc.length; i++) &#123; let itemFn = this.listenFunc[i] if (itemFn.type === messageObj.type) itemFn.cb(messageObj.data) &#125; &#125; window.addEventListener('message', cb, false) &#125;&#125;// modules.export = Messengerexport default Messenger 参考githubpostMessage MDN 文档caniuse arale/messenger/index.js]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>JavaScript</tag>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[兼容多种模式规范]]></title>
    <url>%2F2017%2F07%2F%E5%85%BC%E5%AE%B9%E5%A4%9A%E7%A7%8D%E6%A8%A1%E5%BC%8F%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920;(function(name, definition) &#123; // 检测上下文环境是否为 ADM 或 CMD var hasDefine = typeof define === 'function'; // 检查上下文是否为 node var hasExports = typeof module !== 'undefined' &amp;&amp; module.exports; if (hasDefine) &#123; // AMD环境 或 CMD环境 define(definition); &#125; else if (hasExports) &#123; // 定义为普通Node模块 module.exports = definition(); &#125; else &#123; // 将模块的执行结果挂在window变量中， 在浏览器中 this 指向 window 对象 this[name] = definition(); &#125;&#125;)('hello', function() &#123; var hello = function() &#123;&#125; return hello;&#125;)]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodeJs 学习导航]]></title>
    <url>%2F2017%2F06%2FnodeJs-%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%88%AA%2F</url>
    <content type="text"><![CDATA[廖雪峰node教程内置模块fs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253'use strict'const fs = require('fs')// 读取文件fs.readFile('demo1.html', 'utf-8', (err, data)=&gt; &#123; // console.log(err? err: data)&#125;)// 异步读取文件fs.readFile('about-us.png', (err, data)=&gt; &#123; if (err) &#123; console.log(err) &#125; else &#123; // console.log(data) // console.log(data.length + ' bytes') let text = data.toString('utf-8') // console.log(text) let buf = new Buffer(text, 'utf-8') // console.log(buf) &#125;&#125;)// 同步读取文件try &#123; const data = fs.readFileSync('demo2.html', 'utf-8') console.log(data)&#125; catch(err) &#123; console.log(err)&#125;// 写文件const writeData = 'Hello Jsonz'fs.writeFile('output.txt', writeData, err=&gt; &#123; console.log(err || 'ok.')&#125;)// 获取文件信息fs.stat('output.txt', (err, stat)=&gt; &#123; if (err) &#123; console.log(err) &#125; else &#123; console.log('isFile: ' + stat.isFile()) console.log('isDirectory: ' + stat.isDirectory()) if (stat.isFile()) &#123; console.log('size: ' + stat.size) console.log('birth time: ' + stat.birthtime) console.log('modified time: ' + stat.mtime) &#125; &#125;&#125;) stream1234567891011121314151617181920212223242526272829303132333435363738394041'use strict'try &#123; const fs = require('fs') const rs = fs.createReadStream('output.txt', 'utf-8') // 结束 rs.on('end', function() &#123; console.log('END') &#125;) // 错误捕获 rs.on('error', err=&gt; &#123; console.log('ERROR: ' + err) &#125;) // 读取 rs.on('data', chunk=&gt; &#123; console.log('DATA: ', chunk) &#125;) // 写入文本数据 const ws1 = fs.createWriteStream('output1.txt', 'utf-8') ws1.write('使用Stream写入文本数据...\n') ws1.write('END.') ws1.end() // 写入二进制数据 const rs2 = fs.createWriteStream('output2.txt') rs2.write(new Buffer('使用Stream写入文本数据... \n', 'utf-8')) rs2.write(new Buffer('END.', 'utf-8')) rs2.end() // pipe 流 const ws2 = fs.createWriteStream('copied.txt') rs.pipe(ws2, &#123; end: false &#125;) // rs Readable流和 ws2 Writable流用 pipe串起来。 默认Readable流数据读取完毕后关闭 Writeable流。可以传参修改&#125; catch(err) &#123; console.log(err)&#125; HTTP简单的协议入门介绍 简单的http服务器1234567891011const http = require('http')const server = http.createServer((request, response)=&gt; &#123; console.log(request.method + ': ' + request.url) response.writeHead(200, &#123;'Content-Type': 'text/html'&#125;) response.end('&lt;h1&gt; Hello World! &lt;/h1&gt;')&#125;)server.listen(8080)console.log('server is running at http://127.0.0.1:8080') 文件服务器123456789101112131415161718192021222324252627282930313233343536const http = require('http')const url = require('url')const path = require('path')const fs = require('fs')const root = path.resolve(process.argv[2] || '.')console.log('Static root dir: ' + root)// 创建服务器const server = http.createServer((request, response)=&gt; &#123; // 获取URL 的 path, 类似 /css/bootstrap.css const pathname = url.parse(request.url).pathname // 获取对应的本地文件路径， 蕾西 /srv/www/css/bootstrap.css const filepath = path.join(root, pathname) // 获取文件状态 fs.stat(filepath, (err, stats)=&gt; &#123; if (!err &amp;&amp; stats.isFile) &#123; // 没有出错且文件存在 console.log('200 ' + request.url) // 发送200响应 response.writeHead(200) // 将文件流导向response fs.createReadStream(filepath).pipe(response) &#125; else &#123; // 出错了或者文件不存在 console.log('404 ' + request.url) // 发送404 响应 response.writeHead(404) response.end('404 Not Found') &#125; &#125;)&#125;)server.listen(8080)console.log('server is running at http://127.0.0.1:8080') crypto 通用的加密算法和哈希算法crypto实现加密解密12345678910111213141516171819202122232425262728293031323334// 通用的加密和哈希算法const crypto = require('crypto')const hash = crypto.createHash('md5')// 可以直接把 md5v 改为 sha1 或更安全的 sha256 sha512// 可以任意多次调用update 默认字符串编码为 UTF-8hash.update('hello world')hash.update('hello nodejs')console.log(hash.digest('hex'))// AES 对称加密算法function aesEncrypt(data, key) &#123; const cipher = crypto.createCipher('aes192', key) let crypted = cipher.update(data, 'utf8', 'hex') crypted += cipher.final('hex') return crypted&#125;function aesDecrypt(encrypted, key) &#123; const decipher = crypto.createDecipher('aes192', key) let decrypted = decipher.update(encrypted, 'hex', 'utf8') decrypted += decipher.final('utf8') return decrypted&#125;let data = 'Hello, this is a secret message!'const key = 'Jsonz-password'const encrypted = aesEncrypt(data, key)const decrypted = aesDecrypt(encrypted, key)console.log('Plain text: ' + data)console.log('Encrypted text: ' + encrypted)console.log('Decrypted text: ' + decrypted)]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>NodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native 学习总结]]></title>
    <url>%2F2017%2F06%2Freact-native-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[进公司的时候 原部门老大让我去看rn demo 后面项目会用到，于是有了这个项目的开始。 但是一个星期后，我被调去另一个部门，现部门进来之后就一直忙着业务代码 产品迭代。 从github 提交应该也能看出来， 特别从 6.8到6.24 一次commit都没有。 慕课网狗狗说app的开发教程学习，这次的学习可以算是半成品，大概了解了rn 也写了一个较为完整的demo，后面如果有一些简单的rn项目或者app内嵌 上手成本应该低了很多。包括:RN 项目环境配置 折腾了很久 真的很多坑穿插着学了一点点O-C 语法xCode 资源库引用以及常见问题或常见功能使用RN 项目启动 link watchman 等等RN 具体代码 api 组件 学习Koa 与 mongoDB 的简单使用七牛云使用螺丝帽发送验证码使用各种类库 图片插件 倒计时插件 录音 录像 等接下来如果不是项目有使用到的话 应该不会再深入接触rn。 毕竟现在的目标是进军P3 &amp;&amp; 优秀员工。 app部分截图: 最后附上源码 RN 很看 环境和版本，所以跑得起来才是不正常的]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>github</tag>
        <tag>imooc</tag>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[置顶]捣鼓目录]]></title>
    <url>%2F2017%2F06%2F%E6%8D%A3%E9%BC%93%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[记录平时工作学习的目录条目， 类似 Jsonz-learn、 Jsonz-wheel 的目录。部分比较大的轮子可能会独立成一个git项目 DoingSSR 相关 Next NEXTwebpack plugin/ loader babel plugin 添加 gitment React 新特性 setState 新生命周期函数 新特性 Context、memo、lazy等 新特性 Hook 事件系统 diff 目录 排名按时间顺序正则全局标志注意事项react源码学习系列函数式编程一道赋值面试题引发的思考 —— 对象引用问题视频转字符画window.print 浏览器打印扫盲《http小书》http知识扫盲《css世界》常用技巧 —— 读书笔记浏览器恢复滚动行为 —— history.scrollRestorationcreate-react-app 源码解析(一)create-react-app 源码解析(二)git查漏补缺 非常大好全的文章 慢慢适用一下控制台提交，熟悉之后再切客户端自动化功能测试流程方案项目代码规范工作流——editor、prettier、eslint、git-check自动化测试 puppeteer 与qq空间 源码 react全家桶 + dva 实践整理总结了解 babel 写个babel 插件 —— 了解编译器原理 实现了一个 极简的编译器 react/dva/antd/antd-pro/roadhog 全家桶 项目用ingpostMessage 简单的对系统自带的postMessage进行封装 支持事件类型监听 更多实现参考 arale/messenger/index.js react-native-dogs 学习react-native 比较全面的一个路径 虽然不完整，但包含了rn 常用的api 库 等 也涉及到 node koa 七牛云等 react-native-countdown ReactNative的倒计时组件 造这个轮子的原因是学习rn的时候，视频推荐额一个组件，但是这个组件已经停止维护 所以只能自己造一个 支持日期与秒数的倒计时 简单粗暴 fixedTop 吸顶效果 一个很小的常用效果 主要细节 在于改变dom为 fixed布局后在该dom后面生成一个占位的，防止兄弟节点的抖动 copyText 复制黏贴板插件 支持h5，PC success, error回调 判断浏览器是否支持该事件接口 heatmap 热力图 老大提的小需求 一两个小时完成 点击页面会间隔(10s)存到sessionLocation。 刷新后会把存在sessionLocation 绘制成热力图展示在页面上 validator 小型表单验证插件 移动端简单的验证插件 支持自己配置验证项 支持多重验证 cookie 封装了一些cookie常用的api get set remove clear getAll ObjectiveC ObjectiveC 基础 为了学 ReactNative 做一点ios基础铺垫 setTimeout &amp;&amp; setIntervalEvent 最简单的事件系统 handlebars 简单的模板引擎http://handlebarsjs.com quickskin 简单的PHP模板， 文档很不全 {value} if for sass 简单的入门语法，因为用过less 所以基本无障碍 chrome-extension 学习chrome插件开发入门 暂存finish，后面会重新学习 比较感兴趣 目前想法是做一个可以在页面比较方便加载js的插件 TODO animate-text 一个简单的文字 &amp;&amp; 数字 动画小插件。 demo 文档 backbone 历史悠久的MVC框架 https://github.com/jashkenas/backbone DesignPattern 后面会继续学习 《JavaScript设计模式》张容铭 亚马逊购买 ECMAScript_6_Primer ES6入门 阮一峰 亚马逊购买 gulp gulp中文 https://github.com/gulpjs/gulp imooc 慕课网上的相关学习 imooc.com 学习占幅越来越低，看视频的效率没有看书和博客来的快 markdown markdown语法学习 github markdown require JS模块化加载规范 AMD产物 AMD require+backbone backbone+require 练习 RiotJs 微型类React框架 http://riotjs.com/ 公司在用，有实战经验 v2兼容ie8 edit_config 常用的编辑器配置 Uncle Tom 汤姆大叔的博客Js教程 强烈推荐!!!! 深入浅出 讲了很多原理性的东西 入门与进阶必备 http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html vue vueJs入门部分demo vue+webpack vue+webpack demo jsonz_old 刚入门的时候写的一个在线简历 停止更新 zhangxinxu 腾讯一个大佬，主要重构方面。 css与html很多疑难杂症 基础知识等都可以在里面找到 http://www.zhangxinxu.com/ Done log: 历史日志，定时把doing更新下来，所以会越来越长…因为不想每次都忘了之前定的是什么，又懒得去找git记录 工作项目重新上验证等 √ 工作项目去除日期 √ css自定义属性 × 对象赋值循环引用探讨 √ 视频转字符画 √ 后面有时间整理出来 写个webpack插件，处理cookie生成markdown √ 写完发现这些要在运行时抓取才准确就没继续做下去 create-react-app √ 第一次尝试开心 vue全家桶 √ 过了一遍，等有小项目可以练手_ 《CSS世界》_ √ 好书— 《http小书》_√ 准能帮你省下不少时间 了解函数式编程 √ React源码 √ 升级blog版本 √]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>github</tag>
        <tag>web</tag>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native-countdown RN的倒计时组件]]></title>
    <url>%2F2017%2F06%2Freact-native-countdown-RN%E7%9A%84%E5%80%92%E8%AE%A1%E6%97%B6%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[概述之所以会写这个小组件是因为学习RN的时候，跟着视频敲代码。 视频推荐了一款倒计时组件 因为长期没有维护（最后一次更新是一年前）， 在我的RN环境下报错。 报错的原因大概是 React 把一个功能独立出去，要重新引进就可以了。 不过想着既然我已经看了源码找到问题，那么我何不自己造一个小轮子呢~ 项目github 用法需要手动引入，没有传到npm 懒得再维护 12345678910111213141516171819202122232425import &#123;CountDownText&#125; from 'react-native-sk-countdown';&lt;CountDownText style=&#123;styles.cd&#125; countType='seconds' // 计时类型：seconds / date auto=&#123;true&#125; // 自动开始 afterEnd=&#123;() =&gt; &#123;&#125;&#125; // 结束回调 timeLeft=&#123;10&#125; // 正向计时 时间起点为0秒 step=&#123;-1&#125; // 计时步长，以秒为单位，正数则为正计时，负数为倒计时 startText='获取验证码' // 开始的文本 endText='获取验证码' // 结束的文本 intervalText=&#123;(sec) =&gt; sec + '秒重新获取'&#125; // 定时的文本回调 /&gt;&lt;CountDownText // 倒计时 style=&#123;styles.cd&#125; countType='date' // 计时类型：seconds / date auto=&#123;true&#125; // 自动开始 afterEnd=&#123;() =&gt; &#123;&#125;&#125; // 结束回调 timeLeft=&#123;10&#125; // 正向计时 时间起点为0秒 step=&#123;-1&#125; // 计时步长，以秒为单位，正数则为正计时，负数为倒计时 startText='' // 开始的文本 endText='' // 结束的文本 intervalText=&#123;(date, hour, min, sec) =&gt; date + '天' + hour + '时' + min + '分' + sec&#125; // 定时的文本回调 /&gt; Prop Prop Description Default countType Countdown type, one of ‘seconds’ and ‘date’. None auto Whether to start countdown right now. false timeLeft Seconds lefted to countdown. None step Number to increment in each step. -1 startText Text before countdown. None endText Text after countdown. None intervalText A function to reture a text during countdown. None afterEnd A callback function after countdown. None Methods Method Description Params start start countdown. None end finish countdown. None 源码主要有两个文件，一个是倒计时的逻辑，另一个是夹杂了RN的逻辑。CountDown.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112export default class CountDown &#123; constructor(props) &#123; this.setData(props); &#125; // 获取有多少秒 static getSeconds(time) &#123; let type = typeof time; return (type === 'number' || type === 'string' &amp;&amp; /^\d+$/.test(time)) ? time : new Date(time).getTime() / 1000; &#125; // 位数补全 static ten(t) &#123; return t &lt; 10? '0' + t: t; &#125; // 设置数据 setData(props) &#123; this.countType = props.countType; // 支持两种计时方式，两个日期之间 &amp;&amp; 秒数的倒计时 this.timerId = null; // 计时器 this.endTime = props.endTime; // 计时器结束时间 this.startTime = props.startTime; // 计时器开始时间 this.timeLeft = props.timeLeft; // 计时器剩余秒数， 区别于上面时间段的计时方式 this.timePassed = 0; // 正向为累计时间，反向为剩余时间 this.onInterval = props.onInterval; // 定时的回调 this.onEnd = props.onEnd; // 结束的回调 this.step = props.step; // 计时步长，以秒为单位，正数为正计时，负数为倒计时 this.counter = 0; // 累加器 TODO 疑问 // 数据校验 if (!this.countType) &#123; throw new Error('必须传入一个 countType: seconds || date'); &#125; if ( (this.timeLeft &amp;&amp; (this.endTime || this.startTime)) || (!this.timeLeft &amp;&amp; !(this.endTime || this.startTime)) ) &#123; throw new Error('必须传入一个时间段 [timeLeft] [startTime] [endTime]'); &#125; if (!this.timeLeft &amp;&amp; typeof this.startTime === 'undefined') &#123; this.startTime = Date.now()/ 1000; &#125; if (!this.timeLeft) &#123; this.timeLeft = Math.floor(CountDown.getSeconds(this.endTime) - CountDown.getSeconds(this.startTime)); &#125; this.refreshTime(true); &#125; // 周期启动更新时间 auto() &#123; this.timerId = setTimeout(()=&gt; &#123; // 倒计时到0停止计时 if (this.timePassed &lt;= 0 &amp;&amp; this.step &lt; 0) return this.end(); this.refreshTime(true); &#125;, 1000 * Math.abs(this.step)); // 时间间隔为整数， 对step求绝对值 &#125; refreshTime(isStart) &#123; this.timePassed = (this.timeLeft * 1000 + this.step * 1000 * this.counter++) / 1000; if (this.countType === 'date') &#123; let _timePassed = this.timePassed, second = CountDown.ten(_timePassed % 60); _timePassed = parseInt(_timePassed / 60); let minute = CountDown.ten(_timePassed % 60); _timePassed = parseInt(_timePassed / 60); let hour = CountDown.ten(_timePassed % 24); _timePassed = CountDown.ten(parseInt(_timePassed / 24)); this.onInterval(_timePassed,hour,minute, second); &#125; else if (this.countType === 'seconds') &#123; this.onInterval(this.timePassed); &#125; isStart &amp;&amp; this.auto(); // 是否开始计时 &#125; // 开始计时 start() &#123; clearTimeout(this.timerId); this.refreshTime(true); &#125; // 结束： 没有清空计数 + 停止计时 end() &#123; clearTimeout(this.timerId); this.onEnd(this.timeLeft); &#125; reset() &#123; this.counter = 0; clearTimeout(this.timerId); this.refreshTime(false); &#125;&#125; CountDownText.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import React, &#123;Component&#125; from 'react';import &#123; Text&#125; from 'react-native';import CountDown from './CountDown';class CountDownText extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; text: this.props.startText, &#125;; &#125; counter= null; static isTimeEquals(t1, t2) &#123; return Math.abs(t1 - t2) &lt; 2; &#125; componentWillReceiveProps(nextProps) &#123; let updating = true; // 倒计时的情况 if (this.props.step === nextProps.step &amp;&amp; this.props.step &lt; 0) &#123; if (this.props.endTime) &#123; // 1. 按起始日期来计时 updating = !CountDownText.isTimeEquals(this.props.endTime, nextProps.endTime); &#125; else &#123; // 2. 按间隔秒数来计时 updating = !CountDownText.isTimeEquals(nextProps.timeLeft, this.counter.timePassed); &#125; &#125; if (updating) &#123; // 重置： 清空计数 + 停止计时 this.counter.reset(); this.counter.setData(Object.assign(&#123;&#125;, nextProps, &#123; onInterval: this.onInterval.bind(this), onEnd: this.onEnd.bind(this), &#125;)); if (nextProps.auto) &#123; this.start(); &#125; &#125; &#125; componentDidMount() &#123; this.counter = new CountDown(Object.assign(&#123;&#125;, this.props, &#123; onInterval: this.onInterval.bind(this), onEnd: this.onEnd.bind(this), &#125;)); if (this.counter.timeLeft &lt;= 0 &amp;&amp; this.counter.step &lt;= 0) &#123; return this.end(); &#125; if (this.props.auto) this.start(); &#125; componentWillUnmount() &#123; this.reset(); &#125; start() &#123; this.counter.start(); &#125; end() &#123; this.counter.end(); &#125; reset() &#123; this.counter.reset(); &#125; render() &#123; return ( &lt;Text style=&#123;this.props.style&#125;&gt; &#123;this.state.text&#125; &lt;/Text&gt; ) &#125; getTimePassed() &#123; return this.counter.timePassed; &#125; onInterval(...args) &#123; this.setState(&#123;text: this.props.intervalText.apply(null, args)&#125;) &#125; onEnd(timePassed) &#123; this.setState(&#123; text: this.props.endText, &#125;); this.props.afterEnd(timePassed); &#125;&#125;CountDownText.defaultProps = &#123; countType: 'seconds', onEnd: null, timeLeft: 0, step: -1, startText: null, intervalText: null, endText: null, auto: false, afterEnd: ()=&gt; &#123;&#125;,&#125;;export default CountDownText; 后记大量借鉴 https://github.com/shigebeyond/react-native-sk-countdown 项目 其实说白了只是在原来代码上优化改进，主要兼容新版的React-Native、React 和用 ES6语法改写。]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>JavaScript</tag>
        <tag>work</tag>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端浏览器默认请求 apple-touch-icon.png 问题]]></title>
    <url>%2F2017%2F06%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E9%BB%98%E8%AE%A4%E8%AF%B7%E6%B1%82-apple-touch-icon-png-%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述项目有做埋点与请求的记录， 早上发现有用户老是会请求一个location.origin + &quot;/apple-touch-icon.png&quot; 或 location.origin + &quot;/apple-touch-icon-76x76.png&quot;的问题。 这就很纳闷了， 首先，按照我们的代码风格是不会出现 根目录指向的图片 而且后台也不会输出这么系统化的图片名。 一看就知道是 apple 搞的鬼。 于是乎 google 了一下 大概就是ios8及以上safari浏览器的保存桌面操作请求的一张图，用于做icon。 场景： 解决方法：可以在head加上这段1&lt;link rel="apple-touch-icon" href="/custom_icon.png"&gt; 如果要更加精准一点，根据设备来用不同的icon，则可以这样1234&lt;link rel="apple-touch-icon" href="touch-icon-iphone.png"&gt;&lt;link rel="apple-touch-icon" sizes="152x152" href="touch-icon-ipad.png"&gt;&lt;link rel="apple-touch-icon" sizes="180x180" href="touch-icon-iphone-retina.png"&gt;&lt;link rel="apple-touch-icon" sizes="167x167" href="touch-icon-ipad-retina.png"&gt; 如果没有找到符合设备的尺寸，那么会优先选用比预期尺寸大的最小图标。比如设备的适当图标大小为58 x 58，系统会按照下面寻找 apple-touch-icon-80x80.png apple-touch-icon.png 默认是去更目录寻找，不过你可以指定一个路径。 后记更多资料]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作日常 吸顶效果]]></title>
    <url>%2F2017%2F05%2F%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%B8%B8-%E5%90%B8%E9%A1%B6%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[概述吸顶 最常见的就是我们平时网站浏览的时候，下滑到某个程度之后 导航栏就固定到顶部而不随页面滚动而滚动（简单而言就是 fixed 布局 ).最常见的实现方式思路就是 判断页面滚动高度，到某个高度的时候就让这个div改变定位方式 具体实现引入 jq ，并加一判断，如果jq(zepto) 没有 outerHeight/outerWidth 手动实现。12345678910111213141516171819202122232425262728import $ from './jquery-2.1.1';// 如果没有 outerWidth 或 outerHeight 手动实现outerWidth &amp;&amp; outerHeight(()=&gt; &#123; if (typeof $.outerHeight === 'function') return; ['height', 'width'].forEach(dimension=&gt; &#123; let Dimension = dimension.replace(/./, m=&gt; m[0].toUpperCase()); $.fn['outer' + Dimension] = function(margin) &#123; if (this) &#123; let size = this[dimension](), sides = &#123; 'width': ['left', 'right'], 'height': ['top', 'bottom'], &#125;; sides[dimension].forEach(side=&gt; &#123; if (margin) size += parseInt(this.css('margin-' + side), 10); &#125;); return size; &#125; else &#123; return null; &#125; &#125; &#125;);&#125;)(); 实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const fixedTop = &#123; /** * @param el 具体要 fixed 的 dom 的字符串或jqueryDom 或dom * @param opts 其他配置，目前只有 hold 是否要生成一个占位div防止div 脱离文档流后兄弟节点抖动 */ init(el, opts=&#123; hold: true&#125;) &#123; // 初始化需要的el this.$el = el instanceof $? el: $(el); // 获取后面要改变样式的具体参数 let offset = this.$el.offset(); this.offsetTop = offset.top; this.defaultHeight = this.$el.outerHeight(true); this.defaultState = &#123; position: this.$el.css('position'), width: this.$el.css('width') || 'auto', top: this.$el.css('top') || 'auto', &#125;; this.changeState = &#123; position: 'fixed', width: this.$el.outerWidth(), top: '0', left: offset.left, &#125;; // 如果有 hodl 参数， 配置好要生成的 占位dom this.holdEl = opts.hold? `&lt;div class="J-fixedTop-pad" style="height:$&#123;this.defaultHeight&#125;px; visibility: hidden;"&gt;&lt;/div&gt;`: ''; // 绑定事件 this.bindEvent(); &#125;, bindEvent() &#123; let $win = $(window); $win.scroll(()=&gt; &#123; let isTop = ($win.scrollTop() - this.offsetTop) &gt;= 0, isFixed = this.$el.data('fixed'); // 判断 如果大于top 并且当前的dom元素没有被改变样式，则执行逻辑 if (isTop &amp;&amp; !isFixed) &#123; this.$el.data('fixed', true); if (!this.$el.next().hasClass('J-fixedTop-pad')) &#123; this.$el.after(this.holdEl); &#125; this.addCss(); &#125; else if (!isTop &amp;&amp; isFixed)&#123; // 反之 还原dom样式 this.$el.data('fixed', false); this.removeCss(); this.holdEl &amp;&amp; this.$el.next().remove(); &#125; &#125;) &#125;, addCss() &#123; this.$el.css(this.changeState); &#125;, removeCss() &#123; this.$el.css(this.defaultState); &#125;&#125;; 调用1fixedTop.init('#div'); 后记很简单的小需求， 是在工作中看到小伙伴的脚本后改进的。 主要是之前没有想到要生成一个占位dom来防止后面的抖动项目源码链接 目前只支持吸顶， 后面可以对代码改造，改成可以支持左右上下的 然后有一个css样式可以直接达到这个效果，但是兼容性不乐观， 对布局也有所要求，有兴趣的可以去了解一下.sticky demo。sticky caniuse]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>JavaScript</tag>
        <tag>work</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios body事件委托的坑]]></title>
    <url>%2F2017%2F05%2Fios-body%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[部门老大: 这个套餐怎么超出一屏之后点击没反应的… 起因有一个套餐列表是靠接口异步渲染的，所以事件我直接绑定在body上，通过事件委托去触发。这原本没什么问题， 要命的是 reset.css 中把 body, html 高度设置为 100%。 这就可能出现下面的情况 页面过长，拉上去的时候 body 只有 100% 高度，没有覆盖到下面， 所以这时候点击下面的套餐，不算是点击到body上 委托也就无从下手。 解决方法解决方法很简单…. 只需要在页面重置掉那个样式即可 如 body=&gt; height: auto。]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios9 下 domArray forEach 报错]]></title>
    <url>%2F2017%2F05%2Fios9-%E4%B8%8B-domArray-forEach-%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[起因是这样的，产品需求需要输入框输入后，要根据内容高度自适应，最高不能超过3行， 于是写了一个小函数 123456789101112131415const textareaAutoHeight = (className, &#123;multiple=3&#125;=&#123;&#125;)=&gt;&#123; let domList = document.querySelectorAll(className); domList.forEach(item=&gt; &#123; let _height = item.offsetHeight; // item.offsetHeight 用zepto 的 height保险一点 item.addEventListener('keyup', (e)=&gt; updateHeight(e, _height*multiple)); &#125;); function updateHeight(e, _height) &#123; let o = e.target; o.style.height = '1px'; o.style.height = Math.min(o.scrollHeight, _height) + 'px'; &#125;&#125; 传入dom标识加上行数，用的很开心。没毛病 没问题。 项目上线后，发现说在某些机型下会报错，后面排查到是这个函数的错。原因是 ios9 一下。 domList 不是一个数组。 所以改动了一下 1234567891011121314151617const textareaAutoHeight = (className, &#123;multiple=3&#125;=&#123;&#125;)=&gt;&#123; try &#123; let domList = [...document.querySelectorAll(className)]; domList.forEach(item=&gt; &#123; let _height = item.offsetHeight; // item.offsetHeight 用zepto 的 height保险一点 item.addEventListener('keyup', (e)=&gt; updateHeight(e, _height*multiple)); &#125;); function updateHeight(e, _height) &#123; let o = e.target; o.style.height = '1px'; o.style.height = Math.min(o.scrollHeight, _height) + 'px'; &#125; &#125; catch(e) &#123; console.warn('JSONZ textareaAutoHeight', e)&#125;&#125; 加了一个 try...catch... 并且把 domList 用es6转为数组类型. 以后写工具类方法，尽量加多一个 try..catch... 至少保证不影响主流程]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 代码分割(异步加载加快首屏速度)]]></title>
    <url>%2F2017%2F05%2Fwebpack-%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2-%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E5%8A%A0%E5%BF%AB%E9%A6%96%E5%B1%8F%E9%80%9F%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[概述对于单页应用，将所有代码打包成一个文件，可以减少网络请求，并且后面页面不需要再去加载js 可以减少白页时间。 但是对于首页需要快速加载的情况，我们可能需要重新考虑一下， 是否可以把一些不需要第一时间执行的代码异步加载进来。 Webpack有一个功能可以将您的代码库分解成按需加载的“块”，这个功能叫 代码分割。 Webpack的对于块的执行是， 异步创建&lt;script&gt;标签，把需要加载的脚本加载进来再执行。 具体有两种使用方法: CommonJs: require.ensure AMD: requireES6 Modules 暂不支持 AMD: require12345require(dependencies, callback)require(["module-a", "module-b"], function(a, b) &#123; // ...&#125;); dependencies: 模块依赖数组 callback: 回调函数 CommonJs: require.ensure12345require.ensure(dependencies, callback, chunkName);require.ensure(["module-a", "module-b"], function() &#123; var a = require("module-a"); // ...&#125;); dependencies: 依赖的模块数组 callback: 回调函数，该函数调用时会传一个require参数 chunkName: 模块名，用于构建时生成文件时命名使用 对于 CommonJs 方法， 个人在项目中都是这么用的 12345678require.ensure([],require=&gt;&#123; const menuBar = require('./menuBar'); const upcomingTrips = require('./upcomingTrips'); require('./c'); menuBar.init(); upcomingTrips.init();&#125;,'index_later'); 依赖不写dependencies 而是直接写在 回调里面。 因为webpack会去递归拿依赖模块，所以就算我 menuBar里面依赖到其他模块，也会被下载下来 所以问题不大。 但是如果对于多模块互相依赖的情况，建议按照官方demo写法 防止重复嵌套打包。]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie.js 简单的cookie操作插件]]></title>
    <url>%2F2017%2F05%2Fcookie-js-%E7%AE%80%E5%8D%95%E7%9A%84cookie%E6%93%8D%E4%BD%9C%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[对操作cookie做一些接口, 包括 set, get, remove, clear, getAll 等， 都支持批量处理。 用法12345678910111213141516// 获取Cookie.get('name');// 设置Cookie.set(&#123;key: val, key1: val1&#125;, opts);Cookie.set('key', 'val');// 移除某个值Cookie.remove(name);Cookie.remove([name1, name2]);// 清除CookieCookie.clear();// 获取所有cookieCookie.getAll(); // &#123;key: val&#125; 源码解析set设置cookie, 如果之前没有接触过cookie.set 可以参考文档 https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/cookies/set 添加cookie比较特殊，直接用 document.cookie = 你要设置的cookie 就可以了。 1234567891011121314151617181920set(name, value, opts) &#123; if (isObject(name)) &#123; for (let key in name) &#123; if (name.hasOwnProperty(key)) this.set(key, name[key], value); &#125; &#125; else &#123; let opt = isObject(opts)? opts: &#123; expires: opts&#125;, expires = typeof opt.expires === 'undefined'? '': opt.expires, expiresType = typeof expires, path = typeof opt.path === 'undefined'? ';path=/': `;path=$&#123;opt.path&#125;`, domain = opt.domain? `;domain=$&#123;opt.domain&#125;`: '', secure = opt.secure? ';secure': ''; if (expiresType === 'string' &amp;&amp; expires) expires = new Date(expires); else if (expiresType === 'number') expires = new Date(+new Date + 1000 * 60 * 60 * 24 * expires); if (expires !== '' &amp;&amp; 'toGMTString' in expires) expires = ';expires=' + expires.toGMTString(); document.cookie = [name, '=', encodeURI(value), expires, path, domain, secure].join(''); &#125;&#125;, get获取cookie 其实就是遍历 document.cookie 然后根据 name 去匹配 1234567891011get(name) &#123; let cookieName = name + '=', ca = document.cookie.split(';'); for (let i = 0; i &lt; ca.length; i++) &#123; let cItem = (ca[i][0] === ' ')? ca[i].slice(1): ca[i]; if (cItem.indexOf(cookieName) === 0) return decodeURI(cItem.substr(cookieName.length+1)); &#125; return false;&#125;, remove移除cookie其实就是把这个cookie 设置为过期。 1234567remove(name) &#123; let names = Array.isArray(name)? name: [name]; for (let i= 0; i&lt; names.length; i++) &#123; this.set(names[i], '', -1); &#125; return names;&#125;, clear遍历document.cookie 把所有的cookie 调用一次remove. 123clear(name) &#123; return name? this.remove(name): this.remove(Object.keys(this.getAll()));&#125;, getAll获取本地所有的cookie， 返回 {key: value} 形式 123456789getAll() &#123; if (document.cookie === '') return &#123;&#125;; let cookies = document.cookie.split('; '), result = &#123;&#125;; for (let i= 0; i&lt; cookies.length; i++) &#123; let item = cookies[i].split('='); result[decodeURI(item[0])] = decodeURI(item[1]); &#125; return result;&#125; 源码Jsonz-github 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const isObject = obj=&gt; !!value &amp;&amp; Object.prototype.toString.call(obj) === '[object Object]';const Cookie = &#123; get(name) &#123; let cookieName = name + '=', ca = document.cookie.split(';'); for (let i = 0; i &lt; ca.length; i++) &#123; let cItem = (ca[i][0] === ' ')? ca[i].slice(1): ca[i]; if (cItem.indexOf(cookieName) === 0) return decodeURI(cItem.substr(cookieName.length+1)); &#125; return false; &#125;, set(name, value, opts) &#123; if (isObject(name)) &#123; for (let key in name) &#123; if (name.hasOwnProperty(key)) this.set(key, name[key], value); &#125; &#125; else &#123; let opt = isObject(opts)? opts: &#123; expires: opts&#125;, expires = typeof opt.expires === 'undefined'? '': opt.expires, expiresType = typeof expires, path = typeof opt.path === 'undefined'? ';path=/': `;path=$&#123;opt.path&#125;`, domain = opt.domain? `;domain=$&#123;opt.domain&#125;`: '', secure = opt.secure? ';secure': ''; if (expiresType === 'string' &amp;&amp; expires) expires = new Date(expires); else if (expiresType === 'number') expires = new Date(+new Date + 1000 * 60 * 60 * 24 * expires); if (expires !== '' &amp;&amp; 'toGMTString' in expires) expires = ';expires=' + expires.toGMTString(); document.cookie = [name, '=', encodeURI(value), expires, path, domain, secure].join(''); &#125; &#125;, remove(name) &#123; let names = Array.isArray(name)? name: [name]; for (let i= 0; i&lt; names.length; i++) &#123; this.set(names[i], '', -1); &#125; return names; &#125;, clear(name) &#123; return name? this.remove(name): this.remove(Object.keys(this.getAll())); &#125;, getAll() &#123; if (document.cookie === '') return &#123;&#125;; let cookies = document.cookie.split('; '), result = &#123;&#125;; for (let i= 0; i&lt; cookies.length; i++) &#123; let item = cookies[i].split('='); result[decodeURI(item[0])] = decodeURI(item[1]); &#125; return result; &#125;&#125;; 参考https://github.com/jaywcjlove/cookie.jshttps://developer.mozilla.org/en-US/search?q=cookie]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>github</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CORS 跨域资源共享]]></title>
    <url>%2F2017%2F05%2FCORS-%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing） 出于安全考虑，浏览器会限制某些跨域请求。 而 cors 允许浏览器想跨源服务器发起 XMLHttpRequest 和 Fetch 接口请求。 同源策略同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。 那么浏览器是根据什么规则来判定是否为同源呢 http://www.zuzuche.com:80 协议: http 端口: 80 (默认为80 如果没写 浏览器会帮我们做这些工作) 域名 www.zuzuche.com 如果协议， 端口， 域名一致，那么浏览器就会认定我们是在同个源下面。否则就会出现跨域问题。 具体文档等可见 简单请求与非简单请求简单请求指的是 请求方法是以下方法之一 GET POST HEAD 不自定义某些头部字段 Accept Accept-Language Content-Language Content-Type （需要注意额外的限制） DPR Downlink Save-Data Viewport-Width Width Content-Type 为以下值之一 application/x-www-form-urlencoded multipart/form-data text/plain 非简单请求(预检请求)指的是 使用了下面任一HTTP方法： PUT DELETE CONNECT OPTIONS TRACE PATCH 人为设置某些头部字段 Accept Accept-Language Content-Language Content-Type (but note the additional requirements below) DPR Downlink Save-Data Viewport-Width Width Content-Type的值不属于下列之一 application/x-www-form-urlencoded multipart/form-data text/plain 发起一个简单的请求1fetch(''); 此时会发起一个简单请求，和我们平时写的ajax没多大区别 发起一个非简单请求123456789101112131415var invocation = new XMLHttpRequest();var url = &apos;http://bar.other/resources/post-here/&apos;;var body = &apos;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;person&gt;&lt;name&gt;Arun&lt;/name&gt;&lt;/person&gt;&apos;; function callOtherDomain()&#123; if(invocation) &#123; invocation.open(&apos;POST&apos;, url, true); invocation.setRequestHeader(&apos;X-PINGOTHER&apos;, &apos;pingpong&apos;); invocation.setRequestHeader(&apos;Content-Type&apos;, &apos;application/xml&apos;); invocation.onreadystatechange = function()&#123;&#125;; invocation.send(body); &#125;&#125;callOtherDomain(); 此时发起的是一个非简单请求，所以浏览器会先发一个options请求服务器，以获知浏览器是否允许实际请求，如果允许再会发多一个真实请求。 cors我们要跨域获取资源，主要要后台人员配合。 一般情况我们只需要把报错信息给后台人员看就知道怎么做了，比如我直接调用 报了一个跨域问题 Fetch API cannot load https://www.baidu.com/. No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘https://developer.mozilla.org&#39; is therefore not allowed access. If an opaque response serves your needs, set the request’s mode to ‘no-cors’ to fetch the resource with CORS disabled. 直接把错误丢给后台人员，他们就知道设置一个属性 Access-Control-Allow-Origi 一般设置为 * 谁都可以访问 也可以根据情景设定特定的域名。 参考 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>web</tag>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取滚动条宽度]]></title>
    <url>%2F2017%2F05%2F%E8%8E%B7%E5%8F%96%E6%BB%9A%E5%8A%A8%E6%9D%A1%E5%AE%BD%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[平时工作的时候，我们经常会遇到需要全局 loading 加 遮罩层 的功能。这时候一般会设置 body { overflow: hidden } 防止页面滚动。 但是在 pc 端 如果一个页面有滚动条，突然给设置为没有的话， 可能会出现抖动的现象。 所以我们的解决思路是 在设置样式之后，给body(也可以是其他) 加多一个 padding-right来填充原本滚动条的宽度。 123456789101112131415161718192021function getScrollBarWidth() &#123; var div = document.createElement('div'), styles = &#123; width: '100px', height: '10px', overflow: 'scroll' &#125;, scrollWidth = 0; for (var key in styles) &#123; div.style[key] = styles[key]; &#125; document.body.appendChild(div); scrollWidth = div.offsetWidth - div.clientWidth; div.remove(); return scrollWidth;&#125;// 伪代码思路&#123; body.overflow = hidden; body.paddingRight += getScrollBarWidth();&#125;]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>work</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端长按弹出复制等选项设置]]></title>
    <url>%2F2017%2F05%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%95%BF%E6%8C%89%E5%BC%B9%E5%87%BA%E5%A4%8D%E5%88%B6%E7%AD%89%E9%80%89%E9%A1%B9%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[今儿产品大佬吐槽一句: 在手机端chrome 浏览器下 点一个文字老是要弹出一个让我划词 好烦。能不能让他不要弹出那些东西来 其实现在很多的 app 内嵌 h5 页面都是喜欢把手机默认的长按弹出菜单[选择， 复制， 剪切] 等禁掉。 1234567// 给所有样式都加上进制弹出长按菜单属性。* &#123; -webkit-user-select: none; user-select: none; &#125;// 记得要给表单排除，一般表单都有复制黏贴的需求input,textarea &#123;-webkit-user-select: text;user-select: text;&#125; 兼容问题 移动端基本兼容]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>work</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Native 错误总结]]></title>
    <url>%2F2017%2F05%2FReact-Native-%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[No bundle URL present.github issues 项目创建大概一个月了，最近突然想再捡起react-native学习， 直接跑react-native run-ios就报红屏 No bundle URL present.github 上的 issues 给出了几种解决方法。 重新安装依赖 Run “react-native run-ios” When the error appears, run “npm install” Then run “react-native run-ios” again. adding NSAllowsLocalNetworking to Info.plist这个解决方法慎重，如果修改了没有解决 请还原该代码12345678910&lt;key&gt;NSAppTransportSecurity&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSAllowsArbitraryLoadsInWebContent&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSAllowsLocalNetworking&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt;&lt;/key&gt; 8081端口被占用mac下kill 该接口，再重新跑 run-ios 12sudo lsof -i :8071kill -9 &lt;PID&gt; 在 xCode 中启动项目删除本地项目中的 ios/build 重新跑 run-ios build项目关闭本地代理，或者设置不去代理 127.0.0.1手动查找解决问题在终端跑 react-native bundle --platform ios --dev false --entry-file index.ios.js --bundle-output ./ios/release/main.jsbundle --assets-dest ./ios/release/main.jsbundle 可以找到报错原因， 比如我是 12345678bundle: startbundle: finishbundle: Writing bundle output to: ./ios/release/main.jsbundleENOENT: no such file or directory, open &apos;./ios/release/main.jsbundle&apos;少了 PureRenderMixin 组件npm i --save react@16.0.0-alpha.6 重新设置 本地loaclhost1234$ sudo vi /private/etc/hosts# Add this line127.0.0.1 localhost 让 xcode 获取权限再重试123sudo xcodebuild -licensereact-native run-ios 开两个终端第一个终端跑 npm start第二个终端再跑 react-native 清除项目 重装1234567brew updatebrew unlink watchmanbrew install watchmanrm -rf ios/build; rm -rf ios/build; rm -rf android/build; rm -rf android/app/build; rm -rf $TMPDIR/react* ; rm -f ios/main.jsbundle; rm -rf node_modules; rm yarn.lock || true; npm cache clean; yarn cache cleanyarn install or npm install 我自己的解决方法把自己的项目代码拷贝出来后，整个项目删了重新安装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** * Sample React Native App * https://github.com/facebook/react-native * @flow */import React, &#123; Component &#125; from &apos;react&apos;;import &#123; AppRegistry, StyleSheet, Text, View&#125; from &apos;react-native&apos;;class Parent extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; hit: false &#125;; &#125; // 次数清零 timeReset() &#123; &#125; willHit() &#123; &#125; componentWillMount() &#123; &#125; componentDidMount() &#123; &#125; shouldComponentUpdate() &#123; return true; &#125; componentWillUpdate() &#123; &#125; componentDidUpdate() &#123; &#125; render() &#123; return ( &lt;View style=&#123;srtles.container&#125;&gt; &#123; this.state.hit ? &lt;Child /&gt; : null &#125; &lt;Text style=&#123;styles.welcome&#125; onPress=&#123;this.timeReset.bind(this)&#125;&gt; 老子心情好，不揍你了 &lt;/Text&gt; &lt;Text style=&#123;styles.instructions&#125; onPress=&#123;this.willHit.bind(this)&#125;&gt; 老子揍你一次 &lt;/Text&gt; &lt;Text style=&#123;styles.instructions&#125; onPress=&#123;this.willHitT.bind(this)&#125;&gt; 老子要揍你三次 &lt;/Text&gt; &lt;/View&gt; ) &#125;&#125;class Child extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; times: 0 &#125; &#125; timesPlus() &#123; let time = this.state.times; times++; this.setState(&#123; times &#125;); &#125; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125; onPress=&#123;this.timesPlus.bind(this)&#125;&gt; 儿子不服 &lt;/Text&gt; &lt;Text style=&#123;styles.instructions&#125;&gt; 你打了我 &#123;this.state.times&#125; 次 &lt;/Text&gt; &lt;/View&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: &apos;center&apos;, alignItems: &apos;center&apos;, backgroundColor: &apos;#F5FCFF&apos;, &#125;, welcome: &#123; fontSize: 20, textAlign: &apos;center&apos;, margin: 10, &#125;, instructions: &#123; textAlign: &apos;center&apos;, color: &apos;#333333&apos;, marginBottom: 5, &#125;,&#125;);AppRegistry.registerComponent(&apos;imooc&apos;, () =&gt; Parent); Cannot Find entry file index.ios.js in any of the project roots红屏 报错，找不到入口文件。 检查自己的 index.ios.js 里面有没有调用初始化的函数如 AppRegistry.registerComponent(&#39;Your project name&#39;, () =&gt; indexComponents);https://github.com/facebook/react-native/issues/4968github 里面列举了截止编写 300+ 条评论。可以搜， 不过原因应该是某个node_module 升级依赖造成的， 所以没事不要乱升级啊。 TypeError: Network request failedios 下请求老是失败，莫名其妙的失败。 后面发现说是因为之前 clean project。 没有重新设置 ios 的请求 http 权限。 打开xCode 找到 Info.plist 在 Information Property List 下新增 NSAppTransportSecurity 这时候会提示你已经有了 NSAppTransportSecurity 是否要修改， 点击是 此时你会发现 NSAppTransportSecurity 已经改名为 App Transport Security Settings。 本机xCode 版本为 8.3.2; 点击 App Transport Security Settings 右边的加号 添加NSAllowsArbitraryLoads(8.3.2版本为 Allow Arbitrary Loads) 后面的值改为 YES。 重启项目即可 具体可见https://stackoverflow.com/questions/31254725/transport-security-has-blocked-a-cleartext-http react-native-image-picker 问题选择图片时奔溃错误其实是因为安装 react-native-image-picker 不够细心，只看到自动安装的时候写着 1react-native link 没看到还要手动在 Info.plist 上添加一些信息，用于备注需要 访问照片权限，麦克风权限（录像需要）， 相机权限等。 所以程序会报一个 SIGABRT 的错误. Cannot read property ‘showImagePicker’ of undefinde如果遇到这个问题，是因为你安装该组件后没有重现编译ios代码，重新编译一次即可。 如果还不起作用可以检查一下是否安装正确，再跑命令 rm -rf ios/build &amp;&amp; react-native run-ios React-Native 坑真的是遇过最多的一个]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[imooc React-Native 文字小游戏]]></title>
    <url>%2F2017%2F05%2Fimooc-React-Native-%E6%96%87%E5%AD%97%E5%B0%8F%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[文字小游戏需求： 老子 &amp;&amp; 儿子 -老子打儿子： - 可以打一次 记仇次数+1 - 可以打三次 记仇次数+3 - 可以给个糖 记仇次数清零 儿子反驳老子： 儿子不服 老子打一次 儿子骂老子 老子打三次 儿子买啤酒给老子 记仇次数清零]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>github</tag>
        <tag>imooc</tag>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[setTimeout && setInterval 学习]]></title>
    <url>%2F2017%2F05%2FsetTimeout-setInterval-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[定时器大家平时做js开发都不陌生了 最常见的应用应该就是验证码的倒计时 或 某段函数的异步执行了。 概述js的定时器主要有 setTimeout 和 setInterval. 这两个函数执行后，都会返回一个整数，表示定时器的编号，后面可以通过clearTimeout 或 clearInterval来清除该定时器。 setTimeout和setInterval的运行机制都是 将代码移除本次执行，等待下一轮的 Event Loop再检查是否到执行的时间。所以可以用 setTimeout(()=&gt; {}, 0) 来模拟执行异步操作。 setTimeout执行函数setTimeout 是用来制定某段函数或代码，在多少毫秒延迟后执行。如果传入的是一段代码，必须是字符串类型的。这时候js会调用eval来执行该代码， 出于安全与性能考虑 建议直接传入一个函数的形式来执行。delay 为延迟的时间，单位是ms1var timerId = setTimeout(func|code, delay); 参数setTimeout可以有多个参数，第三个参数开始为传入运行方法的参数。很经典的闭包面试题就可以用setTimeout传参来解决12for (var i = 0; i&lt; 10; i++) &#123; setTimeout(function() &#123; console.log(i)&#125; ,0) &#125; // 运行结果是输出10个10for (var i = 0; i&lt; 10; i++) &#123; setTimeout(function(i) &#123; console.log(i)&#125; ,0, i) &#125; // 运行结果是输出0-9 运行环境setTimeout的运行环境是全局(eval)。demo1123456789var x = 1;var o = &#123; x: 2, y: function() &#123; console.log(this.x); &#125;&#125;setTimeout(o.y, 0); // 此时输出的是1，因为全局(window)上的x属性是1 demo2123456789function User(login) &#123; this.login = login; this.sayHi = function() &#123; console.log(this.login); &#125;&#125;var user = new User('John');setTimeout(user.sayHi, 0); // undefined 因为执行的时候 全局对象没有 login这个属性 解决方法一： 放到一个匿名函数里面执行方法1123setTimeout(function() &#123; user.sayHi();&#125;); 解决方法二： 缓存当前的this变量方法2123456document.body.addEventListener('click', function() &#123; var _this = this; setTimeout(function() &#123; _this.value = 'ok'; &#125;)&#125;, false); 解决方法三： 目前项目中最常用， 用es6的箭头函数方法31setTimeout(()=&gt; user.sayHi(), 0); setIntervalsetInterval的使用方法与参数和setTimeout一致。 不过setInterval是间隔 Xms 执行一次该函数。但实际上 函数执行需要时间，所以两次执行函数之间的间隔会小于 setInterval指定的时间. setInterval 执行时间假定setInterval指定每100ms执行一次，每次执行的函数耗时为 5ms, 那么第一次执行结束后的 95ms 后会执行第二段函数。如果某次执行特别耗时 如 105ms, 那么 当它结束后，会立即执行下一次的函数。 此段为某博客看到的，个人实践得出执行时间有快与慢的偏差没有绝对提前执行 下面看代码例子demo31234567891011121314151617function init() &#123; // 耗时 5ms 的某个操作 handleMouseClick(); // 耗时 5ms 的某个操作 setInterval(timerTask, 10); // 耗时 5ms 的某个操作&#125;function handleMouseClick() &#123; // 耗时 8ms 的某个操作&#125;function timerTask() &#123; // 耗时 2ms 的某个操作&#125;init(); 网上博客说法（此处保留意见）：0-15ms: 运行init15-23ms: 运行handleMouseClick函数。请注意，这个函数是在5ms时触发的，应该在那个时候就立即运行，但是由于单线程的关系，必须等到init函数完成之后再运行。23-25ms: 运行timerTask函数。 规定每10ms运行一次，既在20ms， 30ms， 40ms会运行。但是由于当前还有任务在运行，因此必须延迟到前面任务完成后再运行30-32ms: 运行timerTask40-42ms: 运行timerTask 由于平时debug调试时，在handleMouseClick应该不会等到init运行后再执行。于是抱着学习的态度自己写了一段代码demo412function _init() &#123; demo(10);console.log(1); demo(10); handle(); demo(10);console.log(2); setInterval(()=&gt; console.log('setInterval'), 1000); console.log(3) &#125;; function handle() &#123;demo(15); console.log('handle')&#125;;function demo(i) &#123;var sum = 0; for (var j = 0; j &lt; i * 1000000; j++) &#123;sum += j;&#125;&#125;;_init(); 利用for循环来造成运行实践的延长运行 _init() 结果是：① 输出1 隔26ms后 输出handle 隔10ms后 输出2 同一时间输出3(此处可以理解成执行的时间小于1ms)。此时 _init()执行结束 由于没有返回值，所以会默认返回 undefined② _init()执行结束之后 再去跑 setInterval定时器 所以 隔 1000ms(实际是1005ms) 后输出第一个setInterval。间隔 999ms后输出第二个setInterval 间隔 997ms后输出第三个 setInterval所以觉得说setInterval是当前所有函数运行后才开启定时的，而不是执行到setInterval的时候开始计时。而且运行的间隔不是固定偏多或偏少 最后再给出一个例子理解setTimeout的异步执行机制demo512345678910111213141516171819setTimeout(function() &#123; console.log("Timeout");&#125;, 0);function a(x) &#123; console.log("a() 开始运行"); b(x); console.log("a() 结束运行");&#125;function b(y) &#123; console.log("b() 开始运行"); console.log("传入的值为" + y); console.log("b() 结束运行");&#125;console.log("当前任务开始");a(42);console.log("当前任务结束"); 运行结果为当前任务开始a() 开始运行b() 开始运行传入的值是 42b() 运行结束a() 运行结束当前任务结束timeout 后记无。]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>github</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webstorm 快捷键整理]]></title>
    <url>%2F2017%2F05%2Fwebstorm%2F</url>
    <content type="text"><![CDATA[alt =&gt; optioncommand =&gt; 开始control =&gt; ctrlbutton 1 click 鼠标左键button 2 click 鼠标右键斜体 为不常用粗体 为常用 Editor Actions Add or Remove Caret =&gt; 类似sublime的多行编辑功能 =&gt; alt + button1 Click Add Rectangular selection on mouse drag =&gt; 鼠标矩形选择 =&gt; remove keyMap 没啥卵用 Backspace =&gt; 退格（既删除）=&gt; Backspace 键盘上的退格键，没什么可说的 Move Caret Backward a Paragraph =&gt; 移动光标到上一个段落（既上一个空行处） =&gt; 默认无 Choose lookup item =&gt; Enter =&gt; 既选择当前智能提示的项 Choose Lookup Item and Invoke Complete Statement =&gt; 不知道有什么用 Choose Lookup Item and Insert Dot =&gt; 选择当前项并再最后加入. 既自动完成Enter + . Choose Lookup Item Replace =&gt; 不知道有什么用 Clone Caret Above =&gt; 在当前行上创建多一个光标，不常用 Clone Caret Below =&gt; 在当前行下创建多一个光标，不常用 Move Caret to Code Block End =&gt; 将光标移至块代码结束 =&gt; command + ] || alt + ] Move Caret to Code Block Start =&gt; 将光标移至块代码开始 =&gt; command + [ || atl + [ Move Caret to Code Block End with Selection =&gt; 将光标移至块代码结束并选择, 不常用 Move Caret to Code Block Start with Selection =&gt; 将光标移至块代码开始并选择, 不常用 Complete Current Statement =&gt; 完成当前声明（语句），既如果该行结束则加; 如果是 if (a = 10) 则开一个{} 并将光标移至花括号内 =&gt; 默认 ctrl + shift + enter 不常用 Create Rectangular Selection =&gt; 创建矩形选择 =&gt; alt+shift+button2 click Cut Line Backward =&gt; 从当前光标向前选择并剪切 Cut up to Line End =&gt; 从当前光标向后选择并剪切 Decrease Font Size =&gt; 缩小字体 Delete =&gt; 删除 (和Backspace用起来效果一致) =&gt; 退格键 Delete Line =&gt; 删除整行 一般我都会用 command + x || ctrl + x 代替，既直接剪切整行 Delete to Line End =&gt; 当前光标删除到行尾，一般我用command + 箭头 + shift选中后再删除 Delete to Line Start 同上 Delete to word end &amp;&amp; Delete to word start 等同理不赘述 Down with Selection 向下并选择 Shift + 向下箭头 Duplicate Line or Selection 复制该行 =&gt; 默认为ctrl + d， 但我移除了 Move caret forward a Paragraph 同上 Hungry Backspace 不知道有什么用 Increase Font Size 放大字体 Join Lines =&gt; 把下一行添加到本行，既删除换行符与空格 =&gt; ctrl + shift + j Kill selected region，Save to Kill Ring ，kill the word end, kill the word start 不知道有什么用 Move Caret to Line End =&gt; 将光标移至行尾，类似win上的end =&gt; command + → TODO: window 上修改成一致 Move Caret to Line End with Selection 移动光标至行尾并选中 =&gt; command + shift + → TODO: window上修改一致 Move Caret to Matching Brace 将光标移至当前匹配的括号 =&gt; control + m TODO: window 上的确定 Move Caret to Page Bottom 将光标移至页面底部 =&gt; command + 下箭头 Move Caret to Page Top with Selection 将光标移至页首并选中 Move Caret to Next Word 移动光标到下一个单词 =&gt; alt + → TODO: window确定 Move Caret to Prev Word 等同理 Move Cartet to Next Word with Selection 移动光标到下个单词并选中 =&gt; alt + shift + → Page Down 页面向下滚动一屏 fn + 下箭头 TODO: window Page Down with Selection 页面向下滚动一屏并选中该屏 =&gt; fn + shift + 下箭头 TODO: window Page Up &amp;&amp; Page Up with Selection 同理 Paste from X clipboard 不知道有什么用 Paste Simple 不知道有什么用 Reset Font Size 重置字体大小 Right Left Down Up 等…. Scroll To Bottom, Scroll Down …等等 都是滚动方向 Duplicate Line or Selection 复制整行或选中的区域 一般都会手动选择整行去复制 Duplicate Entire Lines Extend Selection 扩展选择 alt + 上箭头 解除 Split Line 光标下添加多一行 =&gt; command + enter TODO: window Start New Line 开启新的一行 相当于光标移至行尾，回车 =&gt; shift + enter TODO: window Start New Line Before Current 在当前行的上一行新建一行并将光标移至此处 相当于光标移到上行尾再回车 Swap selection boundaries 交换选择边界 Tab tab Move Caret to Text End, Move Caret To Text Start 等 Toggle Case 光标在大小写切换 Toggle Insert/Overwrite =&gt; 切换插入/替换 window 上的 insert 功能 shrink Selection 缩小选择 =&gt; shift + 下箭头 不知道有什么用 ​Emacs tab, Fill Paragraph, Expand Live Template / Emmet Abbreviation, Next Paramete, Prev Paramete 不知道什么用 Main menu列举平日用得到的 ##### new =&gt; 新建文件 =&gt; command + N new Scratch File 新建临时文件，比如可以新建一个es6语法的临时文件，里面写完再复制到某些地方 提供语法支持 =&gt; shift + command + n Preferences 打开设置 =&gt; command + , window: alt + ctrl + s Synchronize 重新加载磁盘文件并同步 =&gt; alt + command + y Navigate File… =&gt; 按文件名查找文件 =&gt; command + shift + O 改 command + p 和sublime Text保持一致 Edit Undo =&gt; 撤销 =&gt; command + z Redo =&gt; 撤销的反方向 =&gt; shift + command + z Cut =&gt; 剪切 =&gt; command + x Copy =&gt; 复制 =&gt; command + c Copy Paths =&gt; 复制路径 =&gt; command + c + shift Paste =&gt; 黏贴 =&gt; command + v— Paste from History =&gt; 打开黏贴板历史 =&gt; command + shift + v Find… =&gt; 查找 =&gt; command + f Replace… =&gt; 替换 =&gt; Command + r Add Selection for Next Occurrence =&gt; 选中相同的词 =&gt; 默认 ctrl + g 改 ctrl + d Select All =&gt; 选择所有 =&gt; command + A 自己修改的比较常见的 Select In… =&gt; alt 1 then 1 定位到当前正在编辑的文件，这个功能vscode 自动完成的 还是比较常用 以前很喜欢用webstorm, 后面在mac上面不习惯快捷键就放弃转战其他 atom等。 这次特地下来回来，设置了快捷键但最后 还是用回了vs code。最后附上配置Mac]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>editor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的网页点击热力图]]></title>
    <url>%2F2017%2F05%2F%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E9%A1%B5%E7%82%B9%E5%87%BB%E7%83%AD%E5%8A%9B%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[前两天老大突然喊我和一小伙子出去开会，说有个好玩的东西给你们玩。 想给网站做个简单的热力图， 记录用户点击了什么位置。要求是，怎么简单怎么实现 先做一版出来 后面再慢慢迭代优化， 定的工作量大概是两人一天。。。。 之前没接触过图表，虽然有接触过埋点统计/talkingData 不过对于这种都是一知半解。具体有两个步骤，一个是数据的记录（入库），一个是展示模式（读取）。 于是下班回到家后没事就先查了资料，想大概写个能定位置的出来看着先。 需求分析 需要传递给后台保存的数据 url 当前页面url(包不包括search, hash 等) screenHeight 屏幕高度 screenWidth 屏幕高度 list 具体坐标的数组 {x: 鼠标相对于屏幕x轴坐标, y: 鼠标相对于屏幕y轴坐标, pageX: 鼠标相对于dom文档的x轴坐标, pageY: 鼠标相对于dom文档的y轴坐标} 代表用户的一个code 不能每次点击都发送，间隔10秒发送一次 后台还没做先在本地sessionLocation做模拟测试 具体实现鼠标点击对象属性特别推荐 Mozilla 开发者平台，现在基本上js html等东西想了解具体或详细的属性都会上这个网站查询https://developer.mozilla.org/zh-CN/大部分有多语言标签。 可以先到这里查看鼠标的具体属性解析developer.mozilla 12345678以下两个指的都是已可视区域左上角为原点(0, 0) 向右 向下正坐标MouseEvent.clientX clientX属性代表点击在元素上的鼠标指针的X坐标；MouseEvent.clientY clientY属性代表点击在元素上的鼠标指针的Y坐标；以下两个指的都是物理屏幕以左上角为原点（0， 0） 向右 向下正坐标MouseEvent.screenXMouseEvent.screenY 这里传递给后台的 x 采用的是 MouseEvent.clientX; y 取的是 MouseEvent.clientY; pageX 取的是 页面滚动宽度 + x; PageY 取的是 页面滚动高度 + y 12页面滚动高度: document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop || 0页面滚动宽度: document.documentElement.scrollLeft || window.pageXOffset || document.body.scrollLeft || 0 具体页面滚动高度与宽度的兼容问题可以查看 http://www.cnblogs.com/xwgli/p/3490466.html 屏幕高度宽度屏幕高度宽度 1234window.screen.height, 屏幕高度window.screen.width, 屏幕宽度window.screen.availHeight, 屏幕可用工作区高度，如mac的除去顶部工具条外的高度window.screen.availWidth 同上 监听url变化后期优化需求，因为还不确定是要每条基本location.namepath当成一个页面还是要把每个不同的 search、hash都当成一个独立的页面。 绘制热力图绘制热力图暂时的展示效果在原页面添加一个文档大小的canvas，然后采用一个js 热力图插件https://github.com/pa7/heatmap.js传递坐标来生成热力图。 源码因为只是晚上回家临时写了一个可以看效果的，所以没有代码分离 脏数据检查 等功能app.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215// style Util Fnconst styleFn = (el, styleObj = &#123;&#125;) =&gt; &#123; if (!el) throw new Error(el); for (let [key, value] of Object.entries(styleObj)) &#123; el.style[key] = value; &#125; return el;&#125;;/** * 需要发送到后台的数据 */class HeatCollect &#123; constructor(opts = &#123;&#125;) &#123; this.initProps(opts); // 初始化属性 this.setDataForServer(); // 启动定时器 定时发送数据给服务器 return this; &#125; initProps(opts) &#123; this.list = []; this.url = location.href; this.screenHeight = window.screen.height; this.screenWidth = window.screen.width; this.serverCode = '1001'; this.index = 0; this.timer = null; this.time = opts.time || 10; // 默认10秒 this.maxLength = opts.maxLength || 100; // 默认最多可以存100个坐标 this.Time = 0; this.queue = []; // 队列 暂存请求的坐标 &#125; // 向当前类添加坐标 push(obj) &#123; obj.index = ++this.index; this.list.push(obj); this.list = this.list.splice(0, 100); // 防止恶意过长 return this.list; &#125; // 获取向服务器传递的数据格式 getServerData() &#123; return &#123; list: this.queue, url: this.url, screenHeight: this.screenHeight, screenWidth: this.screenWidth, serverCode: this.serverCode, timestamp: Date.now(), &#125; &#125; // 发送数据到服务器 setDataForServer() &#123; clearTimeout(this.timer); this.timer = setTimeout(() =&gt; &#123; this.queue = this.list.splice(0, Math.min(this.list.length, 100)); if (!this.queue.length) return this.setDataForServer(); Server.setData(this.getServerData()).then((&#123; code &#125;) =&gt; &#123; if (code === 0) &#123; this.queue = []; &#125; else &#123; this.list = this.queue.concat(this.list); &#125; &#125;, () =&gt; &#123; this.list = this.queue.concat(this.list); &#125;).then(() =&gt; &#123; this.setDataForServer(); &#125;); &#125;, this.time * 1000) &#125;&#125;/** * 绘制函数 */class Draw &#123; constructor() &#123; this.initCanvas(); return this; &#125; // 初始化展示的dom initDom() &#123; let dom = document.createElement('div'), domParent = document.createElement('div'); dom.id = 'heatmapContainer'; domParent.id = 'heatmapContainerWrapper'; domParent.appendChild(dom); domParent.style.height = document.documentElement.offsetHeight + 'px'; domParent.style.width = document.documentElement.offsetWidth + 'px' ; document.body.appendChild(domParent); &#125; // 初始化展示的canvas initCanvas() &#123; this.initDom(); this.heatmap = h337.create(&#123; container: document.getElementById('heatmapContainer'), maxOpacity: .6, radius: 50, blur: .90, backgroundColor: 'rgba(0, 0, 0, 0)' &#125;); &#125; // 遍历绘制canvas上的热点 draw(list) &#123; for (let i = 0; i &lt; list.length; i++) &#123; this.heatmap.addData(this.getDrawData(list[i])); &#125; &#125; // 获取要绘制的数据格式 getDrawData(data) &#123; return &#123; x: data.pageX, y: data.pageY, value: 1 &#125; &#125;&#125;/** * 处理兼容等工具类 */const Util = &#123; // 获取鼠标坐标 getMouseInfo(e) &#123; let &#123; officeX, officeY &#125; = this.getPageOffice(), &#123; clientX: x, clientY: y &#125; = e; return &#123; pageX: officeX + x, pageY: officeY + y, x, y, &#125; &#125;, // 获取页面高宽 getPageOffice() &#123; let officeY = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop || 0, officeX = document.documentElement.scrollLeft || window.pageXOffset || document.body.scrollLeft || 0; return &#123; officeX, officeY &#125; &#125;,&#125;;/** * 入口函数 */const Main = &#123; init() &#123; this.infoData = new HeatCollect(); this.draw = new Draw(); document.documentElement.addEventListener('click', (e) =&gt; this.mouseEvent(e)); &#125;, mouseEvent(e) &#123; let _mouseData = Util.getMouseInfo(e); this.infoData.push(_mouseData); &#125;, drawFn() &#123; let list = JSON.parse(sessionStorage.getItem('test') || '&#123;&#125;').list || []; this.draw.draw(list); &#125;&#125;;Main.init();Main.drawFn();// 模拟发送请求const Server = &#123; setData(data) &#123; return new Promise((res, rej) =&gt; &#123; setTimeout(() =&gt; &#123; let isSuccess = Math.random() &lt; .95; if (isSuccess) &#123; let oldData = sessionStorage.getItem('test'); if (oldData) &#123; oldData = JSON.parse(oldData); oldData.list = oldData.list.concat(data.list); &#125; else &#123; oldData = data; &#125; sessionStorage.setItem('test', JSON.stringify(oldData)); console.log('success', oldData.list); res(&#123; code: 0, data &#125;) &#125; else &#123; rej(&#123; code: 5000 &#125;) &#125; &#125;, 2000); &#125;); &#125;&#125;; index.html1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;style&gt; body, html &#123; height: 3000px; width: 2000px; &#125; #heatMap &#123; height: 100%; width: 100%; position: relative; border:1px solid red; &#125; #heatmapContainer &#123; width:100%; height:100%; &#125; #heatmapContainerWrapper &#123; position:absolute; left: 0; right: 0; top: 0; bottom: 0;&#125;&lt;/style&gt;&lt;script src="heatmap.js"&gt;&lt;/script&gt;&lt;script src="app.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; html中引入的热力图 后话效果图至此 简单的热力图实现完成， 隔天回到公司，老大说 公司已经和第三方服务平台购买了统计之类的服务。。。。。。于是乎当做是自己饭后无聊写点代码消遣消遣。不过热力图很多东西需要处理，不是一两个人短时间可以完成的。最后附上效果与项目目录]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>github</tag>
        <tag>JavaScript</tag>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[imooc-react-native实战 项目入门知识学习]]></title>
    <url>%2F2017%2F05%2Fimooc-react-native%E5%AE%9E%E6%88%98-%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[选用的版本的 v0.22.2 组件生命周期初始化开始 =&gt; getDefaultProps =&gt; getInitialState =&gt; componentWillMount =&gt; render =&gt; componentDidMount =&gt; 组件运行中， state状态改变 =&gt; shouldComponentUpdate 判断是否要更新 return true =&gt; componentWillUpdate =&gt; render 继续循环 =&gt; 外部props改变 =&gt; componentWillReceiveProps =&gt; unmount 卸载组件 =&gt; componentWillUnmount 等等]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>JavaScript</tag>
        <tag>imooc</tag>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios网络操作基础教程]]></title>
    <url>%2F2017%2F05%2Fios%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[demo源码 网络解析与网络请求有关的类 NSURL: 客户端访问哪台服务器的制定资源 NSURLRequest: 客户端发起的网络请求内容 : 客户端服务器建立的网络连接 NSURLResponse: 服务端给予客户端的响应结果 发起第一个网络请求AppDelegate.m123456789101112131415161718192021- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. // 创建一个url对象 用来表示访问的服务器 NSURL *url = [NSURL URLWithString:@"http://www.imooc.com"]; // 客户端发起的网络请求的请求内容 NSURLRequest *request = [NSURLRequest requestWithURL: url]; NSURLConnection *connection = [[NSURLConnection alloc] initWithRequest:request delegate:self]; // 启动网络请求 [connection start]; return YES;&#125;- (void) connection: (NSURLConnection *) connection didReceiveResponse: (NSURLResponse * )response &#123; // 服务器给客户端的响应结果 NSLog(@"response: %@", response);&#125; 键入以上代码后按cmd+r运行一下，此时控制台并没有输出我们想要的结果，而是输出了1App Transport Security has blocked a cleartext HTTP (http://) resource load since it is insecure. Temporary exceptions can be configured via your app&apos;s Info.plist file. 提示我们已经阻止了明文http请求，因为他是不安全的，可以通过Info.plist配置解除请求。在项目根目录里打开Info.plist， 添加 App Transport Security Settings 并在App Transport Security Settings下添加Allow Arbitrary Loads值为YES。 然后重新运行就好了 使用Get方式发送请求搭建用户信息界面api接口已经返回的参数格式结构 新建项目新建cocoa Class=&gt;UserInfoViewController继承UIViewController新建cocoa Class=&gt;KeyValueView继承UIView如图 先在KeyValueView.h 声明所需的变量已经方法KeyValueView.h12345678@interface KeyValueView : UIView@property (nonatomic, strong) UILabel *keyLabel;@property (nonatomic, strong) UILabel *valueLabel;- (void) setupKey: (NSString *)key value:(NSString *)value;@end 并在KeyValueView.m实现KeyValueView.m1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#import "KeyValueView.h"@implementation KeyValueView-(id) initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; // 添加keyLabel // 如果存在父级，则创建一个 UILabel x:0, y:0, 宽：父级宽度1/3, 高: 父级高度 _keyLabel = [[UILabel alloc] initWithFrame: CGRectMake(0, 0, CGRectGetWidth(self.frame) /3, CGRectGetHeight(self.frame))]; // 设置背景色为透明 _keyLabel.backgroundColor = [UIColor clearColor]; // 文字居左对齐 _keyLabel.textAlignment = NSTextAlignmentLeft; // 设置字体大小 _keyLabel.font = [UIFont systemFontOfSize: 16]; // 设置字体颜色 _keyLabel.textColor = [UIColor blackColor]; // 添加到父级 [self addSubview: _keyLabel]; // 添加valueLabel // 如果存在父级，则创建一个 UILabel x:0, y:0, 宽：父级宽度1/3, 高: 父级高度 _valueLabel = [[UILabel alloc] initWithFrame: CGRectMake(CGRectGetWidth(self.frame) /3, 0, CGRectGetWidth(self.frame) * 2 /3, CGRectGetHeight(self.frame))]; // 设置背景色为透明 _valueLabel.backgroundColor = [UIColor clearColor]; // 文字居左对齐 _valueLabel.textAlignment = NSTextAlignmentLeft; // 设置字体大小 _valueLabel.font = [UIFont systemFontOfSize: 16]; // 设置字体颜色 _valueLabel.textColor = [UIColor blackColor]; // 添加到父级 [self addSubview: _valueLabel]; &#125; return self;&#125;-(void)setupKey:(NSString *)key value:(NSString *)value&#123; // 给keyLabel &amp;&amp; valueLabel 赋值的方法 [_keyLabel setText:key]; [_valueLabel setText:value];&#125; 接着我们要在UserInfoViewController去调用keyValueView的UIView类UserInfoViewController.h1234567891011121314#import &lt;UIKit/UIKit.h&gt;// 引入keyvalue#import "KeyValueView.h"@interface UserInfoViewController : UIViewController// 把所有个人信息录到这里 ( 声明 )@property (nonatomic, strong) KeyValueView *userNameView; // 用户名信息@property (nonatomic, strong) KeyValueView *userSexView; // 用户性别@property (nonatomic, strong) KeyValueView *birthdayView; // 生日@property (nonatomic, strong) KeyValueView *emailView; // email@property (nonatomic, strong) KeyValueView *phoneView; // 手机号@end UserInfoViewController.m1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#import "UserInfoViewController.h"//定义两个宏 屏幕宽度与高度，一般项目都会定义方便使用#define KScreenWidth [[UIScreen mainScreen] bounds].size.width#define KScreenHeight [[UIScreen mainScreen] bounds].size.height@interface UserInfoViewController ()@end@implementation UserInfoViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. // 给父级加背景色 [self.view setBackgroundColor: [UIColor whiteColor]]; // 手动创建一个标题 UILabel *titleLable = [[UILabel alloc] initWithFrame:CGRectMake(0, 40, KScreenWidth, 20)]; // 设置标题信息 [titleLable setText:@"个人用户信息"]; titleLable.textAlignment = NSTextAlignmentCenter; titleLable.font = [UIFont systemFontOfSize:18]; titleLable.backgroundColor = [UIColor clearColor]; [self.view addSubview: titleLable]; // 创建一个用户名控件 _userNameView = [[KeyValueView alloc] initWithFrame:CGRectMake(100, 70, KScreenWidth - 100 * 2, 30)]; _userNameView.backgroundColor = [UIColor clearColor]; [self.view addSubview:_userNameView]; // 创建一个用户性别控件 _userSexView = [[KeyValueView alloc] initWithFrame:CGRectMake(100, 70 + 30, KScreenWidth - 100 * 2, 30)]; _userSexView.backgroundColor = [UIColor clearColor]; [self.view addSubview:_userSexView]; // 创建一个用户生日控件 _birthdayView = [[KeyValueView alloc] initWithFrame:CGRectMake(100, 70+30*2, KScreenWidth - 100 * 2, 30)]; _birthdayView.backgroundColor = [UIColor clearColor]; [self.view addSubview:_birthdayView]; // 创建一个用户邮箱控件 _emailView = [[KeyValueView alloc] initWithFrame:CGRectMake(100, 70 + 30*3, KScreenWidth - 100 * 2, 30)]; _emailView.backgroundColor = [UIColor clearColor]; [self.view addSubview:_emailView]; // 创建一个用户手机号控件 _phoneView = [[KeyValueView alloc] initWithFrame:CGRectMake(100, 70 + 30*4, KScreenWidth - 100 * 2, 30)]; _phoneView.backgroundColor = [UIColor clearColor]; [self.view addSubview:_phoneView];&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;/*#pragma mark - Navigation// In a storyboard-based application, you will often want to do a little preparation before navigation- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123; // Get the new view controller using [segue destinationViewController]. // Pass the selected object to the new view controller.&#125;*/@end view &amp;&amp; controller都写好之后，我们去修改一下AppDelegate，因为默认主view为项目根目录的ViewControll，所以如果我们没有把view设置为我们的UserInfoViewController 运行是没有任何效果的。 AppDelegate.m1234567- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // 第二节 get请求 UserInfoViewController *userInfoVC = [[UserInfoViewController alloc] init]; self.window.rootViewController = userInfoVC; [self.window makeKeyAndVisible]; return YES;&#125; 修改完成后再次运行看效果。此时只出现了标题。 这时候我们可以打开调试看一下为什么我们只出现标题，没有出现KeyValueView呢依次打开xCode菜单Debug=&gt;View Debugging=&gt;Show View Frames这时候可以看到我们的labelView其实是有被加到view中，只是没有数据展示 所以看不出来，接下来我们正式开始发起网络请求数据填充view 发起网络请求数据http://www.imooc.com/video/11982 imooc ios网络操作学习指南]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>Objective-C</tag>
        <tag>ios</tag>
        <tag>imooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS基础教程之界面初体验]]></title>
    <url>%2F2017%2F04%2FiOS%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%95%8C%E9%9D%A2%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[demo源码 如果找不到，则到finish文件下找 创建项目因为要学的是 UIwindow， 所以创建的不再是之前的Command Line Tool。 选择iOS=&gt;Single View Application.语言选择ObjectiveC, 项目名根据自己喜欢的取。 Hello UIwindowmain.m 入门文件不再出现在根目录上，而是在Supporting Files下。默认引用了 &lt;UIKit/UIKit.h&gt; 和 &quot;AppDelegate.h&quot; 点击项目文件 删除 Main Interface的默认值Main 然后打开AppDelegate.m 开始来手动来设置一下mainInterfacez AppDelegate.m123456789101112- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. // 设置大小和位置 `UIScreen mainScreen` 可以得到手机主屏幕 `bounds`是获得大小 _window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; // 设置颜色为红色 _window.backgroundColor = [UIColor redColor]; // 设置根视频控制器 _window.rootViewController = [[UIViewController alloc] init]; // 将window设置为我们的主window [_window makeKeyAndVisible]; return YES;&#125; 修改后按 cmd(⌘)+R或按左上角的三角形按钮来 run app。骚等片刻就可以看到 一个全屏红色的模拟器.; UIView新建一个项目。 UI的基类， 基础 UIView的属性 UIView的方法 UIView的自适应 ViewController.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129//// ViewController.m// UIwindow//// Created by Jsonz on 2017/4/27.// Copyright © 2017年 Jsonz. All rights reserved.//#import "ViewController.h"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; NSLog(@"bilibili"); [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 视图 UIView *view1 = [[UIView alloc] init]; // 实例化view // 状态栏高度为20px 所以写view的时候一般会让出20px view1.frame = CGRectMake(10, 30, 375-20, 667-20); // 背景颜色 view1.backgroundColor = [UIColor redColor]; // 将视图加入到父视图中 [self.view addSubview: view1]; // self.view 是view1的父视图 NSLog(@"frame = x:%f y:%f w:%f h:%f", view1.frame.origin.x, view1.frame.origin.y, view1.frame.size.width, view1.frame.size.height); // 一般叫边框大小， x &amp;&amp; y 永远为0 w&amp;&amp;h 一致 NSLog(@"bounds = x:%f y:%f w:%f h:%f", view1.bounds.origin.x, view1.bounds.origin.y, view1.bounds.size.width, view1.bounds.size.height); // center - 中心点 NSLog(@"center - x:%f y:%f", view1.center.x, view1.center.y); // 图片 1.png // 如果是二倍视网膜屏幕 准备 1@2x.png // 同理还有 1@3x.png NSLog(@"w:%f h:%f",[[UIScreen mainScreen] bounds].size.width, [[UIScreen mainScreen] bounds].size.height); // 父视图 只会有一个 UIView *superView = view1.superview; superView.backgroundColor = [UIColor greenColor]; UIView *view2 = [[UIView alloc] init]; view2.frame = CGRectMake(10, 100, 300, 300); // 坐标全是根据自身父视图来设置的，不会跨层 // 给view设置唯一标识，方便父级视图获取辨认 view2.tag = 2; view2.backgroundColor = [UIColor blackColor]; [view1 addSubview:view2]; UIView *view3 = [[UIView alloc] init]; view3.frame = CGRectMake(20, 50, 100, 100); view3.tag = 3; view3.backgroundColor = [UIColor purpleColor]; [view1 addSubview:view3]; // 子视图 会有多个 NSArray *subViewsArray = view1.subviews; for (UIView *view in subViewsArray) &#123; if (view.tag == 2) view.backgroundColor = [UIColor whiteColor]; // view2变白色 &#125; // 如果知道子视图的tag 可以通过tag得到对应的子视图 UIView *subView = [view1 viewWithTag:3]; subView.backgroundColor = [UIColor greenColor]; // 修改层级 类似css 的 zIndex // 当层交换之后， 对应的子视图的数组下标也会进行改变 // 同一个父视图中，先加入的view层级会比较低 UIView *view4 = [[UIView alloc] init]; view4.frame = CGRectMake(0, 100, 300, 300); view4.backgroundColor = [UIColor yellowColor]; [self.view insertSubview:view4 atIndex:0]; // 这时候 view4会盖住view1的所有界面 // 交换两个层的视图 [superView exchangeSubviewAtIndex:0 withSubviewAtIndex:1]; //插入一个视图到指定层 UIView *view5 = [[UIView alloc] init]; view5.frame = CGRectMake(7, 80, 200, 200); view5.backgroundColor = [UIColor blackColor]; [view1 insertSubview:view5 atIndex:1]; // 将一个view 放最顶层或最底层 [view1 bringSubviewToFront:view2]; // 顶层 [view1 sendSubviewToBack: view2]; // 底层 // 自适应 UIView *backView = [[UIView alloc] init]; backView.frame = CGRectMake([UIScreen mainScreen].bounds.size.width / 2 - 25, [UIScreen mainScreen].bounds.size.height /2 - 25, 50, 50); // 自适应到屏幕中部 backView.backgroundColor = [UIColor orangeColor]; backView.tag = 1001; // 准许子视图自适应 backView.autoresizesSubviews = YES; [self.view addSubview: backView]; UIView *topView = [[UIView alloc] init]; topView.frame = CGRectMake(10, 10, 30, 30); topView.backgroundColor = [UIColor greenColor]; // 再设置子视图的适应方式 左侧适应 topView.autoresizingMask = UIViewAutoresizingFlexibleRightMargin | UIViewAutoresizingFlexibleLeftMargin | UIViewAutoresizingFlexibleTopMargin | UIViewAutoresizingFlexibleBottomMargin | UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight; // 右， 左， 上， 下， 宽， 高 跟随父级自适应 [backView addSubview: topView]; // 按钮 下节课会讲到 UIButton *btn = [UIButton buttonWithType: UIButtonTypeSystem]; btn.frame = CGRectMake(10, 550, 355, 30); btn.backgroundColor = [UIColor brownColor]; [btn addTarget:self action:@selector(btnClick) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview: btn];&#125;-(void)btnClick&#123; UIView *view = [self.view viewWithTag:1001]; view.frame = CGRectMake(view.frame.origin.x - 5, view.frame.origin.y -5, view.frame.size.width + 10, view.frame.size.height + 10);&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end UILabel 文本标签 UIColor 颜色类 新建一个项目 ViewController12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 文本标签 UILabel *label = [[UILabel alloc] init]; label.frame = CGRectMake(10, 100, 300, 30); label.backgroundColor = [UIColor yellowColor]; // 文本 label.text = @"我是一个IOS FONT"; // 文字布局 NSTextAlignmentCenter NSTextAlignmentLeft NSTextAlignmentRight 等等 label.textAlignment = NSTextAlignmentCenter; // 文字颜色 // clearColor透明色 // colorWithRed green blue alpha 类似css的rgba label.textColor = [UIColor colorWithRed:.1 green:.8 blue:.2 alpha:1]; // label的透明度 label.alpha = .9; // 字体设置 label.font里面 label.font = [UIFont systemFontOfSize: 25]; // 字号 // 加粗或倾斜 label.font = [UIFont boldSystemFontOfSize:25];// 加粗和25号字，会覆盖前面设置 label.font = [UIFont italicSystemFontOfSize:25]; // 倾斜 // 看系统有哪些字体 for (NSString *name in [UIFont familyNames]) &#123; NSLog(@"font = %@", name); &#125; // 设置字体 label.font = [UIFont fontWithName:@"Bodoni 72 Smallcaps" size:25]; // 文字阴影// label.shadowColor = [UIColor redColor];// label.shadowOffset = CGSizeMake(1, 1); // 多文字处理 会自动出现... label.text = @"topView.autoresizingMask = UIViewAutoresizingFlexibleRightMargin | UIViewAutoresizingFlexibleLeftMargin | UIViewAutoresizingFlexibleTopMargin | UIViewAutoresizingFlexibleBottomMargin | UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight; // 右， 左， 上， 下， 宽， 高 跟随父级自适应[backView addSubview: topView]"; // 如果要换行 // 1. 首先label要足够大 // 2. 设置换行模式 // 3. 设置显示行数 label.frame = CGRectMake(20, 20, [UIScreen mainScreen].bounds.size.width - 40, [UIScreen mainScreen].bounds.size.height - 40); label.lineBreakMode = NSLineBreakByCharWrapping; label.numberOfLines = 2; // 如果设置到-1或0 就不会限制行数，能显示多少行就显示多少行 [self.view addSubview:label]; &#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125; UIImageView 图片view新建一个项目,添加自己喜欢的照片到项目里。 比如我 肯定是添加GAKKI的 ViewController.m12345678910111213141516171819202122232425262728293031323334353637383940- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 首先 随便加载几张图片到项目中 // 获取图片路径 NSString *path = [[NSBundle mainBundle] resourcePath]; // 工程目录 NSString *imgPath = [NSString stringWithFormat: @"%@/2.jpg", path]; // 拼接图片路径 // 后面参数为图片路径 UIImage *image = [[UIImage alloc] initWithContentsOfFile: imgPath]; // 加载完会释放，不会存在内存中，不过每次都会去加载// image = [UIImage alloc] initWithData:&lt;#(nonnull NSData *)#&gt; 2进制格式图片加载// UIImage *image1 = [UIImage imageNamed:@"2"]; // 这种直接写文件名，如果是png格式的，可以省略后缀名 这种方式直接把图片放到内存中，占用内存但是下次调用会很快。 比如qq表情，可以放到缓存（内存）中 // 图片显示必须要有载体 UIImageView *imageView = [[UIImageView alloc] initWithImage: image]; // image.size.width image.size.height imageView.frame = CGRectMake(10, 100, 400, 400); // 内容模式 居中： UIViewContentModeCenter // 默认为UIViewContentModeScaleToFill 拉伸充满整个载体 // UIViewContentModeScaleAspectFit 拉伸但不改变比例，充满小的边框 // UIViewContentModeScaleAspectFill 拉伸但不改变比例，充满大的边框 // 学过css的 应该都很容易理解 background-size模式 imageView.contentMode = UIViewContentModeScaleAspectFit; // UIImageView 动画 - 播放序列图 略! // 图片显示在屏幕上的大小是载体来控制的 [self.view addSubview: imageView]; &#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>Objective-C</tag>
        <tag>ios</tag>
        <tag>imooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Foundation 入门]]></title>
    <url>%2F2017%2F04%2FFoundation-%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Foundation(基础框架) 课程知识比较多，所以后面会每个学习内容新建一个类去写。 新建一个项目， 文章源码,找不到则到finish里面找 String新建一个String类String.h12345#import &lt;Foundation/Foundation.h&gt;@interface String : NSObject-(void) stringBaseFn; // 声明一个函数，后面有关的字符串函数知识都写在该方法内@end main.m123456789101112// 引入并调用该方法，主要是一些字符串的方法 以及输出#import &lt;Foundation/Foundation.h&gt;#import "String.h"int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; String *str = [[String alloc] init]; [str stringBaseFn]; &#125; return 0;&#125; String.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132//// String.m// foundation//// Created by Jsonz on 2017/4/23.// Copyright © 2017年 Jsonz. All rights reserved.//#import "String.h"@implementation String-(void) stringBaseFn&#123; char *s = "Hello C"; // c语言字符串 char 类型 *号代表对象 // OC 中@代表对象 NSString *str = @"Hello ObjectiveC"; // OC 字符串 NSString 类型 *号代表对象 // OC 与 C字符串的类型转换 // C -&gt; OC NSString *str1 = [NSString stringWithUTF8String:s]; NSLog(@"str1 = %@", str1); // OC -&gt; C NSLog(@"str2 = %s", [str UTF8String]); // 这样创建字符串，不需要自己手动去释放内存等 NSString *str3 = @"IOS"; // 这种需要手动释放内存 NSString *str4 = [[NSString alloc] init]; str4 = @"ios"; // **格式化字符串** 重要 int a = 10; NSString *str5 = [NSString stringWithFormat:@"a = %d str3 = %@", a, str3]; NSLog(@"str5 为 %@", str5); // 拼接字符串 NSString *str6 = [str5 stringByAppendingString: [NSString stringWithUTF8String: s]]; NSLog(@"str6 = %@", str6); // 大小写的转换问题 NSString *str7 = @"HELLO JSONZ"; NSString *str8 = [str7 lowercaseString]; NSLog(@"str8 = %@", str8); // 转换大写 NSString *str9 = [str8 uppercaseString]; NSLog(@"str9 = %@", str9); // 前缀和后缀的判断 NSString *str10 = @"www.imooc.com"; // 判断前缀 BOOL hasPreFix = [str10 hasPrefix:@"www."]; if (hasPreFix) NSLog(@"有对应前缀"); else NSLog(@"没有对应前缀"); // 后缀 BOOL hasSuffix = [str10 hasSuffix:@".com"]; if (hasSuffix) NSLog(@"有对应后缀"); else NSLog(@"没有对应后缀"); // 判断字符串是否相同 NSString *str11 = @"Hello"; NSString *str12 = @"Hello"; if ([str11 isEqualToString:str12]) NSLog(@"str11 与 str12 一致"); else NSLog(@"不一致"); // 分割字符串 // 1. 按照指定字符分割字符串 返回数组 NSString *str13 = @"a,b,c,d,e,f,g"; NSArray *strArray = [str13 componentsSeparatedByString:@","]; for (NSString *str in strArray) &#123; NSLog(@"str = %@", str); &#125; // 2. 按照范围截取字符串 NSRange range = NSMakeRange(1, 5); NSString *str14 = [str13 substringWithRange:range]; NSLog(@"str14 = %@", str14); // 3. 从某一位开始截取到结束 NSString *str15 = [str13 substringFromIndex:2]; NSLog(@"str15 = %@", str15); // 4.从开头到某一位 NSString *str16 = [str13 substringToIndex:7]; NSLog(@"str16 = %@", str16); // 5.将字符串拆分为每一个字符, 从字符串取出某一位 for (int i = 0; i &lt; [str13 length]; i++) &#123; NSLog(@"%c", [str13 characterAtIndex:i]); &#125; // 查找 NSString *str17 = @"ab cd ef gh ij ab"; // 查找指定字符串的位置 正向查找 NSRange range1 = [str17 rangeOfString:@"ab"]; NSLog(@"range1.location: %ld range1.length: %ld", range1.location, range1.length); // 替换 NSString *str18 = @"Hello ios, Hello imooc"; // 替换某一个范围的内容 NSString *str19 = [str18 stringByReplacingCharactersInRange:NSMakeRange(0, 5) withString:@"你好"]; NSLog(@"str19 = %@", str19); // 用指定字符串替换原字符串 NSString *str20 = [str18 stringByReplacingOccurrencesOfString:@"Hello ios" withString: @"第一个参数为源字符串中要被替换的内容， 第二个为替换成的字符串"]; NSLog(@"str20 = %@", str20); // 读取文件 // 1. 本地文件； 2.网络文件 // 路径类 NSString *str21 = @"www.baidu.com"; // 网络路径 NSURL *httpURL = [NSURL URLWithString:str21]; //本地路径// NSString *fileURL = [NSURL fileURLWithPath:str21]; // 读取网络文件 NSString *httpStr = [NSString stringWithContentsOfURL:httpURL encoding:NSUTF8StringEncoding error:nil]; NSLog(@"httpStr = %@", httpStr); // 读取本地文件 NSString *fileStr = [NSString stringWithContentsOfFile: @"/Users/jsonz/Documents/learn/Objective-c/foundation/foundation/app.txt" encoding:NSUTF8StringEncoding error: nil]; NSLog(@"fileStr = %@", fileStr); // 写入文件 NSString *str22 = @"Hello JSer"; BOOL isOk = [str22 writeToFile:@"/Users/jsonz/Documents/learn/Objective-c/foundation/foundation/app.js" atomically:YES encoding:NSUTF8StringEncoding error:nil]; if (isOk) NSLog(@"文件写入成功"); else NSLog(@"文件写入失败");&#125;@end NSMutableString 可变字符串新建一个 NSMutableStringClass 类。 NSMutableString是字符串的子类 NSMutableString.h12345678910111213//// NSStringClass.h// foundation//// Created by Jsonz on 2017/4/25.// Copyright © 2017年 Jsonz. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@interface NSMutableStringClass : NSObject-(void) ShowNSMutableString;@end NSMutableString.m123456789101112131415161718192021222324252627282930313233343536373839404142//// NSStringClass.m// foundation//// Created by Jsonz on 2017/4/25.// Copyright © 2017年 Jsonz. All rights reserved.//#import "NSMutableStringClass.h"@implementation NSMutableStringClass-(void) ShowNSMutableString&#123; // 可变字符串的简单方法 // 可变字符串是字符串的子类 // 实例化 NSMutableString *str = [[NSMutableString alloc] initWithCapacity:10]; // 分类长度不可以超过10， 性能优化。不过超过10 也不会报错 [str setString:@"hello "]; // 1.追加字符串 [str appendString:@"ObjectiveC"]; NSLog(@"str = %@", str); // 追加格式化字符串 int a = 10; [str appendFormat:@" - %d", a]; NSLog(@"str = %@", str); // 2.替换字符串 NSRange range = [str rangeOfString:@"ObjectiveC"]; [str replaceCharactersInRange:range withString:@"IOS"]; NSLog(@"str = %@", str); // 3. 插入字符串 [str insertString:@"A" atIndex: 4]; NSLog(@"str = %@", str); // 4. 删除字符串 NSRange range1 = [str rangeOfString:@"IOS"]; [str deleteCharactersInRange:range1]; NSLog(@"str = %@", str);&#125;@end main.m 调用前记得引入类12NSMutableStringClass *_NSMutableString = [[NSMutableStringClass alloc] init];[_NSMutableString ShowNSMutableString]; NSArray 不可变数组新建一个arr类 Arr.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//// Arr.m// foundation//// Created by Jsonz on 2017/4/26.// Copyright © 2017年 Jsonz. All rights reserved.//#import "Arr.h"@implementation Arr-(void) showArrFn&#123; NSLog(@"不可变数组"); // OC数组。 可以存储不同类型对象,只能存储对象.(int, char)不可以 // 只存对象指针（js一样) NSArray *arr1 = [[NSArray alloc] initWithObjects:@"1", @"2", @"3", @"4", @"5", nil]; // 数组长度 int count = (int)arr1.count; NSLog(@"count = %d", count); // 判断是否有该对象 BOOL isHave = [arr1 containsObject: @"2"]; if (isHave) NSLog(@"存在"); else NSLog(@"不存在"); // 取得数组中所需元素 NSString *str = [arr1 lastObject]; NSLog(@"最后一个对象为 %@", str); str = [arr1 firstObject]; NSLog(@"第一个对象为 %@", str); str = [arr1 objectAtIndex: 3]; NSLog(@"第三个元素为 %@", str); // 查找某个对象为第几个下标, 不存在则 -1 int index = (int)[arr1 indexOfObject:@"3"]; NSLog(@"查找某个对象为第几个下标 %d", index); // 数组的遍历 1.for; 2. for in; 3.枚举迭代 // for 循环 注意类型问题 for (int i = 0; i &lt; arr1.count; i++) &#123; NSString *str1 = [arr1 objectAtIndex:i]; NSLog(@"for str1 = %@", str1); &#125; // 快速枚举 数组的元素类型要保持一致 for (NSString *str2 in arr1) &#123; NSLog(@"for in str2 = %@", str2); &#125; // 迭代枚举(慕课没有该点视频) [arr1 enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123; NSLog(@"id= %@", obj); &#125;];&#125;@end NSMutableArr 可变数组与可变字符串一样，数组也有可变的。一般项目中如果有修改数组的就用这个，如果不希望数组被修改则用不可变数组 NSMutableArrClass.m123456789101112131415161718192021222324252627282930313233343536373839404142434445//// NSMutableArrClass.m// foundation//// Created by Jsonz on 2017/4/26.// Copyright © 2017年 Jsonz. All rights reserved.//#import "NSMutableArrClass.h"@implementation NSMutableArrClass-(void)showArrFn&#123; NSMutableArray *array = [[NSMutableArray alloc] init]; NSString *str1 = @"bili"; // 添加元素 [array addObject: str1]; NSArray *arr1 = [[NSArray alloc] initWithObjects:@"1", @"2", @"3", @"4", @"5", nil]; [array addObject:arr1]; NSLog(@"array = %@", array); // 删除所有元素 [array removeAllObjects]; NSLog(@"删除后的 array = %@", array); [array addObject:arr1]; [array addObject: str1]; // 删除最后一个元素 [array removeLastObject]; NSLog(@"删除后的 array = %@", array); [array addObject: str1]; // 删除指定元素 [array removeObject:@"bili"]; NSLog(@"删除后的 array = %@", array); // 删除指定index的元素 [array removeObjectAtIndex:0]; NSLog(@"删除后的 array = %@", array); [array addObject:arr1]; [array addObject: str1]; // 交换元素位置 [array exchangeObjectAtIndex:1 withObjectAtIndex:0]; NSLog(@"交换后 %@", array);&#125;@end 字典 NSDictionary相当于js 里的对象{}. 新建一个类NSDic NSDictionary.h12345678910111213//// NSDictionary.h// foundation//// Created by Jsonz on 2017/4/26.// Copyright © 2017年 Jsonz. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@interface NSDic : NSObject-(void) showNSDictionaryFn;@end NSDictionary.m12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//// NSDictionary.m// foundation//// Created by Jsonz on 2017/4/26.// Copyright © 2017年 Jsonz. All rights reserved.//#import "NSDic.h"@implementation NSDic-(void) showNSDictionaryFn&#123; NSLog(@"test");// 字典： 相当于js的对象~ py的字典。 // 声明后不可以改 NSDictionary *dict1 = [NSDictionary dictionaryWithObject:@"1" forKey:@"a"]; NSLog(@"dict1 = %@", dict1); // 多个键值对 NSDictionary *dict2 = [NSDictionary dictionaryWithObjects:[NSArray arrayWithObjects:@"1", @"2", @"3", nil] forKeys:[NSArray arrayWithObjects:@"a", @"b", @"c", nil]]; NSLog(@"dict2 %@", dict2); // 简便写法 NSDictionary *dict3 = @&#123; @"1": @"a", @"2": @"b" &#125;; NSLog(@"dict3 %@", dict3); // 长度 int count = (int)[dict2 count]; NSLog(@"count %d", count); // 获取对应key的 value NSString *value = [dict2 valueForKey: @"b"]; NSLog(@"value = %@", value); NSString *value2 = [dict2 objectForKey: @"b"]; NSLog(@"value2 = %@", value2); // 数组 字典所有的值 NSArray *allValues = [dict2 allValues]; NSLog(@"allValues = %@", allValues); // 数组 所有的key NSArray *allKeys = [dict2 allKeys]; NSLog(@"allKeys = %@", allKeys); // 遍历 NSArray *array = [dict2 objectsForKeys:[NSArray arrayWithObjects: @"a", @"b", @"d", nil] notFoundMarker:@"Not Fount"]; NSLog(@"array = %@", array); // 遍历字典 for (NSString *key in dict2) &#123; NSLog(@"%@ = %@", key, [dict2 objectForKey:key]); &#125; // 枚举器 NSEnumerator *en = [dict2 keyEnumerator]; id key = nil; while (key = [en nextObject]) &#123; NSLog(@"key = %@", key); &#125; [dict2 enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123; NSLog(@"id = %@, obj = %@", key, obj); &#125;]; &#125;@end 可变字段 NSMutableDictionaryNSDic2.h12345678910111213//// NSDic2.h// foundation//// Created by Jsonz on 2017/4/26.// Copyright © 2017年 Jsonz. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@interface NSDic2 : NSObject-(void) showFn;@end NSDic2.m1234567891011121314151617181920212223242526272829303132333435//// NSDic2.m// foundation//// Created by Jsonz on 2017/4/26.// Copyright © 2017年 Jsonz. All rights reserved.//#import "NSDic2.h"@implementation NSDic2// 可变字典-(void) showFn&#123; NSMutableDictionary *dict = [[NSMutableDictionary alloc] init]; // 添加键值对 [dict setObject:@"1" forKey: @"a"]; [dict setObject: @"2" forKey: @"b"]; // 删除键值对 [dict removeObjectForKey:@"a"]; NSLog(@"dict 删除forKey %@", dict); // 删除所有 [dict removeAllObjects]; NSLog(@"dict 删除所有 %@", dict); [dict setObject:@"1" forKey: @"a"]; [dict setObject: @"2" forKey: @"b"]; [dict setObject: @"3" forKey: @"c"]; [dict removeObjectsForKeys: [NSArray arrayWithObjects:@"a", @"b", nil]]; NSLog(@"dict 批量删除 %@", dict); &#125;@end]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>Objective-C</tag>
        <tag>ios</tag>
        <tag>imooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C 面向对象初体验]]></title>
    <url>%2F2017%2F04%2FObjective-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[面向对象简介语言的面向对象都是换汤不换药 来来去去那几个概念 OOP（Object Oriented Programming) 基本概念 对象 （男人，女人，程序员） 抽象 - 类（人） 类和对象的关系 创建类(人)、得到对象（程序员） 成员变量： 内部使用，比如 大脑 眼睛 嘴 属性： 给外部使用 比如 职业 类的实例为对象 创建demo 同征战Objective-C一样 创建一个Command Line Tool 写示例代码 创建一个文件，类型为Cocoa Class,name: People, Subclass of: NSObject, language: Objective-C 。点击Next之后会生成两个文件 People.h,People.m。 引入与实例化在 main.m 里面引入文件并实例化对象, 后面如果没有特别说明， 都是在 main @autoreleasepool 里面写代码main.m12345678910111213141516171819#import &lt;Foundation/Foundation.h&gt;#import "People.h" // 引入类int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // 实例化对象 // 类名 对象名(星号代表是指针类型) = [[类名/对象名] 方法名] // People p1/p2 = [[People alloc] init] // alloc - 为对象分配内存空间 // init - 进行初始化操作 People *p1 = [[People alloc] init]; People *p2 = [[People alloc] init]; People *p3 = [People new]; // new 在Objective-C 用得少 NSLog(@"p1 - %p", p1); NSLog(@"p2 - %p", p2); NSLog(@"p3 - %p", p3); &#125; return 0;&#125; 创建成员变量与属性People.h12345678910// 姓名，年龄，性别// 类内使用成员变量(m)， 类外使用属性(h)@interface People : NSObject&#123;&#125;// 声明类的属性 声明后 main.m 就可以通过 p1.peopleName = @"Jsonz"; 访问修改属性// 属性就是成员变量的外部接口 h 文件写。外部使用//设置与获取Name@property(nonatomic, strong)NSString *peopleName;@end People.m1234567891011121314151617#import "People.h"// 成员变量 m 文件定义 内部使用@implementation People&#123; int _peopleAge; int _peopleSex;&#125;- (instancetype) init&#123; self = [super init]; if (self) &#123; _peopleName = @"张三"; // 成员变量 类内使用 &#125; return self;&#125;@end 此时main.m 可以使用peopleName属性 main.m12345// 属性的使用p1.peopleName = @"jsonz";p2.peopleName = @"李四";NSLog(@"p1.peopleName - %@", p1.peopleName);NSLog(@"p2.peopleName - %@", p2.peopleName); 函数加号方法 减号方法 的声明与调用在People.h 声明方法People.h123456789/** * - 、+ (减号代表对象方法，加号代表类方法) * 对象方法既是在实例上调用，而类方法则是在类上面调用，如: People *p1 = [[People alloc] init] * 此时 People是类， p1是对象 * h 文件进行声明， m 进行实现 */-(void) report; // 减号方法+(void) report1; // void 代表不用返回， +号方法-(int) returnInt; // 改变返回值的函数 在People.m实现该方法People.m1234567891011121314151617181920- (void) report&#123; NSLog(@"减号 Report"); // 如何在减号方法调加号方法 // [People report1]; &#125;static NSString *_peopleName1; // 静态变量，供加号方法内调用+(void) report1&#123; NSLog(@"加号 Report"); _peopleName1 = @"张三"; // 调用静态变量 不能调用成员变量 // 如何在加号方法调减号方法 // [[People alloc] report]&#125;-(int) returnInt&#123; // 前面是int，所以该函数必须返回一个int类型 return 0;&#125; 调用main.m123456People *p1 = [[People alloc] init][p1 report]; // 减号方法[People report1]; // 加号方法// [[People alloc] init]// [People alloc]会返回一个对象，这时候才能调用 init 所以 alloc是加号方法， init是减号方法 函数参数类型People.h 声明123// 函数参数问题-(int)showWithA: (int) a; // 有一个int类型参数 函数名为 `showWithA:`-(int)showWithA: (int)a andB:(int)b; // 有两个int类型参数 函数名为 `showWithA: andB:` People.m 实现123456789//参数问题-(int)showWithA:(int)a&#123; return a;&#125;-(int)showWithA:(int)a andB:(int)b&#123; return a + b;&#125; main.m 调用12345// 函数的参数使用int a1 = [p1 showWithA:10];int a2 = [p1 showWithA:20 andB:30];NSLog(@"a1 = %d", a1);NSLog(@"a2 = %d", a2); 初始化方法平时调用一个类的对象方法都是这么调用的 People *p1 = [[People alloc] init]， 但此时这个init具体做了什么事情，我们并不知道。 我们可以在类里面重写掉这个init 方法; People.h1234// 对于初始化方法来说 id || instancetype 没有区别，对于其他方法，一般 instancetype 比 id用的多// -(id)init; // 万能类型，可以返回各种类型对象-(instancetype)init; // 当前类的类型，比如当前类是People类型，那么instancetype就是People类型-(void) showPeopleProperty; // 定义一个方法来输出类的属性 People.m 重写init123456789101112131415161718192021// 如果此时提示 Duplicate declaration of method ‘init' 则代表你上面本来就声明了一个init 此时删除该init 或者把逻辑移到那个函数内即可// init 固有的模式- (instancetype) init&#123; self = [super init]; // 自己继承父级的 init 此处是 NSObject // 内部进行一些初始化的设定 if (self) &#123; _peopleName = @"Jsonz"; // 成员变量 类内使用 _peopleAge = 30; _peopleSex = 1; &#125; return self; // 返回自身&#125;// 输出People的对象初始化值-(void) showPeopleProperty&#123; NSLog(@"peopleName = %@", _peopleName); NSLog(@"peopleAge = %d", _peopleAge); NSLog(@"peopleAge = %d", _peopleSex);&#125; 接下来我们来自定义一个初始化的方法People.h1-(instancetype)initWithPeopleName:(NSString *) peopleName andPeopleAge:(int)peopleAge People.m123456789101112// 既然我们是自定义一个初始化方法，那也要按照初始化方法的写法，把一些结构给加上-(instancetupe)initWithPeopleName:(NSString *)peopleName andPeopleAge:(int)peopleAge&#123; // 初始化方法的结构 self = [super init]; if (self) &#123; _peopleName = peopleName; _peopleAge = peopleAge; &#125; return self;&#125; main.m1234// 自己实现的初始化方法People *pSelf = [[People alloc] initWithPeopleName:@"Jsonz" andPeopleAge: 23];NSLog(@"自己实现的init 的属性有哪些: ---- ");[pSelf showPeopleProperty]; 面向对象三部曲新建一个项目，避免学习太混乱 封装新建一个类，叫MyClassMyClass.h1234567891011121314151617181920#import &lt;Foundation/Foundation.h&gt;@interface MyClass : NSObject&#123; // 成员变量访问修饰符的问题 // 默认为 protected 受保护的 @public // 公有 - 在类内 类外都可以使用，并且可以被继承 int _classInt; @private // 私有 - 在类内可以使用， 类外无法调用 并且无法被继承 @protected // 受保护 - 默认的 在类内可以使用，类外无法调用 并且可以被继承 NSString *_classStr; @package // 框架权限 - 在框架内相当于受保护(可被调用与继承)， 在框架外相当于私有(类外无法使用与继承)&#125;@property(nonatomic, strong)NSString *className;// 方法是没有访问修饰符的， 同C语言一样。// 如果想要一个方法可以在类外可以使用，则要在h声明，m实现。// 如果不想在类外使用， 直接在m写实现， h 不写声明。-(void) report;@end MyClass.m12345678910#import "MyClass.h"@implementation MyClass-(void)report&#123; _classStr = @"ClassStr bilibilii"; NSLog(@"ClassName - %@", _className); NSLog(@"classInt - %d", _classInt);&#125;@end main.m12345678910111213141516#import &lt;Foundation/Foundation.h&gt;#import "MyClass.h"int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; MyClass *mc = [[MyClass alloc] init]; mc.className = @"我的类"; // 类外使用 public 成员变量 mc-&gt;_classInt = 1001; // 使用指向来调用类中的公有成员变量 [mc report]; &#125; return 0;&#125; 继承创建两个类 父类 ParentClass 子类 ChildClass, 创建的时候记得选上继承 ParentClass， 如果忘了选也没关系 后面手动修改一下就可以 ParentClass.h12345678910111213141516#import &lt;Foundation/Foundation.h&gt;// NSObject - 基类 此处的:(冒号)是代表继承关系@interface ParentClass : NSObject&#123; // 受保护变量 可继承 不可外部调用 int _classInt; // 私有变量 @private NSString *_classStr; &#125;@property(nonatomic, strong)NSString *className;-(void)report; // 如果此处不声明，则类外不能调。 子类也不继承@end ParentClass.m123456789101112#import "ParentClass.h"@implementation ParentClass-(void)report&#123; _classInt = 1002; _classStr = @"Jsonz's 私有变量"; NSLog(@"ClassName - %@", _className); NSLog(@"classInt - %d", _classInt); NSLog(@"classStr - %@", _classStr); // 此处在 ChildClass 中也会被打印出来，因为继承了该方法，所以会被打印&#125;@end ChildClass.h12345#import "ParentClass.h"@interface ChildClass : ParentClass-(void)show;@end ChildClass.m12345678910#import "ChildClass.h"@implementation ChildClass-(void)show&#123; _classInt = 1003; NSLog(@"show 此处_classInt 变化了 - %d", _classInt);// NSLog(@"show 打印父类的私有方法NSString %@", _classStr); 此处因为是父级的私有变量，所以外部无法访问&#125;@end main.m1234567891011// 调用// 父类ParentClass *pc = [[ParentClass alloc] init];pc.className = @"parentClass ClassName";[pc report];// 子类ChildClass *cc = [[ChildClass alloc] init];cc.className = @"ChildClass ClassName"; // 此处为父类继承过来的属性[cc show];[cc report]; // 此处还是1002 因为 cc中的 report 继承 pc 的report，此处重新复制了并打印。所以是1002 多态 方法重写 基于父类方法继承重写，返回值，函数名，参数等都一致 方法重载 (OC 不支持) 函数名一致，返回值 参数 参数类型等都不一致 创建一个类ColorPrint 用于演示多态，后面会基于 ParentClass, ChildClass 与ColorPrint 来说明多态。 父类实现一个打印机方法ParentClass.h1-(void) print; ParentClass.m1234-(void) print&#123; NSLog(@"普通打印机");&#125; 子类重写不需要声明，直接在m文件去重写实现即可ChildClass.m1234-(void)print&#123; NSLog(@"我是黑白打印机");&#125; ColorPrinter.m12345678-(void)print&#123; // 如果此处要调用父类的方法可以这么写： [super print]; // 调用当前类的方法可以用 self 父类可以用 super // [self print]; NSLog(@"我是彩色打印机");&#125; main.m12345678910// 调用ChildClass *cc = [[ChilClass alloc] init];[cc print]; // 黑白ColorPrinter *cc2 = [[ColorPrinter alloc] init];[cc2 print]; // 彩色打印机// 如果已经引入了子类的头文件，默认父类h文件（子类头文件所引入的头文件）也会被引入了。// 可以这么写ParentClass *color = [[ColorPrinter alloc] init];[color print]; // 此处也是才是打印机 demo]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>imooc</tag>
        <tag>learn - ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[征战Objective-C]]></title>
    <url>%2F2017%2F04%2F%E5%BE%81%E6%88%98Objective-C%2F</url>
    <content type="text"><![CDATA[Objective-C 下面简称OC 源代码文件扩展名对比一般来说，头文件是放声明， 实现文件放实现的代码 头文件 实现文件 c语言 .h .c c++语言 .h .cpp oc语言 .h .m oc&amp;c++ .h .mm 面向对象概览类的定义123// 当前的SimpleClass 继承 NSObject 类@interface SimpleClass: NSObject@end 类的属性申明12345678910111213141516@interface Person:NSObject@property NSString*firstName;@property NSString*lastName;@property NSNumber *yearOfBirth;@property int yearOfBirth;@property (readonly) NSString *firstName;@end 减号方法（普通方法又称对象方法）声明12345@interface Person: NSObject- (void) someMethod;- (void) someMethodWithValue: (SomeType)value;- (void) someMethodWithFirstValue: (SomeType)info1 secondValue: (AnotherType)info2;@end 加号方法 (类方法， 又称静态方法) 声明123456789@interface NSString: NSObject+(id)string;+(id)stringWithString:(NSString *)aString;+(id)stringWithFormat:(NSString *)format, ..;+(id)stringWithContentsOfFile: (NSString *)pathencoding: (NSStringEncoding)enc error:(NSError **)error;+(id)stringWithCString: (const char *)cStringencoding: (NSStringEncoding)enc;@end 类的实现123#import 'XYZPerson.h'@implementation XYZPerson@end 完成的例子XYZPerson.h 文件123@interface XYZPerson: NSObject-(void)sayHello;@end XYZPerson.m 文件1234567#import "XYZPerson.h"@implementation XYZPerson-(void)sayHello &#123; NSLog(@"Hello, World!");&#125;@end Hello World首先去app store 下载xCode. 打开xCode 选择左侧 Create a new Xcode project=&gt;macOS=&gt; Command Line Tool ，选择保存项目的位置。 进入项目后点击左上角箭头运行，如果下面控制台有输出 hello world 则代表运行成功了。 1234567#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // 真正开始写代码的地方 &#125; return 0;&#125; ObjectiveC 变量与表达式声明变量与简单运算12345int a = 0;int b = 1;b = 3;int c = a + b;NSLog(@"变量a+ b的值等于: %d", c); // %d 格式化输出，后面加个逗号再加变量 基础类型123456int int a = 0; 整数 占32位2进制float float a = 1.0; 浮点数 占32位2进制double double num; 双精度 占64位 可以保存更大的数char char c = 'A'; 单字符串 单引号NSString: @"Hello world" 使用比较多 双引号 (高级类型)C语言字符串类型 "hello world" 使用比较少 限定词12345long: long int a; 比int 更大的整形long long: long long int a; 比 long int 更大 具体应用才会涉及 比如大数据等short: short int a; short a; 小于或等于整形， 16位 比较省类型，但是比较少用这些，一般直接用 intunsigned: unsigned int a; 无符号signed: signed int a; 有符号(正负类型) 运算12345678910int a = 1;a++;++a;a--;--a;一元 ++, --,二元 +, -, *, /, %三元 2&gt;3?Yes:Not逻辑符号 &lt;, &gt;, &gt;=, &lt;=, ==, != if12345678// 如果是真的会返回 1，如果未假返回 0;if (True) &#123; // is True&#125; else &#123; // do something&#125;// 只要非0就是真的。if (1) NSLog(@"对"); else NSLog(@"错"); // 单行可以不写括号 goto语法1234567 int i = 0;a: &#123; i++; NSLog(@"i的值为 %d", i); // 先输出一个 i = 0;&#125; if (i &lt; 5) goto a; // 执行到这里i &lt; 5 跳转到a 去执行。 直到 i == 5 // 最后输出 0, 1, 2, 3, 4 while 循环 比较常用12345int a = 0;while ( a &lt; 5) &#123; a++; NSLog(@"a的变量是 %d", a);&#125; for循环 比较常用123for (int i= 0; i &lt; 10; i++) &#123; NSLog(@"i=%d", i);&#125; do while 肯定会执行一次再判断是否循环123do &#123; NSLog(@"hehe");&#125; while (0); break continue12break 可以在 循环中 退出循环continue 可以在 循环中 跳出当前循环，继续下一项循环 switch12345678910111213141516int i = 10.0; // char int float switch (i) &#123; case 1: NSLog(@"i = 1"); break; case 2: NSLog(@"i = 2"); break; case 10: NSLog(@"i = 10"); break; default: NSLog(@"i = 10.0"); &#125; // 最后会输出一个 10。 函数123456789101112131415161718192021// 求矩形面积的函数 s = a * b;// 返回的类型 函数名 ([(参数类型， 参数名)， (参数类型， 参数名)])double qiumianji(double a, double b) &#123; double s = a * b; return s;&#125;// 调用 main 函数内。// 一个相同类型的变量来接收返回值double s = qiumianji(10.0, 5.0);NSLog(@"s 的值为 %f", s); // %d 输出整数， %f 输出浮点数// 如果没有返回值，则调用函数的时候不用一个变量去接收void show() &#123; NSLog(@"this is a test !"); NSLog(@"this is a test2 !"); NSLog(@"this is a test3 !");&#125;// main 函数内调用show(); main函数中的默认参数12345NSLog(@"argc=%d", argc);// argv 参数为 命令行输入命令运行的参数如： les1 -h -c -a -l 则有5个参数[les1, -h, -c, -a, -l]for (int i =0; i &lt; argc; i++) &#123; NSLog(@"%s", argv[i]);&#125; 输出目前遇到的总结1234567NSLog(@"type %d", a); - %d int; - %s char *; - %f float;- %p 指针类型- %@ NSString- %ld 目前遇到过的有 NSRange.length || NSRange.location]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>Objective-C</tag>
        <tag>ios</tag>
        <tag>imooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单事件系统]]></title>
    <url>%2F2017%2F04%2F%E7%AE%80%E5%8D%95%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[最简单的事件系统 应该包含四个接口 on, off, once, trigger。 初始化方法1234567function E() &#123;&#125;E.prototype = &#123; on: function()&#123;&#125;, off: ..., trigger: ..., once: ...,&#125; on 事件绑定12345678on: function(name, cb, ctx) &#123; var e = this.e || (this.e = &#123;&#125;); (e[name] || (e[name] = [])).push(&#123; fn: cb, ctx: ctx &#125;); return this;&#125;, off 事件解绑1234567891011121314off: function(name, cb, ctx) &#123; var e = this.e || (this.e = &#123;&#125;); var evts = e[name]; var liveEvents = []; if (evts &amp;&amp; cb) &#123; for (var i= 0, len= evts.length; i&lt; len; i++) &#123; if (evts[i].fn !== cb &amp;&amp; evts[i].fn._ !== cb) liveEvents.push(evts[i]); &#125; &#125; (liveEvents.length) ? e[name] = liveEvents : delete e[name]; return this;&#125; once 绑定单次123456789once: function(name, cb, ctx) &#123; var self = this; function listener() &#123; self.off(name, listener); cb.apply(ctx, arguments); &#125; listener._ = cb; return this.on(name, listener, ctx);&#125; trigger 事件触发12345678910trigger: function(name) &#123; var data = [].slice.call(arguments, 1); var evtArr = ((this.e || (this.e = &#123;&#125;))[name] || []).slice(); var i = 0; var len = evtArr.length; for (i; i&lt; len; i++) &#123; evtArr[i].fn.apply(evtArr[i].ctx, data); &#125; return this;&#125; 简单的调用12345678910111213141516171819&lt;script src="./e.js"&gt;&lt;/script&gt;&lt;script&gt;var e = new E();e.on('bilibili', function() &#123; console.log('on');&#125;).once('once', function() &#123; console.log('once')&#125;).on('off', function() &#123; console.log('off')&#125;);window.addEventListener('load', function() &#123; document.body.addEventListener('click', function() &#123; e.trigger('off') .off('off') .trigger('bilibili') .trigger('once'); &#125;);&#125;)&lt;/script&gt; 最后附上源码]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>github</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复制黏贴板插件-CopyText]]></title>
    <url>%2F2017%2F04%2F%E5%A4%8D%E5%88%B6%E9%BB%8F%E8%B4%B4%E6%9D%BF%E6%8F%92%E4%BB%B6-CopyText%2F</url>
    <content type="text"><![CDATA[最近公司有个需求是要在移动端实现操作黏贴板功能，简单来说就是点击一个一个评论弹出菜单，其中有一个就是复制的选项。其中安卓和ios中的app还好，有原生提供接口，web端就要自己去实现了。 公司原本有一个copy的插件，但是亲测没效，找到github上面一些copy的插件用的start最高的是clipboard 截止此文有16k个start。 官方说明是 Modern copy to clipboard. No Flash. Just 3kb gzipped. 只有3k!而且官方插件提供的接口不是我想要的那种，遂有了造个自己用的小轮子念头。 简单思路创建一个虚拟的textarea 设置好样式让其显示在用户看不到的界面1234567891011121314151617181920212223selectFake() &#123; const isRTL = document.documentElement.getAttribute('dir'); this.removeFake(); this.fakeHandlerCallback = ()=&gt; this.removeFake(); this.fakeHandler = document.addEventListener('click', this.fakeHandlerCallback) || true; this.fakeEl = document.createElement('textarea'); let yPosition = window.pageYOffset || document.documentElement.scrollTo; styleFn(this.fakeEl, &#123; fontSize: '12pt', border: '0', margin: '0', padding: '0', position: 'absolute', [isRTL? 'right': 'left']: '-9999px', top: `$&#123;yPosition&#125;px`, &#125;); this.fakeEl.setAttribute('readonly', ''); this.fakeEl.value = this.text; document.body.appendChild(this.fakeEl); this.selectedText = this.selectDom(this.fakeEl); this.copyText(); &#125; 选择该dom，既选中textarea的文字区域1234567selectDom(el) &#123; let selectedText; el.select(); el.setSelectionRange(0, el.value.length); el.removeAttribute('readonly'); return el.value;&#125; 执行copy事件123456789copyText() &#123; let succeeded; try &#123; succeeded = document.execCommand('copy'); &#125; catch(e) &#123; succeeded = fale; &#125; this.handleResult(succeeded); // 事件回调处理&#125; 源码加注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/** * Created by Jsonz@github.com/jsonz1993 on 17/04/16 * CopyText 将文本copy到剪切板 支持pc &amp;&amp; web。 有兼容问题 H5 建议用原生copy接口 * @param &#123;Object&#125; options 配置参数 * @property &#123;String&#125; text 要复制的文本 * @property &#123;Function&#125; success 成功回调 * @property &#123;Function&#125; error 失败回调 * * CopyText.isSupported 判断当前环境是否支持copy事件 */export default class CopyText &#123; constructor(options) &#123; this.resolveOptions(options); this.init(); &#125; // 配置参数 resolveOptions(options= &#123;&#125;) &#123; this.text = options.text; this.successCb = typeof options.success === 'function'? options.success: ()=&gt; &#123;&#125;; this.errorCb = typeof options.error === 'function'? options.error: ()=&gt; &#123;&#125;; &#125; // 初始化函数 init() &#123; if (CopyText.isSupported()) this.selectFake(); else this.handleResult(false); &#125; // 创建虚拟dom &amp;&amp; copy selectFake() &#123; const isRTL = document.documentElement.getAttribute('dir'); this.removeFake(); this.fakeHandlerCallback = ()=&gt; this.removeFake(); this.fakeHandler = document.addEventListener('click', this.fakeHandlerCallback) || true; this.fakeEl = document.createElement('textarea'); let yPosition = window.pageYOffset || document.documentElement.scrollTo; styleFn(this.fakeEl, &#123; fontSize: '12pt', border: '0', margin: '0', padding: '0', position: 'absolute', [isRTL? 'right': 'left']: '-9999px', top: `$&#123;yPosition&#125;px`, &#125;); this.fakeEl.setAttribute('readonly', ''); this.fakeEl.value = this.text; document.body.appendChild(this.fakeEl); this.selectedText = this.selectDom(this.fakeEl); this.copyText(); &#125; // 移除虚拟dom removeFake() &#123; if (this.fakeHandler) &#123; document.body.removeEventListener('click', this.fakeHandlerCallback); this.fakeHandler = null; this.fakeHandlerCallback = null; &#125; if (this.fakeEl) &#123; document.body.removeChild(this.fakeEl); this.fakeEl = null; &#125; &#125; // 选择dom selectDom(el) &#123; let selectedText; el.select(); el.setSelectionRange(0, el.value.length); el.removeAttribute('readonly'); return el.value; &#125; // copy copyText() &#123; let succeeded; try &#123; succeeded = document.execCommand('copy'); &#125; catch(e) &#123; succeeded = fale; &#125; this.handleResult(succeeded); // 事件回调处理 &#125; // 回调 handleResult(succeeded) &#123; succeeded? this.successCb(): this.errorCb(); &#125; // 判断是否支持该事件 static isSupported(action= 'copy') &#123; return !!document.queryCommandSupported &amp;&amp; !!document.queryCommandSupported(action); &#125;&#125;const styleFn = (el, opts)=&gt; &#123; if (typeof opts !== 'object' || !el.nodeType) return; for (let key in opts) &#123; el.style[key] = opts[key]; &#125; return el;&#125; 使用方法12345678import CopyText from './CopyText';new CopyText(&#123; text: '文本复制', success() &#123;&#125;, error() &#123;&#125;&#125;);// 可以自行判断环境是否支持copy事件CopyText.isSupported() // Boolean]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime text 3 配置]]></title>
    <url>%2F2017%2F04%2Fsublime-text-3-%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[这篇博客主要讲怎么配置自己的sublime text， 安装可以去官网下载自行安装。 Package Control之后我们要安装Package Control, 既sublime的包管理工具 后面我们的包下载安装都用他。 按快捷键ctrl + ` 调出或者菜单view&gt; show Control 调出control 复制下面代码到control sublime Text 31import urllib.request,os,hashlib; h = &apos;2915d1851351e5ee549c20394736b442&apos; + &apos;8bc59f460fa1548d1514676163dafc88&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) sublime Text 21import urllib2,os,hashlib; h = &apos;df21e130d211cfc94d9b0905775a7c0f&apos; + &apos;1e3d39e33b79698005270310898eea76&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &apos;wb&apos; ).write(by) if dh == h else None; print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h) if dh != h else &apos;Please restart Sublime Text to finish installation&apos;) 复制完敲回车就可以安装，稍等片刻出现即可，安装完成后在 Preferences菜单下会出现 Package Control 选项 详细安装可看Package Control 插件打开 Package Control或按快捷键cmd/ctrl + shift + p， 输入 install package 选中第一个选项既进入安装插件的列表。 这时候可能需要等一会加载远程仓库，具体在左下角会有一个loading标识， 加载完在弹窗输入要安装的插件即可。 所有的插件都可以在https://packagecontrol.io/ 找到，下面列出比较常用的几个插件 Themesublime 编辑器虽然轻巧强大，但是默认的主题实在有点看不下去。主题可以在https://packagecontrol.io/browse/labels/theme 找自己喜欢的。目前个人使用的是 Material Theme 。 直接在install package 弹窗输入 Material Theme 选第一个即可（后面安装方法类似）。 安装完成后会弹出一个README，根据提示修改一下配置。打开Preferences &gt; settings &gt; User添加以下配置，保存即可生效12&quot;color_scheme&quot;: &quot;Packages/Material Theme/schemes/Material-Theme.tmTheme&quot;,&quot;theme&quot;: &quot;Material-Theme.sublime-theme&quot;, Material Theme 个人比较喜欢的主题还有 ayu Agila Theme Emmet前端工程师使用sublime编辑的必备插件，可以极大提高开发效率。最简单的应用就是在空白的.html页面输入!再按 tab键会自动生成html5基本页面解构。还有基本如 #div1&gt;span.child{这是子级}*2+button.name[disabled]{按钮}快捷语法等具体看emmet, Emmet-package SideBarEnhancementssublime 自带的侧边栏文件（夹）功能特别少，这个插件可以为其添加很多其他功能。docs BracketHighlighter前后标签高亮的插件，如[], (), {}, &quot;&quot;, &#39;&#39;, &lt;tag&gt;&lt;/tag&gt;等，可以比较方便看清代码块的起始点。docs AutoFileName按照路径提示该路径目录下的文件名，对于引入文件资源等很有帮助 All AutoComplete让代码自动完成的匹配从所有打开的文件里去匹配，而不是只在当前文件里匹配。 HTML-CSS-JS Prettifyhtml, css, js &amp;&amp; Json 的格式化插件。需要本地安装了node。默认格式化快捷键为ctrl+shift+h END基本上比较通用的插件就这些，可以发现这些插件基本上都在package Control前十位。学会举一反三，工作中用到的另一些插件再上https://packagecontrol.io/ 搜索关键字安装如 git, less, vuejs等等。 最后附上自己的配置12345678910111213141516&#123; "color_scheme": "Packages/Material Theme/schemes/Material-Theme-Lighter.tmTheme", "ignored_packages": [ "Vintage" ], "always_show_minimap_viewport": true, "theme": "Material-Theme-Lighter.sublime-theme", "word_wrap":true, "wrap_width": 120, "font_size": 10, "line_padding_bottom": 2, "line_padding_top": 2, "highlight_line":true, "font_face": "Monaco"&#125;]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>editor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome插件开发]]></title>
    <url>%2F2017%2F04%2Fchrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[先放上入门的英语文档https://developer.chrome.com/extensions/getstarted 后面的教程是参照文档学习的。 新建配置文件首先创建一个manifest.json 用于整个项目的配置文件， 类似平时 js 的 package.json。 包含了项目的版本号， 项目名（扩展插件名）， 描述等。 12345678910111213141516171819202122232425262728293031&#123; "manifest_version": 2, "name": "Getting started example", "description": "This extension shows a Google Image search result for the current page", "version": "1.0", "browser_action": &#123; "default_icon": "icon.png", "default_popup": "popup.html" &#125;, "permissions": [ "activeTab", "https://ajax.googleapis.com/" ]&#125;&#123; "manifest_version": 2, // 版本号 "name": "Getting started example", // 项目名 "description": "This extension shows a Google Image search result for the current page", // 描述 "version": "1.0", // 项目版本号 "browser_action": &#123; "default_icon": "icon.png", // 默认icon "default_popup": "popup.html" // 默认弹窗 &#125;, "permissions": [ "activeTab", // "https://ajax.googleapis.com/" ]&#125; 资源文件在配置文件中我们定义了一个 default_icon 和 default_popup， 现在让我们来创建他们。 default_icondefault_icon 指向的是用于显示在工具栏的图标 可以选自己喜欢的图片，不过要选取 19px 的 .png文件。 可以用google提供的例子 icon.png popup.htmlpopup.html用于用户点击时弹出的一个操作框。为html 文件 所以你可以自己捣鼓自己想显示的东西。 可以用google提供的例子 popup.html 主要的逻辑以外部js的格式独立写在一个js文件里。 popup.js 现在你的文件夹里应该有四个文件: icon.png popup.html popup.js manifest.json 这些完成之后，我们接下来就在chrome加载我们的插件 加载插件调试chrome 访问 chrome://extensions 或手动从菜单进入 扩展程序 打开右上角的开发者模式 如果电脑没有装chrome….趁早装一个 点击加载已压缩的扩展程序，即可看到自己编写的第一个Hello Chrome 扩展插件此时双击审查代码可以调试写的插件。 附上后续学习链接https://developer.chrome.com/extensions]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[animate-text]]></title>
    <url>%2F2017%2F04%2Fanimate-text%2F</url>
    <content type="text"><![CDATA[animate-text文字动画和数字动画 animate text查看DEMO git仓库 轻巧的文字动画库, 使用简单, 文件大小4k可以给文字添加出现动画, 支持字符串打字效果和数字变化效果, 支持监听动画结束事件 项原项目地址, 这里对其代码改造优化。 使用方法12345678910111213141516import AnimateText from './animate-text'// 最简单的使用方法new AnimateText('.text')// 如果需要定义动画时间可以这样初始化new AnimateText('.text', 1000)// 如果还有其它设置 请这样写new AnimateText('.text', &#123; time: 1000, // 动画时长 isNumber: true, // 是否渲染为数字动画 startNumber: 0, // 渲染为数字动画时 动画的开始数字 changeCount: 32, // 数字动画数字变化次数 onAnimated: function () &#123;console.log('动画结束')&#125; // 动画结束事件回调&#125;) 参数说明AnimateText接收两个参数, 例如: new AnimateText(element, options) 参数 类型 是否必填 描述 element String or Object 是 可以是选择器或者dom节点对象(请保证这个节点内只有文本而没有其它节点) options Number or Object 否 如果第二个参数是数字, 则当作动画时间处理, 如果有其他参数, 以对象格式传递, 具体每个属性的描述请看下方的 options说明 options说明第二个参数options详细说明 参数 类型 默认值 是否必填 描述 time Number 500 否 动画持续的时间 isNumber Boolean false 否 是否渲染为数字动画 startNumber Number 0 否 数字动画的开始数字 changeCount Number 32 否 数字动画变化次数 也就是数字经过多少次跳动才变为最终数字 onAnimated Function null 否 动画结束监听函数 实例对象方法说明1234567// 实例化var animateText = new AnimateText('.text')// 实例化对象后 对象提供play方法重新播放动画// 接受参数作为动画时间// 不传递参数则使用实例化的时间animateText.play(1000)]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>learn</tag>
        <tag>github</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-第三方服务集成]]></title>
    <url>%2F2017%2F04%2F%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[静态站点拥有一定的局限性，因此我们需要借助于第三方服务来扩展站点的功能。 以下是 NexT 目前支持的第三方服务，你可以根据你的需求集成一些功能进来。 评论系统NexT 支持多款评论系统。如需取消某个 页面/文章 的评论，在 md 文件的 front-matter 中增加 comments: false 暂没开评论，多说准备下架。 站内搜索本站用 Hexo 提供的 Local Search， 原理是通过hexo-generator-search插件在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。 安装安装 hexo-generator-search1$ npm install hexo-generator-search 安装 hexo-generator-searchdb1$ npm install hexo-generator-searchdb --save 修改站点配置编辑 站点配置 根目录下的_config.yml.12345search: path: search.xml field: post format: html limit: 10000 站内搜索原文教程-EZLippi-浮生志]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next-主题设置]]></title>
    <url>%2F2017%2F04%2Fnext-%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[下面的主题配置指的是 themes&gt;Next&gt;_config.yml, 站点配置指的是根目录下的_config.yml; 添加[标签]页面新建「标签」页面，并在菜单中显示「标签」链接。「标签」页面将展示站点的所有标签，若你的所有文章都未包含标签，此页面将是空的。 底下代码是一篇包含标签的文章的例子： 12345title: 标签测试文章tags: - Testing - Another Tag--- 新建tags页面使用hexo new page tags 新建一个页面，命名为tags:12$ cd you-hexo-site$ hexo new page tags 设置新建的tags页面类型，改为tags123456---title: tagsdate: 2017-04-03 11:35:36type: "tags"comments: false # tags页面自定义是否要开启评论（前提你已经集成了评论）--- 修改主题配置文件，把tag添加到menu中1234menu: home: / archives: /archives tags: /tags 添加[分类]页面新建「分类」页面，并在菜单中显示「分类」链接。「分类」页面将展示站点的所有分类，若你的所有文章都未包含分类，此页面将是空的。 底下代码是一篇包含分类的文章的例子： 123title: 分类测试文章categories: Testing--- 分类和标签的区别详见Hexo的分类与标签文档 新建页面在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 categories ：1234567891011$ cd your-hexo-site$ hexo new page categories``` #### 设置页面类型编辑刚新建的页面，将页面的 `type` 设置为 `categories` ，主题将自动为这个页面显示分类。页面内容如下：```ymltitle: 分类date: 2014-12-22 12:39:04type: "categories"--- 修改菜单在菜单中添加链接。编辑 主题配置文件 ， 添加 categories 到 menu 中，如下:1234menu: home: / archives: /archives categories: /categories 设置字体Next提供了5个特定范围的字体设定 全局字体：定义的字体将在全站范围使用 标题字体：文章内标题的字体（h1, h2, h3, h4, h5, h6） 文章字体：文章所使用的字体 Logo字体：Logo 所使用的字体 代码字体： 代码块所使用的字体 该配置中的 external 可以用来控制是否使用外链字体库。 开放此属性方便你设定那些已经安装在系统中的字体，减少不必要的请求（请求大小）。 设置代码高亮主题NexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是 白色的 normal 主题，可选的值有 normal，night， night blue， night bright， night eighties：可以自行更改 highlight_theme 字段， 设置成你自己喜欢的高亮主题。 侧边栏社交链接侧栏社交链接的修改包含两个部分，第一是链接，第二是链接图标。 两者配置均在 主题配置文件 中。 设置链接在 主题配置 中找到 social字段， 其格式为 显示文本: 链接地址。 scoial123social: Github: https://github.com/jsonz1993 微博: http://weibo.com/u/1638841204 设置图标在 主题配置 中找到 social_icons字段， 其格式为 匹配键: Font Awesome 图标名称。enable 为是否显示图标控制。 注意此时的匹配建要与 social的键一致,图标依旧是Font Awesome图标 站点建立时间这个时间将在站点的底部显示，例如 © 2013 - 2015。 编辑 主题配置文件，新增字段 since。 1since: 2013 设置「动画效果」NexT 默认开启动画效果，效果使用 JavaScript 编写，因此需要等待 JavaScript 脚本完全加载完毕后才会显示内容。 如果您比较在乎速度，可以将设置此字段的值为 false 来关闭动画。编辑 主题配置文件， 搜索 use_motion，根据您的需求设置值为 true 或者 false 即可：1use_motion: true # 开启动画 设置「背景动画」NexT 自带两种背景动画效果 编辑 主题配置文件， 搜索 canvas_nest 或 three_waves，根据您的需求设置值为 true 或者 false 即可：只能同时开启一种背景效果， 建议酌情开启，会影响电脑网页性能(macbook pro或笔记本容易出现过热现象).12canvas_nest: false //关闭动画three_waves: true //开启动画]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello next]]></title>
    <url>%2F2017%2F04%2Fhellp-next%2F</url>
    <content type="text"><![CDATA[next 入门配置 主题安装下面Next下的_config称主题配置， 根目录Hexo的_config称站点配置 安装next 到目录 themes/next:注意安装完themes下应该有一个 next 文件夹1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启动主题修改 站点配置:1theme: next 验证主题先清除缓存再启动服务，启动完成后打开 http://localhost:4000/1$ hexo clean &amp;&amp; hexo s 主题设定选择SchemeScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。在主题配置配置中的Scheme选项。目前提供三种方案： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 目前使用的是 scheme: Mist方案 设置语言在站点配置 language 中设置 zh-Hans (简体中文)。支持的语言可在 themes/next/languages 中查看 设置菜单菜单格式为 item name: link此处只是将 url映射到对应 菜单上，若要具体显示文案需要到语言配置文件修改123456menu: home: / # 主页 categories: /categories # 分类 archives: /archives # 归档 tags: /tags # 标签 about: /about # 关于我 设置菜单图标图标可从http://fontawesome.io/选择123456789menu_icons: enable: true # 是否显示图标 # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 设置侧栏 设置侧栏位置：主题配置 修改 sidebar.position 的值，支持 left &amp; right但目前只有Pisces Scheme支持该设置 设置侧栏显示的时机主题配置 修改 sidebar.display，目前支持的有： post 默认行文，文展页面自动展开 首页等不自动展开 always 所有页面都自动展开 hide 所有页面都隐藏，可以手动展开 remove 完全移除 设置头像主题配置 修改 avatar字段。支持互联网URI 如 https://www.img.com/img.jpg或站内地址 /images/avatar.jpg 集成第三方服务百度统计 登录百度统计， 定位到站点的代码获取页面 复制 hm.js? 后面那串统计脚本 id，如:hm.src = &quot;https://hm.baidu.com/hm.js?dksjklsajdlkasjkl&quot;;则id = dksjklsajdlkasjkl 修改主题配置 baidu_analytics 字段，改为上述id 骚等一段时间后可以自行登录百度统计查看PV,UV等数据。 文章阅读量统计为Next主题添加文章阅读量]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-辅助函数]]></title>
    <url>%2F2017%2F04%2Fhexo-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[主要用于模板中辅助的函数，如 date(Date, &#39;YYYY-DD-MM&#39;) 详见https://hexo.io/zh-cn/docs/helpers.html]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-变量]]></title>
    <url>%2F2017%2F04%2Fhexo-%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[变量主要用于 layout 等的应用 全局变量 变量 描述 site 网站变量 page 针对该页面的内容以及 front-matter 所设定的变量。 config 网站配置 theme 主题配置。继承自网站配置。 _ (单下划线) Lodash 函数库 path 当前页面的路径（不含根路径） url 当前页面的完整网址 env 环境变量 网站变量 变量 描述 site.posts 所有文章 site.pages 所有分页 site.categories 所有分类 site.tags 所有标签 页面变量页面page 变量 描述 page.title 页面标题 page.date 页面建立日期（Moment.js 对象） page.updated 页面更新日期（Moment.js 对象） page.comments 留言是否开启 page.layout 布局名称 page.content 页面的完整内容 page.excerpt 页面摘要 page.more 除了页面摘要的其余内容 page.source 页面原始路径 page.full_source 页面的完整原始路径 page.path 页面网址（不含根路径）。我们通常在主题 中使用 url_for(page.path)。 page.permalink 页面的完整网址 page.prev 上一个页面。如果此为第一个页面则为 null。 page.next 下一个页面。如果此为最后一个页面则为 null。 page.raw 文章的原始内容 page.photos 文章的照片（用于相簿） page.link 文章的外部链接（用于链接文章） 文章post与page类似 但是添加了下列变量 变量 描述 page.published 如果该文章已发布则为True page.categories 该文章的所有分类 page.tags 该文章的所有标签 首页 index 变量 描述 page.per_page 每页显示的文章数量 page.total 总文章数 page.current 目前页数 page.current_url 目前分页的网址 page.posts 本页文章 page.prev 上一页的页数。如果此页是第一页的话则为 0。 page.prev_link 上一页的网址。如果此页是第一页的话则为 ‘’。 page.next 下一页的页数。如果此页是最后一页的话则为 0。 page.next_link 下一页的网址。如果此页是最后一页的话则为 ‘’。 page.path 当前页面的路径（不含根目录）。我们通常在主题中使用 url_for(page.path)。 归档 (archive)与 index 布局相同， 但新增了以下变量 变量 描述 page.archive 等于 true page.year 年份归档 (4位) page.month 月份归档 (没有前导零的2位数) 分类 (category)与 index 布局相同， 但新增了以下变量 变量 描述 page.category 分类名称 标签(tag)与 index 布局相同， 但新增了以下变量 变量 描述 page.tag 标签名称]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-模板]]></title>
    <url>%2F2017%2F04%2Fhexo-%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[模板决定了网站内容的呈现方式，每个主题至少都应包含一个 index 模板，以下是各页面相对应的模板名称： 模板 用途 回调 index 首页 post 文章 index page 分页 index archive 归档 index category 分类归档 archive tag 标签归档 archive 布局 Layout布局这块可参考 next 主题看, Hexo 默认的引擎模板为swig 如果页面结构类似，例如两个模板都有页首（Header）和页脚（Footer），您可考虑通过「布局」让两个模板共享相同的结构。一个布局文件必须要能显示 body 变量的内容，如此一来模板的内容才会被显示，举例来说： index.ejs1index layout.ejs1234&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt;&lt;%- body %&gt;&lt;/body&gt;&lt;/html&gt; 生成1234&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt;index&lt;/body&gt;&lt;/html&gt; 每个模板都默认使用 layout 布局，您可在 front-matter 指定其他布局，或是设为 false 来关闭布局功能，您甚至可在布局中再使用其他布局来建立嵌套布局。 局部模板 Partial局部模板让您在不同模板之间共享相同的组件，例如页首（Header）、页脚（Footer）或侧边栏（Sidebar）等，可利用局部模板功能分割为个别文件，让维护更加便利。 官网说的都是ejs语法， 目前next采用的是swig 语法。 TODO 后面再补上 Next主题学习 &amp;&amp; swig]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-主题概述]]></title>
    <url>%2F2017%2F04%2Fhexo-%E4%B8%BB%E9%A2%98%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[了解一款主题的文件结构可以让你在有自定义需求的时候，快速定位到目标文件，也为后面的定制化主题做铺垫。 创建 Hexo 主题非常容易，您只要在 themes 文件夹内，新增一个任意名称的文件夹，并修改 _config.yml 内的 theme 设定，即可切换主题。一个主题可能会有以下的结构： 123456.├── _config.yml├── languages├── layout├── scripts└── source _config.yml主题的配置文件。修改时会自动更新，无需重启服务器。 languages语言文件夹。请参见 国际化 (i18n)。 layout布局文件夹。用于存放主题的模板文件，决定了网站内容的呈现方式，Hexo 内建 Swig 模板引擎，您可以另外安装插件来获得 EJS、Haml 或 Jade 支持，Hexo 根据模板文件的扩展名来决定所使用的模板引擎，例如：12layout.ejs - 使用 EJSlayout.swig - 使用 Swig 详细见 模板 scripts脚本文件夹。在启动时，Hexo 会载入此文件夹内的 JavaScript 文件，详细见 插件 。 source资源文件夹，除了模板以外的 Asset，例如 CSS、JavaScript 文件等，都应该放在这个文件夹中。文件或文件夹开头名称为 _（下划线线）或隐藏的文件会被忽略。 如果文件可以被渲染的话，会经过解析然后储存到 public 文件夹，否则会直接拷贝到 public 文件夹 发布（略）]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-永久链接]]></title>
    <url>%2F2017%2F04%2Fhexo-%E6%B0%B8%E4%B9%85%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[你可以在_config.yml &gt; permalink配置网站的永久链接或者每篇文章的Front-matter自定义该文章的永久链接, 如: :year/:month/:title/ 对应 2017/04/hexo-永久链接/ 变量除了下列变量外，您还可使用 Front-matter 中的所有属性。 变量 描述 :year 文章的发表年份（4 位数） :month 文章的发表月份（2 位数） :i_month 文章的发表月份（去掉开头的零） :day 文章的发表日期 (2 位数) :i_day 文章的发表日期（去掉开头的零） :title 文件名称 :id 文章 ID :category 分类。如果文章没有分类，则是 default_category 配置信息。 也可以在 permalink_defaults 参数下调整永久链接中各变量的默认值：12permalink_defaults: lang: en]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-生成文件与部署]]></title>
    <url>%2F2017%2F04%2F%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6%E4%B8%8E%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[生成文件生成文件一般是用于生成静态资源文件部署服务器用的 12345$ hexo generate快捷方式为:$hexo g 也可以让Hexo在监视到文件变动后立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。1$ hexo generate --watch 一般会跑以下命令，方便在Hexo生成文件后直接部署到Github上123456789$ hexo generate --deploy$ hexo deploy --generate(上面两条命令效果一样)或者简写$ hexo g -d$ hexo d -g(上面两条命令效果一样) 部署服务器在部署之前先要在 _config.yml 将部署信息补充完整，此处以 Github 为例: _config.yml配置12345deploy: type: git # type repo: https://github.com/jsonz1993/jsonz1993.github.io.git # 仓库地址 branch: master # 分支 可不填自动识别 message: "feat(hexo)-生成文件与部署" # 提交的信息 参数说明123repo 库（Repository）地址branch 分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。message 自定义提交信息 (默认为 Site updated: &#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125;) 确保本地安装了 hexo-deployer-git， 可通过以下方法安装1$ npm install hexo-deployer-git --save 你也可以通过 generate 生成静态资源，再手动copy或上传到服务器.]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-本地服务器]]></title>
    <url>%2F2017%2F04%2F%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一般安装hexo时会自动安装服务器，如果本地没有安装hexo服务器可通过以下命令安装：1$ npm install hexo-server --save 安装完成后，启动服务器，会启动一个（默认4000端口）本地服务器，可通过 http://localhost:4000 访问，Hexo会监视文件变动自动更新，如果是改动配置，需要手动重启服务：1$ hexo server 缩写1$ hexo s 如果您想要更改端口，或是在执行时遇到了 EADDRINUSE 错误，可以在执行时使用 -p 选项指定其他端口，如下：1$ hexo server -p 5000 自定义IP服务器默认运行在 0.0.0.0，您可以覆盖默认的 IP 设置，如下：1$ hexo server -i 192.168.1.1 指定这个参数后，您就只能通过该IP才能访问站点。例如，对于一台使用无线网络的笔记本电脑，除了指向本机的127.0.0.1外，通常还有一个192.168.*.*的局域网IP，如果像上面那样使用-i参数，就不能用127.0.0.1来访问站点了。对于有公网IP的主机，如果您指定一个局域网IP作为-i参数的值，那么就无法通过公网来访问站点。]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-资源文件夹与数据文件夹]]></title>
    <url>%2F2017%2F04%2F%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%A4%B9%2F</url>
    <content type="text"><![CDATA[资源文件资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 ![](/images/image.jpg) 的方法访问它们。 文章资源文件夹可以通过设置 _config.yml 来使生成的每个文章都有对应的静态资源文件夹。 _config.yml1post_asset_folder: true 数据文件有时您可能需要在主题中使用某些资料，而这些资料并不在文章内，并且是需要重复使用的，那么您可以考虑使用 Hexo 3.0 新增的「数据文件」功能。此功能会载入 source/_data 内的 YAML 或 JSON 文件，如此一来您便能在网站中复用这些文件了。 举例来说，在 source/_data 文件夹中新建 menu.yml 文件： 123Home: /Gallery: /gallery/Archives: /archives/ 您就能在模板中使用这些资料： 123&#123;% for link in site.data.menu %&#125; &lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot;&gt;&#123;&#123; loop.key &#125;&#125;&lt;/a&gt;&#123;% endfor %&#125;]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tag plugins]]></title>
    <url>%2F2017%2F04%2Ftag-plugins%2F</url>
    <content type="text"><![CDATA[tag plugins 用于在文章中快速插入特定内容的插件,下面列出常用几种 具体参见https://hexo.io/zh-cn/docs/tag-plugins.html 引用快在文章中插入引言，可包含作者、来源和标题。123&#123;% blockquote @Jsonz http://weibo.com/u/1638841204 %&#125;引用内容&#123;% endblockquote %&#125; 引用内容 @Jsonzweibo.com/u/1638841204 代码块样式可以在 themes&gt;next&gt;source&gt;css修改[language] [title] [url] [link text] code snippet 这是标题,Jsonz's Github1234const a = ()=&gt; &#123; [..."123"].forEach(item=&gt; ++item); return &#123;&#125;;&#125; iframe1&#123;% iframe url [width] [height] %&#125; image插入指定大小图片 1&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125;]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello Hexo]]></title>
    <url>%2F2017%2F04%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[折腾了一晚上终于把搭好自己喜欢的主题的Hexo博客。接下来一步一步配置 Hexo __config.yml 文件Hexo 官网配置项 一步一步跟着改配置，比较麻烦的是每次修改配置都要hexo s 重启一下服务器看效果如果修改配置后重启服务看不到效果，可以先运行hexo clean清除缓存再重启服务 Site 网站123456title: jsonz1993 # 网站标题，也会显示在该主题导航左上角subtitle: # 网站副标题 会生成在导航栏主标题旁边（这里隐藏了）description: 前端开发 Jsonz 张欣欣 # 网站描述，会出现在head，侧边菜单上 主要用做SEOauthor: Jsonz # 博客作者 Your Namelanguage: zh-Hans # 语言，支持的语言可以在themes&gt;your-thems&gt;languages 找到timezone: # 默认使用电脑的时区，一般不填 URL 网址123456url: https://jsonz1993.github.io/root: /# 文章永久链接的格式 [https://hexo.io/zh-cn/docs/permalinks.html]# 可以使用的变量有[:year, :month, :day, :title, :id, :category, Front-matter所有属性]permalink: :year/:month/:day/:title/ permalink_defaults: # 可以给变量指定默认值 Directory 目录123456789# 定义文件目录, 这部分一般用默认的就可以source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render: Writing 文章相关配置123456789101112131415161718# 新文章的名称 我喜欢配合年月按文件夹分类，这样后面方便管理# 此时生成的文件位于: source/_posts/:year/:month/:title.mdnew_post_name: :year/:month/:title.md default_layout: post #命令行 hexo new &lt;layout&gt; name 中 layout默认值titlecase: false # 标题转换为首字母大写external_link: true # 是否在新标签打开连接filename_case: 0 # 文件名大小写转换 (0)不转换（1)小写 (2)大写render_drafts: false # 显示草稿# 启动资源文件夹 看个人可用可不用# 主要每次创建文件都会生成一个同名文件夹用于存放图片等资源post_asset_folder: truerelative_link: false # 把链接改为与根目录的相对位址future: true # 显示下一条文章highlight: # 代码块设置 既现在看到的这块 enable: true line_number: true auto_detect: false tab_replace: Category &amp; Tag 分类&amp;标签123default_category: uncategorized # 默认的分类category_map: # 分类映射（别名）tag_map: # 标签映射（别名） Date / Time format 日期&amp;时间格式12date_format: YYYY-MM-DDtime_format: HH:mm:ss Pagination 分页设置123# 文章数量有限，未实践过该功能per_page: 10 # 每页文章数量 0 为关闭分页pagination_dir: page # 分页的目录 Extensions 其他拓展设置12# 此处有插件与主题设置theme: next #设置的主题应存放在 根目录/themes下 将草稿转为文章1hexo publish [layout] &lt;filename&gt;]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
