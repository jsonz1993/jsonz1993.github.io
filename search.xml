<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[iOS基础教程之界面初体验]]></title>
      <url>%2F2017%2F04%2FiOS%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%95%8C%E9%9D%A2%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
      <content type="text"><![CDATA[demo源码 如果找不到，则到finish文件下找 创建项目因为要学的是 UIwindow， 所以创建的不再是之前的Command Line Tool。 选择iOS=&gt;Single View Application.语言选择ObjectiveC, 项目名根据自己喜欢的取。 Hello UIwindowmain.m 入门文件不再出现在根目录上，而是在Supporting Files下。默认引用了 &lt;UIKit/UIKit.h&gt; 和 &quot;AppDelegate.h&quot; 点击项目文件 删除 Main Interface的默认值Main 然后打开AppDelegate.m 开始来手动来设置一下mainInterfacez AppDelegate.m123456789101112- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. // 设置大小和位置 `UIScreen mainScreen` 可以得到手机主屏幕 `bounds`是获得大小 _window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; // 设置颜色为红色 _window.backgroundColor = [UIColor redColor]; // 设置根视频控制器 _window.rootViewController = [[UIViewController alloc] init]; // 将window设置为我们的主window [_window makeKeyAndVisible]; return YES;&#125; 修改后按 cmd(⌘)+R或按左上角的三角形按钮来 run app。骚等片刻就可以看到 一个全屏红色的模拟器.; UIView新建一个项目。 UI的基类， 基础 UIView的属性 UIView的方法 UIView的自适应 ViewController.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129//// ViewController.m// UIwindow//// Created by Jsonz on 2017/4/27.// Copyright © 2017年 Jsonz. All rights reserved.//#import "ViewController.h"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; NSLog(@"bilibili"); [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 视图 UIView *view1 = [[UIView alloc] init]; // 实例化view // 状态栏高度为20px 所以写view的时候一般会让出20px view1.frame = CGRectMake(10, 30, 375-20, 667-20); // 背景颜色 view1.backgroundColor = [UIColor redColor]; // 将视图加入到父视图中 [self.view addSubview: view1]; // self.view 是view1的父视图 NSLog(@"frame = x:%f y:%f w:%f h:%f", view1.frame.origin.x, view1.frame.origin.y, view1.frame.size.width, view1.frame.size.height); // 一般叫边框大小， x &amp;&amp; y 永远为0 w&amp;&amp;h 一致 NSLog(@"bounds = x:%f y:%f w:%f h:%f", view1.bounds.origin.x, view1.bounds.origin.y, view1.bounds.size.width, view1.bounds.size.height); // center - 中心点 NSLog(@"center - x:%f y:%f", view1.center.x, view1.center.y); // 图片 1.png // 如果是二倍视网膜屏幕 准备 1@2x.png // 同理还有 1@3x.png NSLog(@"w:%f h:%f",[[UIScreen mainScreen] bounds].size.width, [[UIScreen mainScreen] bounds].size.height); // 父视图 只会有一个 UIView *superView = view1.superview; superView.backgroundColor = [UIColor greenColor]; UIView *view2 = [[UIView alloc] init]; view2.frame = CGRectMake(10, 100, 300, 300); // 坐标全是根据自身父视图来设置的，不会跨层 // 给view设置唯一标识，方便父级视图获取辨认 view2.tag = 2; view2.backgroundColor = [UIColor blackColor]; [view1 addSubview:view2]; UIView *view3 = [[UIView alloc] init]; view3.frame = CGRectMake(20, 50, 100, 100); view3.tag = 3; view3.backgroundColor = [UIColor purpleColor]; [view1 addSubview:view3]; // 子视图 会有多个 NSArray *subViewsArray = view1.subviews; for (UIView *view in subViewsArray) &#123; if (view.tag == 2) view.backgroundColor = [UIColor whiteColor]; // view2变白色 &#125; // 如果知道子视图的tag 可以通过tag得到对应的子视图 UIView *subView = [view1 viewWithTag:3]; subView.backgroundColor = [UIColor greenColor]; // 修改层级 类似css 的 zIndex // 当层交换之后， 对应的子视图的数组下标也会进行改变 // 同一个父视图中，先加入的view层级会比较低 UIView *view4 = [[UIView alloc] init]; view4.frame = CGRectMake(0, 100, 300, 300); view4.backgroundColor = [UIColor yellowColor]; [self.view insertSubview:view4 atIndex:0]; // 这时候 view4会盖住view1的所有界面 // 交换两个层的视图 [superView exchangeSubviewAtIndex:0 withSubviewAtIndex:1]; //插入一个视图到指定层 UIView *view5 = [[UIView alloc] init]; view5.frame = CGRectMake(7, 80, 200, 200); view5.backgroundColor = [UIColor blackColor]; [view1 insertSubview:view5 atIndex:1]; // 将一个view 放最顶层或最底层 [view1 bringSubviewToFront:view2]; // 顶层 [view1 sendSubviewToBack: view2]; // 底层 // 自适应 UIView *backView = [[UIView alloc] init]; backView.frame = CGRectMake([UIScreen mainScreen].bounds.size.width / 2 - 25, [UIScreen mainScreen].bounds.size.height /2 - 25, 50, 50); // 自适应到屏幕中部 backView.backgroundColor = [UIColor orangeColor]; backView.tag = 1001; // 准许子视图自适应 backView.autoresizesSubviews = YES; [self.view addSubview: backView]; UIView *topView = [[UIView alloc] init]; topView.frame = CGRectMake(10, 10, 30, 30); topView.backgroundColor = [UIColor greenColor]; // 再设置子视图的适应方式 左侧适应 topView.autoresizingMask = UIViewAutoresizingFlexibleRightMargin | UIViewAutoresizingFlexibleLeftMargin | UIViewAutoresizingFlexibleTopMargin | UIViewAutoresizingFlexibleBottomMargin | UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight; // 右， 左， 上， 下， 宽， 高 跟随父级自适应 [backView addSubview: topView]; // 按钮 下节课会讲到 UIButton *btn = [UIButton buttonWithType: UIButtonTypeSystem]; btn.frame = CGRectMake(10, 550, 355, 30); btn.backgroundColor = [UIColor brownColor]; [btn addTarget:self action:@selector(btnClick) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview: btn];&#125;-(void)btnClick&#123; UIView *view = [self.view viewWithTag:1001]; view.frame = CGRectMake(view.frame.origin.x - 5, view.frame.origin.y -5, view.frame.size.width + 10, view.frame.size.height + 10);&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end UILabel 文本标签 UIColor 颜色类 新建一个项目 ViewController12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 文本标签 UILabel *label = [[UILabel alloc] init]; label.frame = CGRectMake(10, 100, 300, 30); label.backgroundColor = [UIColor yellowColor]; // 文本 label.text = @"我是一个IOS FONT"; // 文字布局 NSTextAlignmentCenter NSTextAlignmentLeft NSTextAlignmentRight 等等 label.textAlignment = NSTextAlignmentCenter; // 文字颜色 // clearColor透明色 // colorWithRed green blue alpha 类似css的rgba label.textColor = [UIColor colorWithRed:.1 green:.8 blue:.2 alpha:1]; // label的透明度 label.alpha = .9; // 字体设置 label.font里面 label.font = [UIFont systemFontOfSize: 25]; // 字号 // 加粗或倾斜 label.font = [UIFont boldSystemFontOfSize:25];// 加粗和25号字，会覆盖前面设置 label.font = [UIFont italicSystemFontOfSize:25]; // 倾斜 // 看系统有哪些字体 for (NSString *name in [UIFont familyNames]) &#123; NSLog(@"font = %@", name); &#125; // 设置字体 label.font = [UIFont fontWithName:@"Bodoni 72 Smallcaps" size:25]; // 文字阴影// label.shadowColor = [UIColor redColor];// label.shadowOffset = CGSizeMake(1, 1); // 多文字处理 会自动出现... label.text = @"topView.autoresizingMask = UIViewAutoresizingFlexibleRightMargin | UIViewAutoresizingFlexibleLeftMargin | UIViewAutoresizingFlexibleTopMargin | UIViewAutoresizingFlexibleBottomMargin | UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight; // 右， 左， 上， 下， 宽， 高 跟随父级自适应[backView addSubview: topView]"; // 如果要换行 // 1. 首先label要足够大 // 2. 设置换行模式 // 3. 设置显示行数 label.frame = CGRectMake(20, 20, [UIScreen mainScreen].bounds.size.width - 40, [UIScreen mainScreen].bounds.size.height - 40); label.lineBreakMode = NSLineBreakByCharWrapping; label.numberOfLines = 2; // 如果设置到-1或0 就不会限制行数，能显示多少行就显示多少行 [self.view addSubview:label]; &#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125; UIImageView 图片view新建一个项目,添加自己喜欢的照片到项目里。 比如我 肯定是添加GAKKI的 ViewController.m12345678910111213141516171819202122232425262728293031323334353637383940- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 首先 随便加载几张图片到项目中 // 获取图片路径 NSString *path = [[NSBundle mainBundle] resourcePath]; // 工程目录 NSString *imgPath = [NSString stringWithFormat: @"%@/2.jpg", path]; // 拼接图片路径 // 后面参数为图片路径 UIImage *image = [[UIImage alloc] initWithContentsOfFile: imgPath]; // 加载完会释放，不会存在内存中，不过每次都会去加载// image = [UIImage alloc] initWithData:&lt;#(nonnull NSData *)#&gt; 2进制格式图片加载// UIImage *image1 = [UIImage imageNamed:@"2"]; // 这种直接写文件名，如果是png格式的，可以省略后缀名 这种方式直接把图片放到内存中，占用内存但是下次调用会很快。 比如qq表情，可以放到缓存（内存）中 // 图片显示必须要有载体 UIImageView *imageView = [[UIImageView alloc] initWithImage: image]; // image.size.width image.size.height imageView.frame = CGRectMake(10, 100, 400, 400); // 内容模式 居中： UIViewContentModeCenter // 默认为UIViewContentModeScaleToFill 拉伸充满整个载体 // UIViewContentModeScaleAspectFit 拉伸但不改变比例，充满小的边框 // UIViewContentModeScaleAspectFill 拉伸但不改变比例，充满大的边框 // 学过css的 应该都很容易理解 background-size模式 imageView.contentMode = UIViewContentModeScaleAspectFit; // UIImageView 动画 - 播放序列图 略! // 图片显示在屏幕上的大小是载体来控制的 [self.view addSubview: imageView]; &#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Foundation 入门]]></title>
      <url>%2F2017%2F04%2FFoundation-%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[Foundation(基础框架) 课程知识比较多，所以后面会每个学习内容新建一个类去写。 新建一个项目， 文章源码,找不到则到finish里面找 String新建一个String类String.h12345#import &lt;Foundation/Foundation.h&gt;@interface String : NSObject-(void) stringBaseFn; // 声明一个函数，后面有关的字符串函数知识都写在该方法内@end main.m123456789101112// 引入并调用该方法，主要是一些字符串的方法 以及输出#import &lt;Foundation/Foundation.h&gt;#import "String.h"int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; String *str = [[String alloc] init]; [str stringBaseFn]; &#125; return 0;&#125; String.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132//// String.m// foundation//// Created by Jsonz on 2017/4/23.// Copyright © 2017年 Jsonz. All rights reserved.//#import "String.h"@implementation String-(void) stringBaseFn&#123; char *s = "Hello C"; // c语言字符串 char 类型 *号代表对象 // OC 中@代表对象 NSString *str = @"Hello ObjectiveC"; // OC 字符串 NSString 类型 *号代表对象 // OC 与 C字符串的类型转换 // C -&gt; OC NSString *str1 = [NSString stringWithUTF8String:s]; NSLog(@"str1 = %@", str1); // OC -&gt; C NSLog(@"str2 = %s", [str UTF8String]); // 这样创建字符串，不需要自己手动去释放内存等 NSString *str3 = @"IOS"; // 这种需要手动释放内存 NSString *str4 = [[NSString alloc] init]; str4 = @"ios"; // **格式化字符串** 重要 int a = 10; NSString *str5 = [NSString stringWithFormat:@"a = %d str3 = %@", a, str3]; NSLog(@"str5 为 %@", str5); // 拼接字符串 NSString *str6 = [str5 stringByAppendingString: [NSString stringWithUTF8String: s]]; NSLog(@"str6 = %@", str6); // 大小写的转换问题 NSString *str7 = @"HELLO JSONZ"; NSString *str8 = [str7 lowercaseString]; NSLog(@"str8 = %@", str8); // 转换大写 NSString *str9 = [str8 uppercaseString]; NSLog(@"str9 = %@", str9); // 前缀和后缀的判断 NSString *str10 = @"www.imooc.com"; // 判断前缀 BOOL hasPreFix = [str10 hasPrefix:@"www."]; if (hasPreFix) NSLog(@"有对应前缀"); else NSLog(@"没有对应前缀"); // 后缀 BOOL hasSuffix = [str10 hasSuffix:@".com"]; if (hasSuffix) NSLog(@"有对应后缀"); else NSLog(@"没有对应后缀"); // 判断字符串是否相同 NSString *str11 = @"Hello"; NSString *str12 = @"Hello"; if ([str11 isEqualToString:str12]) NSLog(@"str11 与 str12 一致"); else NSLog(@"不一致"); // 分割字符串 // 1. 按照指定字符分割字符串 返回数组 NSString *str13 = @"a,b,c,d,e,f,g"; NSArray *strArray = [str13 componentsSeparatedByString:@","]; for (NSString *str in strArray) &#123; NSLog(@"str = %@", str); &#125; // 2. 按照范围截取字符串 NSRange range = NSMakeRange(1, 5); NSString *str14 = [str13 substringWithRange:range]; NSLog(@"str14 = %@", str14); // 3. 从某一位开始截取到结束 NSString *str15 = [str13 substringFromIndex:2]; NSLog(@"str15 = %@", str15); // 4.从开头到某一位 NSString *str16 = [str13 substringToIndex:7]; NSLog(@"str16 = %@", str16); // 5.将字符串拆分为每一个字符, 从字符串取出某一位 for (int i = 0; i &lt; [str13 length]; i++) &#123; NSLog(@"%c", [str13 characterAtIndex:i]); &#125; // 查找 NSString *str17 = @"ab cd ef gh ij ab"; // 查找指定字符串的位置 正向查找 NSRange range1 = [str17 rangeOfString:@"ab"]; NSLog(@"range1.location: %ld range1.length: %ld", range1.location, range1.length); // 替换 NSString *str18 = @"Hello ios, Hello imooc"; // 替换某一个范围的内容 NSString *str19 = [str18 stringByReplacingCharactersInRange:NSMakeRange(0, 5) withString:@"你好"]; NSLog(@"str19 = %@", str19); // 用指定字符串替换原字符串 NSString *str20 = [str18 stringByReplacingOccurrencesOfString:@"Hello ios" withString: @"第一个参数为源字符串中要被替换的内容， 第二个为替换成的字符串"]; NSLog(@"str20 = %@", str20); // 读取文件 // 1. 本地文件； 2.网络文件 // 路径类 NSString *str21 = @"www.baidu.com"; // 网络路径 NSURL *httpURL = [NSURL URLWithString:str21]; //本地路径// NSString *fileURL = [NSURL fileURLWithPath:str21]; // 读取网络文件 NSString *httpStr = [NSString stringWithContentsOfURL:httpURL encoding:NSUTF8StringEncoding error:nil]; NSLog(@"httpStr = %@", httpStr); // 读取本地文件 NSString *fileStr = [NSString stringWithContentsOfFile: @"/Users/jsonz/Documents/learn/Objective-c/foundation/foundation/app.txt" encoding:NSUTF8StringEncoding error: nil]; NSLog(@"fileStr = %@", fileStr); // 写入文件 NSString *str22 = @"Hello JSer"; BOOL isOk = [str22 writeToFile:@"/Users/jsonz/Documents/learn/Objective-c/foundation/foundation/app.js" atomically:YES encoding:NSUTF8StringEncoding error:nil]; if (isOk) NSLog(@"文件写入成功"); else NSLog(@"文件写入失败");&#125;@end NSMutableString 可变字符串新建一个 NSMutableStringClass 类。 NSMutableString是字符串的子类 NSMutableString.h12345678910111213//// NSStringClass.h// foundation//// Created by Jsonz on 2017/4/25.// Copyright © 2017年 Jsonz. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@interface NSMutableStringClass : NSObject-(void) ShowNSMutableString;@end NSMutableString.m123456789101112131415161718192021222324252627282930313233343536373839404142//// NSStringClass.m// foundation//// Created by Jsonz on 2017/4/25.// Copyright © 2017年 Jsonz. All rights reserved.//#import "NSMutableStringClass.h"@implementation NSMutableStringClass-(void) ShowNSMutableString&#123; // 可变字符串的简单方法 // 可变字符串是字符串的子类 // 实例化 NSMutableString *str = [[NSMutableString alloc] initWithCapacity:10]; // 分类长度不可以超过10， 性能优化。不过超过10 也不会报错 [str setString:@"hello "]; // 1.追加字符串 [str appendString:@"ObjectiveC"]; NSLog(@"str = %@", str); // 追加格式化字符串 int a = 10; [str appendFormat:@" - %d", a]; NSLog(@"str = %@", str); // 2.替换字符串 NSRange range = [str rangeOfString:@"ObjectiveC"]; [str replaceCharactersInRange:range withString:@"IOS"]; NSLog(@"str = %@", str); // 3. 插入字符串 [str insertString:@"A" atIndex: 4]; NSLog(@"str = %@", str); // 4. 删除字符串 NSRange range1 = [str rangeOfString:@"IOS"]; [str deleteCharactersInRange:range1]; NSLog(@"str = %@", str);&#125;@end main.m 调用前记得引入类12NSMutableStringClass *_NSMutableString = [[NSMutableStringClass alloc] init];[_NSMutableString ShowNSMutableString]; NSArray 不可变数组新建一个arr类 Arr.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//// Arr.m// foundation//// Created by Jsonz on 2017/4/26.// Copyright © 2017年 Jsonz. All rights reserved.//#import "Arr.h"@implementation Arr-(void) showArrFn&#123; NSLog(@"不可变数组"); // OC数组。 可以存储不同类型对象,只能存储对象.(int, char)不可以 // 只存对象指针（js一样) NSArray *arr1 = [[NSArray alloc] initWithObjects:@"1", @"2", @"3", @"4", @"5", nil]; // 数组长度 int count = (int)arr1.count; NSLog(@"count = %d", count); // 判断是否有该对象 BOOL isHave = [arr1 containsObject: @"2"]; if (isHave) NSLog(@"存在"); else NSLog(@"不存在"); // 取得数组中所需元素 NSString *str = [arr1 lastObject]; NSLog(@"最后一个对象为 %@", str); str = [arr1 firstObject]; NSLog(@"第一个对象为 %@", str); str = [arr1 objectAtIndex: 3]; NSLog(@"第三个元素为 %@", str); // 查找某个对象为第几个下标, 不存在则 -1 int index = (int)[arr1 indexOfObject:@"3"]; NSLog(@"查找某个对象为第几个下标 %d", index); // 数组的遍历 1.for; 2. for in; 3.枚举迭代 // for 循环 注意类型问题 for (int i = 0; i &lt; arr1.count; i++) &#123; NSString *str1 = [arr1 objectAtIndex:i]; NSLog(@"for str1 = %@", str1); &#125; // 快速枚举 数组的元素类型要保持一致 for (NSString *str2 in arr1) &#123; NSLog(@"for in str2 = %@", str2); &#125; // 迭代枚举(慕课没有该点视频) [arr1 enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123; NSLog(@"id= %@", obj); &#125;];&#125;@end NSMutableArr 可变数组与可变字符串一样，数组也有可变的。一般项目中如果有修改数组的就用这个，如果不希望数组被修改则用不可变数组 NSMutableArrClass.m123456789101112131415161718192021222324252627282930313233343536373839404142434445//// NSMutableArrClass.m// foundation//// Created by Jsonz on 2017/4/26.// Copyright © 2017年 Jsonz. All rights reserved.//#import "NSMutableArrClass.h"@implementation NSMutableArrClass-(void)showArrFn&#123; NSMutableArray *array = [[NSMutableArray alloc] init]; NSString *str1 = @"bili"; // 添加元素 [array addObject: str1]; NSArray *arr1 = [[NSArray alloc] initWithObjects:@"1", @"2", @"3", @"4", @"5", nil]; [array addObject:arr1]; NSLog(@"array = %@", array); // 删除所有元素 [array removeAllObjects]; NSLog(@"删除后的 array = %@", array); [array addObject:arr1]; [array addObject: str1]; // 删除最后一个元素 [array removeLastObject]; NSLog(@"删除后的 array = %@", array); [array addObject: str1]; // 删除指定元素 [array removeObject:@"bili"]; NSLog(@"删除后的 array = %@", array); // 删除指定index的元素 [array removeObjectAtIndex:0]; NSLog(@"删除后的 array = %@", array); [array addObject:arr1]; [array addObject: str1]; // 交换元素位置 [array exchangeObjectAtIndex:1 withObjectAtIndex:0]; NSLog(@"交换后 %@", array);&#125;@end 字典 NSDictionary相当于js 里的对象{}. 新建一个类NSDic NSDictionary.h12345678910111213//// NSDictionary.h// foundation//// Created by Jsonz on 2017/4/26.// Copyright © 2017年 Jsonz. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@interface NSDic : NSObject-(void) showNSDictionaryFn;@end NSDictionary.m12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//// NSDictionary.m// foundation//// Created by Jsonz on 2017/4/26.// Copyright © 2017年 Jsonz. All rights reserved.//#import "NSDic.h"@implementation NSDic-(void) showNSDictionaryFn&#123; NSLog(@"test");// 字典： 相当于js的对象~ py的字典。 // 声明后不可以改 NSDictionary *dict1 = [NSDictionary dictionaryWithObject:@"1" forKey:@"a"]; NSLog(@"dict1 = %@", dict1); // 多个键值对 NSDictionary *dict2 = [NSDictionary dictionaryWithObjects:[NSArray arrayWithObjects:@"1", @"2", @"3", nil] forKeys:[NSArray arrayWithObjects:@"a", @"b", @"c", nil]]; NSLog(@"dict2 %@", dict2); // 简便写法 NSDictionary *dict3 = @&#123; @"1": @"a", @"2": @"b" &#125;; NSLog(@"dict3 %@", dict3); // 长度 int count = (int)[dict2 count]; NSLog(@"count %d", count); // 获取对应key的 value NSString *value = [dict2 valueForKey: @"b"]; NSLog(@"value = %@", value); NSString *value2 = [dict2 objectForKey: @"b"]; NSLog(@"value2 = %@", value2); // 数组 字典所有的值 NSArray *allValues = [dict2 allValues]; NSLog(@"allValues = %@", allValues); // 数组 所有的key NSArray *allKeys = [dict2 allKeys]; NSLog(@"allKeys = %@", allKeys); // 遍历 NSArray *array = [dict2 objectsForKeys:[NSArray arrayWithObjects: @"a", @"b", @"d", nil] notFoundMarker:@"Not Fount"]; NSLog(@"array = %@", array); // 遍历字典 for (NSString *key in dict2) &#123; NSLog(@"%@ = %@", key, [dict2 objectForKey:key]); &#125; // 枚举器 NSEnumerator *en = [dict2 keyEnumerator]; id key = nil; while (key = [en nextObject]) &#123; NSLog(@"key = %@", key); &#125; [dict2 enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123; NSLog(@"id = %@, obj = %@", key, obj); &#125;]; &#125;@end 可变字段 NSMutableDictionaryNSDic2.h12345678910111213//// NSDic2.h// foundation//// Created by Jsonz on 2017/4/26.// Copyright © 2017年 Jsonz. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@interface NSDic2 : NSObject-(void) showFn;@end NSDic2.m1234567891011121314151617181920212223242526272829303132333435//// NSDic2.m// foundation//// Created by Jsonz on 2017/4/26.// Copyright © 2017年 Jsonz. All rights reserved.//#import "NSDic2.h"@implementation NSDic2// 可变字典-(void) showFn&#123; NSMutableDictionary *dict = [[NSMutableDictionary alloc] init]; // 添加键值对 [dict setObject:@"1" forKey: @"a"]; [dict setObject: @"2" forKey: @"b"]; // 删除键值对 [dict removeObjectForKey:@"a"]; NSLog(@"dict 删除forKey %@", dict); // 删除所有 [dict removeAllObjects]; NSLog(@"dict 删除所有 %@", dict); [dict setObject:@"1" forKey: @"a"]; [dict setObject: @"2" forKey: @"b"]; [dict setObject: @"3" forKey: @"c"]; [dict removeObjectsForKeys: [NSArray arrayWithObjects:@"a", @"b", nil]]; NSLog(@"dict 批量删除 %@", dict); &#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Objective-C 面向对象初体验]]></title>
      <url>%2F2017%2F04%2FObjective-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
      <content type="text"><![CDATA[面向对象简介语言的面向对象都是换汤不换药 来来去去那几个概念 OOP（Object Oriented Programming) 基本概念 对象 （男人，女人，程序员） 抽象 - 类（人） 类和对象的关系 创建类(人)、得到对象（程序员） 成员变量： 内部使用，比如 大脑 眼睛 嘴 属性： 给外部使用 比如 职业 类的实例为对象 创建demo 同征战Objective-C一样 创建一个Command Line Tool 写示例代码 创建一个文件，类型为Cocoa Class,name: People, Subclass of: NSObject, language: Objective-C 。点击Next之后会生成两个文件 People.h,People.m。 引入与实例化在 main.m 里面引入文件并实例化对象, 后面如果没有特别说明， 都是在 main @autoreleasepool 里面写代码main.m12345678910111213141516171819#import &lt;Foundation/Foundation.h&gt;#import "People.h" // 引入类int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // 实例化对象 // 类名 对象名(星号代表是指针类型) = [[类名/对象名] 方法名] // People p1/p2 = [[People alloc] init] // alloc - 为对象分配内存空间 // init - 进行初始化操作 People *p1 = [[People alloc] init]; People *p2 = [[People alloc] init]; People *p3 = [People new]; // new 在Objective-C 用得少 NSLog(@"p1 - %p", p1); NSLog(@"p2 - %p", p2); NSLog(@"p3 - %p", p3); &#125; return 0;&#125; 创建成员变量与属性People.h12345678910// 姓名，年龄，性别// 类内使用成员变量(m)， 类外使用属性(h)@interface People : NSObject&#123;&#125;// 声明类的属性 声明后 main.m 就可以通过 p1.peopleName = @"Jsonz"; 访问修改属性// 属性就是成员变量的外部接口 h 文件写。外部使用//设置与获取Name@property(nonatomic, strong)NSString *peopleName;@end People.m1234567891011121314151617#import "People.h"// 成员变量 m 文件定义 内部使用@implementation People&#123; int _peopleAge; int _peopleSex;&#125;- (instancetype) init&#123; self = [super init]; if (self) &#123; _peopleName = @"张三"; // 成员变量 类内使用 &#125; return self;&#125;@end 此时main.m 可以使用peopleName属性 main.m12345// 属性的使用p1.peopleName = @"jsonz";p2.peopleName = @"李四";NSLog(@"p1.peopleName - %@", p1.peopleName);NSLog(@"p2.peopleName - %@", p2.peopleName); 函数加号方法 减号方法 的声明与调用在People.h 声明方法People.h123456789/** * - 、+ (减号代表对象方法，加号代表类方法) * 对象方法既是在实例上调用，而类方法则是在类上面调用，如: People *p1 = [[People alloc] init] * 此时 People是类， p1是对象 * h 文件进行声明， m 进行实现 */-(void) report; // 减号方法+(void) report1; // void 代表不用返回， +号方法-(int) returnInt; // 改变返回值的函数 在People.m实现该方法People.m1234567891011121314151617181920- (void) report&#123; NSLog(@"减号 Report"); // 如何在减号方法调加号方法 // [People report1]; &#125;static NSString *_peopleName1; // 静态变量，供加号方法内调用+(void) report1&#123; NSLog(@"加号 Report"); _peopleName1 = @"张三"; // 调用静态变量 不能调用成员变量 // 如何在加号方法调减号方法 // [[People alloc] report]&#125;-(int) returnInt&#123; // 前面是int，所以该函数必须返回一个int类型 return 0;&#125; 调用main.m123456People *p1 = [[People alloc] init][p1 report]; // 减号方法[People report1]; // 加号方法// [[People alloc] init]// [People alloc]会返回一个对象，这时候才能调用 init 所以 alloc是加号方法， init是减号方法 函数参数类型People.h 声明123// 函数参数问题-(int)showWithA: (int) a; // 有一个int类型参数 函数名为 `showWithA:`-(int)showWithA: (int)a andB:(int)b; // 有两个int类型参数 函数名为 `showWithA: andB:` People.m 实现123456789//参数问题-(int)showWithA:(int)a&#123; return a;&#125;-(int)showWithA:(int)a andB:(int)b&#123; return a + b;&#125; main.m 调用12345// 函数的参数使用int a1 = [p1 showWithA:10];int a2 = [p1 showWithA:20 andB:30];NSLog(@"a1 = %d", a1);NSLog(@"a2 = %d", a2); 初始化方法平时调用一个类的对象方法都是这么调用的 People *p1 = [[People alloc] init]， 但此时这个init具体做了什么事情，我们并不知道。 我们可以在类里面重写掉这个init 方法; People.h1234// 对于初始化方法来说 id || instancetype 没有区别，对于其他方法，一般 instancetype 比 id用的多// -(id)init; // 万能类型，可以返回各种类型对象-(instancetype)init; // 当前类的类型，比如当前类是People类型，那么instancetype就是People类型-(void) showPeopleProperty; // 定义一个方法来输出类的属性 People.m 重写init123456789101112131415161718192021// 如果此时提示 Duplicate declaration of method ‘init' 则代表你上面本来就声明了一个init 此时删除该init 或者把逻辑移到那个函数内即可// init 固有的模式- (instancetype) init&#123; self = [super init]; // 自己继承父级的 init 此处是 NSObject // 内部进行一些初始化的设定 if (self) &#123; _peopleName = @"Jsonz"; // 成员变量 类内使用 _peopleAge = 30; _peopleSex = 1; &#125; return self; // 返回自身&#125;// 输出People的对象初始化值-(void) showPeopleProperty&#123; NSLog(@"peopleName = %@", _peopleName); NSLog(@"peopleAge = %d", _peopleAge); NSLog(@"peopleAge = %d", _peopleSex);&#125; 接下来我们来自定义一个初始化的方法People.h1-(instancetype)initWithPeopleName:(NSString *) peopleName andPeopleAge:(int)peopleAge People.m123456789101112// 既然我们是自定义一个初始化方法，那也要按照初始化方法的写法，把一些结构给加上-(instancetupe)initWithPeopleName:(NSString *)peopleName andPeopleAge:(int)peopleAge&#123; // 初始化方法的结构 self = [super init]; if (self) &#123; _peopleName = peopleName; _peopleAge = peopleAge; &#125; return self;&#125; main.m1234// 自己实现的初始化方法People *pSelf = [[People alloc] initWithPeopleName:@"Jsonz" andPeopleAge: 23];NSLog(@"自己实现的init 的属性有哪些: ---- ");[pSelf showPeopleProperty]; 面向对象三部曲新建一个项目，避免学习太混乱 封装新建一个类，叫MyClassMyClass.h1234567891011121314151617181920#import &lt;Foundation/Foundation.h&gt;@interface MyClass : NSObject&#123; // 成员变量访问修饰符的问题 // 默认为 protected 受保护的 @public // 公有 - 在类内 类外都可以使用，并且可以被继承 int _classInt; @private // 私有 - 在类内可以使用， 类外无法调用 并且无法被继承 @protected // 受保护 - 默认的 在类内可以使用，类外无法调用 并且可以被继承 NSString *_classStr; @package // 框架权限 - 在框架内相当于受保护(可被调用与继承)， 在框架外相当于私有(类外无法使用与继承)&#125;@property(nonatomic, strong)NSString *className;// 方法是没有访问修饰符的， 同C语言一样。// 如果想要一个方法可以在类外可以使用，则要在h声明，m实现。// 如果不想在类外使用， 直接在m写实现， h 不写声明。-(void) report;@end MyClass.m12345678910#import "MyClass.h"@implementation MyClass-(void)report&#123; _classStr = @"ClassStr bilibilii"; NSLog(@"ClassName - %@", _className); NSLog(@"classInt - %d", _classInt);&#125;@end main.m12345678910111213141516#import &lt;Foundation/Foundation.h&gt;#import "MyClass.h"int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; MyClass *mc = [[MyClass alloc] init]; mc.className = @"我的类"; // 类外使用 public 成员变量 mc-&gt;_classInt = 1001; // 使用指向来调用类中的公有成员变量 [mc report]; &#125; return 0;&#125; 继承创建两个类 父类 ParentClass 子类 ChildClass, 创建的时候记得选上继承 ParentClass， 如果忘了选也没关系 后面手动修改一下就可以 ParentClass.h12345678910111213141516#import &lt;Foundation/Foundation.h&gt;// NSObject - 基类 此处的:(冒号)是代表继承关系@interface ParentClass : NSObject&#123; // 受保护变量 可继承 不可外部调用 int _classInt; // 私有变量 @private NSString *_classStr; &#125;@property(nonatomic, strong)NSString *className;-(void)report; // 如果此处不声明，则类外不能调。 子类也不继承@end ParentClass.m123456789101112#import "ParentClass.h"@implementation ParentClass-(void)report&#123; _classInt = 1002; _classStr = @"Jsonz's 私有变量"; NSLog(@"ClassName - %@", _className); NSLog(@"classInt - %d", _classInt); NSLog(@"classStr - %@", _classStr); // 此处在 ChildClass 中也会被打印出来，因为继承了该方法，所以会被打印&#125;@end ChildClass.h12345#import "ParentClass.h"@interface ChildClass : ParentClass-(void)show;@end ChildClass.m12345678910#import "ChildClass.h"@implementation ChildClass-(void)show&#123; _classInt = 1003; NSLog(@"show 此处_classInt 变化了 - %d", _classInt);// NSLog(@"show 打印父类的私有方法NSString %@", _classStr); 此处因为是父级的私有变量，所以外部无法访问&#125;@end main.m1234567891011// 调用// 父类ParentClass *pc = [[ParentClass alloc] init];pc.className = @"parentClass ClassName";[pc report];// 子类ChildClass *cc = [[ChildClass alloc] init];cc.className = @"ChildClass ClassName"; // 此处为父类继承过来的属性[cc show];[cc report]; // 此处还是1002 因为 cc中的 report 继承 pc 的report，此处重新复制了并打印。所以是1002 多态 方法重写 基于父类方法继承重写，返回值，函数名，参数等都一致 方法重载 (OC 不支持) 函数名一致，返回值 参数 参数类型等都不一致 创建一个类ColorPrint 用于演示多态，后面会基于 ParentClass, ChildClass 与ColorPrint 来说明多态。 父类实现一个打印机方法ParentClass.h1-(void) print; ParentClass.m1234-(void) print&#123; NSLog(@"普通打印机");&#125; 子类重写不需要声明，直接在m文件去重写实现即可ChildClass.m1234-(void)print&#123; NSLog(@"我是黑白打印机");&#125; ColorPrinter.m12345678-(void)print&#123; // 如果此处要调用父类的方法可以这么写： [super print]; // 调用当前类的方法可以用 self 父类可以用 super // [self print]; NSLog(@"我是彩色打印机");&#125; main.m12345678910// 调用ChildClass *cc = [[ChilClass alloc] init];[cc print]; // 黑白ColorPrinter *cc2 = [[ColorPrinter alloc] init];[cc2 print]; // 彩色打印机// 如果已经引入了子类的头文件，默认父类h文件（子类头文件所引入的头文件）也会被引入了。// 可以这么写ParentClass *color = [[ColorPrinter alloc] init];[color print]; // 此处也是才是打印机 demo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[征战Objective-C]]></title>
      <url>%2F2017%2F04%2F%E5%BE%81%E6%88%98Objective-C%2F</url>
      <content type="text"><![CDATA[Objective-C 下面简称OC 源代码文件扩展名对比一般来说，头文件是放声明， 实现文件放实现的代码 头文件 实现文件 c语言 .h .c c++语言 .h .cpp oc语言 .h .m oc&amp;c++ .h .mm 面向对象概览类的定义123// 当前的SimpleClass 继承 NSObject 类@interface SimpleClass: NSObject@end 类的属性申明12345678910111213141516@interface Person:NSObject@property NSString*firstName;@property NSString*lastName;@property NSNumber *yearOfBirth;@property int yearOfBirth;@property (readonly) NSString *firstName;@end 减号方法（普通方法又称对象方法）声明12345@interface Person: NSObject- (void) someMethod;- (void) someMethodWithValue: (SomeType)value;- (void) someMethodWithFirstValue: (SomeType)info1 secondValue: (AnotherType)info2;@end 加号方法 (类方法， 又称静态方法) 声明123456789@interface NSString: NSObject+(id)string;+(id)stringWithString:(NSString *)aString;+(id)stringWithFormat:(NSString *)format, ..;+(id)stringWithContentsOfFile: (NSString *)pathencoding: (NSStringEncoding)enc error:(NSError **)error;+(id)stringWithCString: (const char *)cStringencoding: (NSStringEncoding)enc;@end 类的实现123#import 'XYZPerson.h'@implementation XYZPerson@end 完成的例子XYZPerson.h 文件123@interface XYZPerson: NSObject-(void)sayHello;@end XYZPerson.m 文件1234567#import "XYZPerson.h"@implementation XYZPerson-(void)sayHello &#123; NSLog(@"Hello, World!");&#125;@end Hello World首先去app store 下载xCode. 打开xCode 选择左侧 Create a new Xcode project=&gt;macOS=&gt; Command Line Tool ，选择保存项目的位置。 进入项目后点击左上角箭头运行，如果下面控制台有输出 hello world 则代表运行成功了。 1234567#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // 真正开始写代码的地方 &#125; return 0;&#125; ObjectiveC 变量与表达式声明变量与简单运算12345int a = 0;int b = 1;b = 3;int c = a + b;NSLog(@"变量a+ b的值等于: %d", c); // %d 格式化输出，后面加个逗号再加变量 基础类型123456int int a = 0; 整数 占32位2进制float float a = 1.0; 浮点数 占32位2进制double double num; 双精度 占64位 可以保存更大的数char char c = 'A'; 单字符串 单引号NSString: @"Hello world" 使用比较多 双引号 (高级类型)C语言字符串类型 "hello world" 使用比较少 限定词12345long: long int a; 比int 更大的整形long long: long long int a; 比 long int 更大 具体应用才会涉及 比如大数据等short: short int a; short a; 小于或等于整形， 16位 比较省类型，但是比较少用这些，一般直接用 intunsigned: unsigned int a; 无符号signed: signed int a; 有符号(正负类型) 运算12345678910int a = 1;a++;++a;a--;--a;一元 ++, --,二元 +, -, *, /, %三元 2&gt;3?Yes:Not逻辑符号 &lt;, &gt;, &gt;=, &lt;=, ==, != if12345678// 如果是真的会返回 1，如果未假返回 0;if (True) &#123; // is True&#125; else &#123; // do something&#125;// 只要非0就是真的。if (1) NSLog(@"对"); else NSLog(@"错"); // 单行可以不写括号 goto语法1234567 int i = 0;a: &#123; i++; NSLog(@"i的值为 %d", i); // 先输出一个 i = 0;&#125; if (i &lt; 5) goto a; // 执行到这里i &lt; 5 跳转到a 去执行。 直到 i == 5 // 最后输出 0, 1, 2, 3, 4 while 循环 比较常用12345int a = 0;while ( a &lt; 5) &#123; a++; NSLog(@"a的变量是 %d", a);&#125; for循环 比较常用123for (int i= 0; i &lt; 10; i++) &#123; NSLog(@"i=%d", i);&#125; do while 肯定会执行一次再判断是否循环123do &#123; NSLog(@"hehe");&#125; while (0); break continue12break 可以在 循环中 退出循环continue 可以在 循环中 跳出当前循环，继续下一项循环 switch12345678910111213141516int i = 10.0; // char int float switch (i) &#123; case 1: NSLog(@"i = 1"); break; case 2: NSLog(@"i = 2"); break; case 10: NSLog(@"i = 10"); break; default: NSLog(@"i = 10.0"); &#125; // 最后会输出一个 10。 函数123456789101112131415161718192021// 求矩形面积的函数 s = a * b;// 返回的类型 函数名 ([(参数类型， 参数名)， (参数类型， 参数名)])double qiumianji(double a, double b) &#123; double s = a * b; return s;&#125;// 调用 main 函数内。// 一个相同类型的变量来接收返回值double s = qiumianji(10.0, 5.0);NSLog(@"s 的值为 %f", s); // %d 输出整数， %f 输出浮点数// 如果没有返回值，则调用函数的时候不用一个变量去接收void show() &#123; NSLog(@"this is a test !"); NSLog(@"this is a test2 !"); NSLog(@"this is a test3 !");&#125;// main 函数内调用show(); main函数中的默认参数12345NSLog(@"argc=%d", argc);// argv 参数为 命令行输入命令运行的参数如： les1 -h -c -a -l 则有5个参数[les1, -h, -c, -a, -l]for (int i =0; i &lt; argc; i++) &#123; NSLog(@"%s", argv[i]);&#125; 输出目前遇到的总结1234567NSLog(@"type %d", a); - %d int; - %s char *; - %f float;- %p 指针类型- %@ NSString- %ld 目前遇到过的有 NSRange.length || NSRange.location]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简单事件系统]]></title>
      <url>%2F2017%2F04%2F%E7%AE%80%E5%8D%95%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
      <content type="text"><![CDATA[最简单的事件系统 应该包含四个接口 on, off, once, trigger。 初始化方法1234567function E() &#123;&#125;E.prototype = &#123; on: function()&#123;&#125;, off: ..., trigger: ..., once: ...,&#125; on 事件绑定12345678on: function(name, cb, ctx) &#123; var e = this.e || (this.e = &#123;&#125;); (e[name] || (e[name] = [])).push(&#123; fn: cb, ctx: ctx &#125;); return this;&#125;, off 事件解绑1234567891011121314off: function(name, cb, ctx) &#123; var e = this.e || (this.e = &#123;&#125;); var evts = e[name]; var liveEvents = []; if (evts &amp;&amp; cb) &#123; for (var i= 0, len= evts.length; i&lt; len; i++) &#123; if (evts[i].fn !== cb &amp;&amp; evts[i].fn._ !== cb) liveEvents.push(evts[i]); &#125; &#125; (liveEvents.length) ? e[name] = liveEvents : delete e[name]; return this;&#125; once 绑定单次123456789once: function(name, cb, ctx) &#123; var self = this; function listener() &#123; self.off(name, listener); cb.apply(ctx, arguments); &#125; listener._ = cb; return this.on(name, listener, ctx);&#125; trigger 事件触发12345678910trigger: function(name) &#123; var data = [].slice.call(arguments, 1); var evtArr = ((this.e || (this.e = &#123;&#125;))[name] || []).slice(); var i = 0; var len = evtArr.length; for (i; i&lt; len; i++) &#123; evtArr[i].fn.apply(evtArr[i].ctx, data); &#125; return this;&#125; 简单的调用12345678910111213141516171819&lt;script src="./e.js"&gt;&lt;/script&gt;&lt;script&gt;var e = new E();e.on('bilibili', function() &#123; console.log('on');&#125;).once('once', function() &#123; console.log('once')&#125;).on('off', function() &#123; console.log('off')&#125;);window.addEventListener('load', function() &#123; document.body.addEventListener('click', function() &#123; e.trigger('off') .off('off') .trigger('bilibili') .trigger('once'); &#125;);&#125;)&lt;/script&gt; 最后附上源码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[复制黏贴板插件-CopyText]]></title>
      <url>%2F2017%2F04%2F%E5%A4%8D%E5%88%B6%E9%BB%8F%E8%B4%B4%E6%9D%BF%E6%8F%92%E4%BB%B6-CopyText%2F</url>
      <content type="text"><![CDATA[最近公司有个需求是要在移动端实现操作黏贴板功能，简单来说就是点击一个一个评论弹出菜单，其中有一个就是复制的选项。其中安卓和ios中的app还好，有原生提供接口，web端就要自己去实现了。 公司原本有一个copy的插件，但是亲测没效，找到github上面一些copy的插件用的start最高的是clipboard 截止此文有16k个start。 官方说明是 Modern copy to clipboard. No Flash. Just 3kb gzipped. 只有3k!而且官方插件提供的接口不是我想要的那种，遂有了造个自己用的小轮子念头。 简单思路创建一个虚拟的textarea 设置好样式让其显示在用户看不到的界面1234567891011121314151617181920212223selectFake() &#123; const isRTL = document.documentElement.getAttribute('dir'); this.removeFake(); this.fakeHandlerCallback = ()=&gt; this.removeFake(); this.fakeHandler = document.addEventListener('click', this.fakeHandlerCallback) || true; this.fakeEl = document.createElement('textarea'); let yPosition = window.pageYOffset || document.documentElement.scrollTo; styleFn(this.fakeEl, &#123; fontSize: '12pt', border: '0', margin: '0', padding: '0', position: 'absolute', [isRTL? 'right': 'left']: '-9999px', top: `$&#123;yPosition&#125;px`, &#125;); this.fakeEl.setAttribute('readonly', ''); this.fakeEl.value = this.text; document.body.appendChild(this.fakeEl); this.selectedText = this.selectDom(this.fakeEl); this.copyText(); &#125; 选择该dom，既选中textarea的文字区域1234567selectDom(el) &#123; let selectedText; el.select(); el.setSelectionRange(0, el.value.length); el.removeAttribute('readonly'); return el.value;&#125; 执行copy事件123456789copyText() &#123; let succeeded; try &#123; succeeded = document.execCommand('copy'); &#125; catch(e) &#123; succeeded = fale; &#125; this.handleResult(succeeded); // 事件回调处理&#125; 源码加注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/** * Created by Jsonz@github.com/jsonz1993 on 17/04/16 * CopyText 将文本copy到剪切板 支持pc &amp;&amp; web。 有兼容问题 H5 建议用原生copy接口 * @param &#123;Object&#125; options 配置参数 * @property &#123;String&#125; text 要复制的文本 * @property &#123;Function&#125; success 成功回调 * @property &#123;Function&#125; error 失败回调 * * CopyText.isSupported 判断当前环境是否支持copy事件 */export default class CopyText &#123; constructor(options) &#123; this.resolveOptions(options); this.init(); &#125; // 配置参数 resolveOptions(options= &#123;&#125;) &#123; this.text = options.text; this.successCb = typeof options.success === 'function'? options.success: ()=&gt; &#123;&#125;; this.errorCb = typeof options.error === 'function'? options.error: ()=&gt; &#123;&#125;; &#125; // 初始化函数 init() &#123; if (CopyText.isSupported()) this.selectFake(); else this.handleResult(false); &#125; // 创建虚拟dom &amp;&amp; copy selectFake() &#123; const isRTL = document.documentElement.getAttribute('dir'); this.removeFake(); this.fakeHandlerCallback = ()=&gt; this.removeFake(); this.fakeHandler = document.addEventListener('click', this.fakeHandlerCallback) || true; this.fakeEl = document.createElement('textarea'); let yPosition = window.pageYOffset || document.documentElement.scrollTo; styleFn(this.fakeEl, &#123; fontSize: '12pt', border: '0', margin: '0', padding: '0', position: 'absolute', [isRTL? 'right': 'left']: '-9999px', top: `$&#123;yPosition&#125;px`, &#125;); this.fakeEl.setAttribute('readonly', ''); this.fakeEl.value = this.text; document.body.appendChild(this.fakeEl); this.selectedText = this.selectDom(this.fakeEl); this.copyText(); &#125; // 移除虚拟dom removeFake() &#123; if (this.fakeHandler) &#123; document.body.removeEventListener('click', this.fakeHandlerCallback); this.fakeHandler = null; this.fakeHandlerCallback = null; &#125; if (this.fakeEl) &#123; document.body.removeChild(this.fakeEl); this.fakeEl = null; &#125; &#125; // 选择dom selectDom(el) &#123; let selectedText; el.select(); el.setSelectionRange(0, el.value.length); el.removeAttribute('readonly'); return el.value; &#125; // copy copyText() &#123; let succeeded; try &#123; succeeded = document.execCommand('copy'); &#125; catch(e) &#123; succeeded = fale; &#125; this.handleResult(succeeded); // 事件回调处理 &#125; // 回调 handleResult(succeeded) &#123; succeeded? this.successCb(): this.errorCb(); &#125; // 判断是否支持该事件 static isSupported(action= 'copy') &#123; return !!document.queryCommandSupported &amp;&amp; !!document.queryCommandSupported(action); &#125;&#125;const styleFn = (el, opts)=&gt; &#123; if (typeof opts !== 'object' || !el.nodeType) return; for (let key in opts) &#123; el.style[key] = opts[key]; &#125; return el;&#125; 使用方法12345678import CopyText from './CopyText';new CopyText(&#123; text: '文本复制', success() &#123;&#125;, error() &#123;&#125;&#125;);// 可以自行判断环境是否支持copy事件CopyText.isSupported() // Boolean]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sublime Text 3 配置]]></title>
      <url>%2F2017%2F04%2Fsublime-text-3-%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[这篇博客主要讲怎么配置自己的sublime text， 安装可以去官网下载自行安装。 Package Control之后我们要安装Package Control, 既sublime的包管理工具 后面我们的包下载安装都用他。 按快捷键ctrl + ` 调出或者菜单view&gt; show Control 调出control 复制下面代码到control sublime Text 31import urllib.request,os,hashlib; h = &apos;2915d1851351e5ee549c20394736b442&apos; + &apos;8bc59f460fa1548d1514676163dafc88&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) sublime Text 21import urllib2,os,hashlib; h = &apos;df21e130d211cfc94d9b0905775a7c0f&apos; + &apos;1e3d39e33b79698005270310898eea76&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &apos;wb&apos; ).write(by) if dh == h else None; print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h) if dh != h else &apos;Please restart Sublime Text to finish installation&apos;) 复制完敲回车就可以安装，稍等片刻出现即可，安装完成后在 Preferences菜单下会出现 Package Control 选项 详细安装可看Package Control 插件打开 Package Control或按快捷键cmd/ctrl + shift + p， 输入 install package 选中第一个选项既进入安装插件的列表。 这时候可能需要等一会加载远程仓库，具体在左下角会有一个loading标识， 加载完在弹窗输入要安装的插件即可。 所有的插件都可以在https://packagecontrol.io/ 找到，下面列出比较常用的几个插件 Themesublime 编辑器虽然轻巧强大，但是默认的主题实在有点看不下去。主题可以在https://packagecontrol.io/browse/labels/theme 找自己喜欢的。目前个人使用的是 Material Theme 。 直接在install package 弹窗输入 Material Theme 选第一个即可（后面安装方法类似）。 安装完成后会弹出一个README，根据提示修改一下配置。打开Preferences &gt; settings &gt; User添加以下配置，保存即可生效12&quot;color_scheme&quot;: &quot;Packages/Material Theme/schemes/Material-Theme.tmTheme&quot;,&quot;theme&quot;: &quot;Material-Theme.sublime-theme&quot;, Material Theme 个人比较喜欢的主题还有 ayu Agila Theme Emmet前端工程师使用sublime编辑的必备插件，可以极大提高开发效率。最简单的应用就是在空白的.html页面输入!再按 tab键会自动生成html5基本页面解构。还有基本如 #div1&gt;span.child{这是子级}*2+button.name[disabled]{按钮}快捷语法等具体看emmet, Emmet-package SideBarEnhancementssublime 自带的侧边栏文件（夹）功能特别少，这个插件可以为其添加很多其他功能。docs BracketHighlighter前后标签高亮的插件，如[], (), {}, &quot;&quot;, &#39;&#39;, &lt;tag&gt;&lt;/tag&gt;等，可以比较方便看清代码块的起始点。docs AutoFileName按照路径提示该路径目录下的文件名，对于引入文件资源等很有帮助 All AutoComplete让代码自动完成的匹配从所有打开的文件里去匹配，而不是只在当前文件里匹配。 HTML-CSS-JS Prettifyhtml, css, js &amp;&amp; Json 的格式化插件。需要本地安装了node。默认格式化快捷键为ctrl+shift+h END基本上比较通用的插件就这些，可以发现这些插件基本上都在package Control前十位。学会举一反三，工作中用到的另一些插件再上https://packagecontrol.io/ 搜索关键字安装如 git, less, vuejs等等。 最后附上自己的配置12345678910111213141516&#123; "color_scheme": "Packages/Material Theme/schemes/Material-Theme-Lighter.tmTheme", "ignored_packages": [ "Vintage" ], "always_show_minimap_viewport": true, "theme": "Material-Theme-Lighter.sublime-theme", "word_wrap":true, "wrap_width": 120, "font_size": 10, "line_padding_bottom": 2, "line_padding_top": 2, "highlight_line":true, "font_face": "Monaco"&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Chrome插件开发]]></title>
      <url>%2F2017%2F04%2Fchrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[先放上入门的英语文档https://developer.chrome.com/extensions/getstarted 后面的教程是参照文档学习的。 新建配置文件首先创建一个manifest.json 用于整个项目的配置文件， 类似平时 js 的 package.json。 包含了项目的版本号， 项目名（扩展插件名）， 描述等。 12345678910111213141516171819202122232425262728293031&#123; "manifest_version": 2, "name": "Getting started example", "description": "This extension shows a Google Image search result for the current page", "version": "1.0", "browser_action": &#123; "default_icon": "icon.png", "default_popup": "popup.html" &#125;, "permissions": [ "activeTab", "https://ajax.googleapis.com/" ]&#125;&#123; "manifest_version": 2, // 版本号 "name": "Getting started example", // 项目名 "description": "This extension shows a Google Image search result for the current page", // 描述 "version": "1.0", // 项目版本号 "browser_action": &#123; "default_icon": "icon.png", // 默认icon "default_popup": "popup.html" // 默认弹窗 &#125;, "permissions": [ "activeTab", // "https://ajax.googleapis.com/" ]&#125; 资源文件在配置文件中我们定义了一个 default_icon 和 default_popup， 现在让我们来创建他们。 default_icondefault_icon 指向的是用于显示在工具栏的图标 可以选自己喜欢的图片，不过要选取 19px 的 .png文件。 可以用google提供的例子 icon.png popup.htmlpopup.html用于用户点击时弹出的一个操作框。为html 文件 所以你可以自己捣鼓自己想显示的东西。 可以用google提供的例子 popup.html 主要的逻辑以外部js的格式独立写在一个js文件里。 popup.js 现在你的文件夹里应该有四个文件: icon.png popup.html popup.js manifest.json 这些完成之后，我们接下来就在chrome加载我们的插件 加载插件调试chrome 访问 chrome://extensions 或手动从菜单进入 扩展程序 打开右上角的开发者模式 如果电脑没有装chrome….趁早装一个 点击加载已压缩的扩展程序，即可看到自己编写的第一个Hello Chrome 扩展插件此时双击审查代码可以调试写的插件。 附上后续学习链接https://developer.chrome.com/extensions]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Animate-Text]]></title>
      <url>%2F2017%2F04%2Fanimate-text%2F</url>
      <content type="text"><![CDATA[animate-text文字动画和数字动画 animate text查看DEMO git仓库 轻巧的文字动画库, 使用简单, 文件大小4k可以给文字添加出现动画, 支持字符串打字效果和数字变化效果, 支持监听动画结束事件 项原项目地址, 这里对其代码改造优化。 使用方法12345678910111213141516import AnimateText from './animate-text'// 最简单的使用方法new AnimateText('.text')// 如果需要定义动画时间可以这样初始化new AnimateText('.text', 1000)// 如果还有其它设置 请这样写new AnimateText('.text', &#123; time: 1000, // 动画时长 isNumber: true, // 是否渲染为数字动画 startNumber: 0, // 渲染为数字动画时 动画的开始数字 changeCount: 32, // 数字动画数字变化次数 onAnimated: function () &#123;console.log('动画结束')&#125; // 动画结束事件回调&#125;) 参数说明AnimateText接收两个参数, 例如: new AnimateText(element, options) 参数 类型 是否必填 描述 element String or Object 是 可以是选择器或者dom节点对象(请保证这个节点内只有文本而没有其它节点) options Number or Object 否 如果第二个参数是数字, 则当作动画时间处理, 如果有其他参数, 以对象格式传递, 具体每个属性的描述请看下方的 options说明 options说明第二个参数options详细说明 参数 类型 默认值 是否必填 描述 time Number 500 否 动画持续的时间 isNumber Boolean false 否 是否渲染为数字动画 startNumber Number 0 否 数字动画的开始数字 changeCount Number 32 否 数字动画变化次数 也就是数字经过多少次跳动才变为最终数字 onAnimated Function null 否 动画结束监听函数 实例对象方法说明1234567// 实例化var animateText = new AnimateText('.text')// 实例化对象后 对象提供play方法重新播放动画// 接受参数作为动画时间// 不传递参数则使用实例化的时间animateText.play(1000)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-第三方服务集成]]></title>
      <url>%2F2017%2F04%2F%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90%2F</url>
      <content type="text"><![CDATA[静态站点拥有一定的局限性，因此我们需要借助于第三方服务来扩展站点的功能。 以下是 NexT 目前支持的第三方服务，你可以根据你的需求集成一些功能进来。 评论系统NexT 支持多款评论系统。如需取消某个 页面/文章 的评论，在 md 文件的 front-matter 中增加 comments: false 暂没开评论，多说准备下架。 站内搜索本站用 Hexo 提供的 Local Search， 原理是通过hexo-generator-search插件在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。 安装安装 hexo-generator-search1$ npm install hexo-generator-search 安装 hexo-generator-searchdb1$ npm install hexo-generator-searchdb --save 修改站点配置编辑 站点配置 根目录下的_config.yml.12345search: path: search.xml field: post format: html limit: 10000 站内搜索原文教程-EZLippi-浮生志]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Next-主题设置]]></title>
      <url>%2F2017%2F04%2Fnext-%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[下面的主题配置指的是 themes&gt;Next&gt;_config.yml, 站点配置指的是根目录下的_config.yml; 添加[标签]页面新建「标签」页面，并在菜单中显示「标签」链接。「标签」页面将展示站点的所有标签，若你的所有文章都未包含标签，此页面将是空的。 底下代码是一篇包含标签的文章的例子： 12345title: 标签测试文章tags: - Testing - Another Tag--- 新建tags页面使用hexo new page tags 新建一个页面，命名为tags:12$ cd you-hexo-site$ hexo new page tags 设置新建的tags页面类型，改为tags123456---title: tagsdate: 2017-04-03 11:35:36type: "tags"comments: false # tags页面自定义是否要开启评论（前提你已经集成了评论）--- 修改主题配置文件，把tag添加到menu中1234menu: home: / archives: /archives tags: /tags 添加[分类]页面新建「分类」页面，并在菜单中显示「分类」链接。「分类」页面将展示站点的所有分类，若你的所有文章都未包含分类，此页面将是空的。 底下代码是一篇包含分类的文章的例子： 123title: 分类测试文章categories: Testing--- 分类和标签的区别详见Hexo的分类与标签文档 新建页面在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 categories ：1234567891011$ cd your-hexo-site$ hexo new page categories``` #### 设置页面类型编辑刚新建的页面，将页面的 `type` 设置为 `categories` ，主题将自动为这个页面显示分类。页面内容如下：```ymltitle: 分类date: 2014-12-22 12:39:04type: "categories"--- 修改菜单在菜单中添加链接。编辑 主题配置文件 ， 添加 categories 到 menu 中，如下:1234menu: home: / archives: /archives categories: /categories 设置字体Next提供了5个特定范围的字体设定 全局字体：定义的字体将在全站范围使用 标题字体：文章内标题的字体（h1, h2, h3, h4, h5, h6） 文章字体：文章所使用的字体 Logo字体：Logo 所使用的字体 代码字体： 代码块所使用的字体 该配置中的 external 可以用来控制是否使用外链字体库。 开放此属性方便你设定那些已经安装在系统中的字体，减少不必要的请求（请求大小）。 设置代码高亮主题NexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是 白色的 normal 主题，可选的值有 normal，night， night blue， night bright， night eighties：可以自行更改 highlight_theme 字段， 设置成你自己喜欢的高亮主题。 侧边栏社交链接侧栏社交链接的修改包含两个部分，第一是链接，第二是链接图标。 两者配置均在 主题配置文件 中。 设置链接在 主题配置 中找到 social字段， 其格式为 显示文本: 链接地址。 scoial123social: Github: https://github.com/jsonz1993 微博: http://weibo.com/u/1638841204 设置图标在 主题配置 中找到 social_icons字段， 其格式为 匹配键: Font Awesome 图标名称。enable 为是否显示图标控制。 注意此时的匹配建要与 social的键一致,图标依旧是Font Awesome图标 站点建立时间这个时间将在站点的底部显示，例如 © 2013 - 2015。 编辑 主题配置文件，新增字段 since。 1since: 2013 设置「动画效果」NexT 默认开启动画效果，效果使用 JavaScript 编写，因此需要等待 JavaScript 脚本完全加载完毕后才会显示内容。 如果您比较在乎速度，可以将设置此字段的值为 false 来关闭动画。编辑 主题配置文件， 搜索 use_motion，根据您的需求设置值为 true 或者 false 即可：1use_motion: true # 开启动画 设置「背景动画」NexT 自带两种背景动画效果 编辑 主题配置文件， 搜索 canvas_nest 或 three_waves，根据您的需求设置值为 true 或者 false 即可：只能同时开启一种背景效果， 建议酌情开启，会影响电脑网页性能(macbook pro或笔记本容易出现过热现象).12canvas_nest: false //关闭动画three_waves: true //开启动画]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello Next]]></title>
      <url>%2F2017%2F04%2Fhellp-next%2F</url>
      <content type="text"><![CDATA[next 入门配置 主题安装下面Next下的_config称主题配置， 根目录Hexo的_config称站点配置 安装next 到目录 themes/next:注意安装完themes下应该有一个 next 文件夹1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启动主题修改 站点配置:1theme: next 验证主题先清除缓存再启动服务，启动完成后打开 http://localhost:4000/1$ hexo clean &amp;&amp; hexo s 主题设定选择SchemeScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。在主题配置配置中的Scheme选项。目前提供三种方案： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 目前使用的是 scheme: Mist方案 设置语言在站点配置 language 中设置 zh-Hans (简体中文)。支持的语言可在 themes/next/languages 中查看 设置菜单菜单格式为 item name: link此处只是将 url映射到对应 菜单上，若要具体显示文案需要到语言配置文件修改123456menu: home: / # 主页 categories: /categories # 分类 archives: /archives # 归档 tags: /tags # 标签 about: /about # 关于我 设置菜单图标图标可从http://fontawesome.io/选择123456789menu_icons: enable: true # 是否显示图标 # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 设置侧栏 设置侧栏位置：主题配置 修改 sidebar.position 的值，支持 left &amp; right但目前只有Pisces Scheme支持该设置 设置侧栏显示的时机主题配置 修改 sidebar.display，目前支持的有： post 默认行文，文展页面自动展开 首页等不自动展开 always 所有页面都自动展开 hide 所有页面都隐藏，可以手动展开 remove 完全移除 设置头像主题配置 修改 avatar字段。支持互联网URI 如 https://www.img.com/img.jpg或站内地址 /images/avatar.jpg 集成第三方服务百度统计 登录百度统计， 定位到站点的代码获取页面 复制 hm.js? 后面那串统计脚本 id，如:hm.src = &quot;https://hm.baidu.com/hm.js?dksjklsajdlkasjkl&quot;;则id = dksjklsajdlkasjkl 修改主题配置 baidu_analytics 字段，改为上述id 骚等一段时间后可以自行登录百度统计查看PV,UV等数据。 文章阅读量统计为Next主题添加文章阅读量]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-辅助函数]]></title>
      <url>%2F2017%2F04%2Fhexo-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[主要用于模板中辅助的函数，如 date(Date, &#39;YYYY-DD-MM&#39;) 详见https://hexo.io/zh-cn/docs/helpers.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-变量]]></title>
      <url>%2F2017%2F04%2Fhexo-%E5%8F%98%E9%87%8F%2F</url>
      <content type="text"><![CDATA[变量主要用于 layout 等的应用 全局变量 变量 描述 site 网站变量 page 针对该页面的内容以及 front-matter 所设定的变量。 config 网站配置 theme 主题配置。继承自网站配置。 _ (单下划线) Lodash 函数库 path 当前页面的路径（不含根路径） url 当前页面的完整网址 env 环境变量 网站变量 变量 描述 site.posts 所有文章 site.pages 所有分页 site.categories 所有分类 site.tags 所有标签 页面变量页面page 变量 描述 page.title 页面标题 page.date 页面建立日期（Moment.js 对象） page.updated 页面更新日期（Moment.js 对象） page.comments 留言是否开启 page.layout 布局名称 page.content 页面的完整内容 page.excerpt 页面摘要 page.more 除了页面摘要的其余内容 page.source 页面原始路径 page.full_source 页面的完整原始路径 page.path 页面网址（不含根路径）。我们通常在主题 中使用 url_for(page.path)。 page.permalink 页面的完整网址 page.prev 上一个页面。如果此为第一个页面则为 null。 page.next 下一个页面。如果此为最后一个页面则为 null。 page.raw 文章的原始内容 page.photos 文章的照片（用于相簿） page.link 文章的外部链接（用于链接文章） 文章post与page类似 但是添加了下列变量 变量 描述 page.published 如果该文章已发布则为True page.categories 该文章的所有分类 page.tags 该文章的所有标签 首页 index 变量 描述 page.per_page 每页显示的文章数量 page.total 总文章数 page.current 目前页数 page.current_url 目前分页的网址 page.posts 本页文章 page.prev 上一页的页数。如果此页是第一页的话则为 0。 page.prev_link 上一页的网址。如果此页是第一页的话则为 ‘’。 page.next 下一页的页数。如果此页是最后一页的话则为 0。 page.next_link 下一页的网址。如果此页是最后一页的话则为 ‘’。 page.path 当前页面的路径（不含根目录）。我们通常在主题中使用 url_for(page.path)。 归档 (archive)与 index 布局相同， 但新增了以下变量 变量 描述 page.archive 等于 true page.year 年份归档 (4位) page.month 月份归档 (没有前导零的2位数) 分类 (category)与 index 布局相同， 但新增了以下变量 变量 描述 page.category 分类名称 标签(tag)与 index 布局相同， 但新增了以下变量 变量 描述 page.tag 标签名称]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-模板]]></title>
      <url>%2F2017%2F04%2Fhexo-%E6%A8%A1%E6%9D%BF%2F</url>
      <content type="text"><![CDATA[模板决定了网站内容的呈现方式，每个主题至少都应包含一个 index 模板，以下是各页面相对应的模板名称： 模板 用途 回调 index 首页 post 文章 index page 分页 index archive 归档 index category 分类归档 archive tag 标签归档 archive 布局 Layout布局这块可参考 next 主题看, Hexo 默认的引擎模板为swig 如果页面结构类似，例如两个模板都有页首（Header）和页脚（Footer），您可考虑通过「布局」让两个模板共享相同的结构。一个布局文件必须要能显示 body 变量的内容，如此一来模板的内容才会被显示，举例来说： index.ejs1index layout.ejs1234&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt;&lt;%- body %&gt;&lt;/body&gt;&lt;/html&gt; 生成1234&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt;index&lt;/body&gt;&lt;/html&gt; 每个模板都默认使用 layout 布局，您可在 front-matter 指定其他布局，或是设为 false 来关闭布局功能，您甚至可在布局中再使用其他布局来建立嵌套布局。 局部模板 Partial局部模板让您在不同模板之间共享相同的组件，例如页首（Header）、页脚（Footer）或侧边栏（Sidebar）等，可利用局部模板功能分割为个别文件，让维护更加便利。 官网说的都是ejs语法， 目前next采用的是swig 语法。 TODO 后面再补上 Next主题学习 &amp;&amp; swig]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-主题概述]]></title>
      <url>%2F2017%2F04%2Fhexo-%E4%B8%BB%E9%A2%98%E6%A6%82%E8%BF%B0%2F</url>
      <content type="text"><![CDATA[了解一款主题的文件结构可以让你在有自定义需求的时候，快速定位到目标文件，也为后面的定制化主题做铺垫。 创建 Hexo 主题非常容易，您只要在 themes 文件夹内，新增一个任意名称的文件夹，并修改 _config.yml 内的 theme 设定，即可切换主题。一个主题可能会有以下的结构： 123456.├── _config.yml├── languages├── layout├── scripts└── source _config.yml主题的配置文件。修改时会自动更新，无需重启服务器。 languages语言文件夹。请参见 国际化 (i18n)。 layout布局文件夹。用于存放主题的模板文件，决定了网站内容的呈现方式，Hexo 内建 Swig 模板引擎，您可以另外安装插件来获得 EJS、Haml 或 Jade 支持，Hexo 根据模板文件的扩展名来决定所使用的模板引擎，例如：12layout.ejs - 使用 EJSlayout.swig - 使用 Swig 详细见 模板 scripts脚本文件夹。在启动时，Hexo 会载入此文件夹内的 JavaScript 文件，详细见 插件 。 source资源文件夹，除了模板以外的 Asset，例如 CSS、JavaScript 文件等，都应该放在这个文件夹中。文件或文件夹开头名称为 _（下划线线）或隐藏的文件会被忽略。 如果文件可以被渲染的话，会经过解析然后储存到 public 文件夹，否则会直接拷贝到 public 文件夹 发布（略）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-永久链接]]></title>
      <url>%2F2017%2F04%2Fhexo-%E6%B0%B8%E4%B9%85%E9%93%BE%E6%8E%A5%2F</url>
      <content type="text"><![CDATA[你可以在_config.yml &gt; permalink配置网站的永久链接或者每篇文章的Front-matter自定义该文章的永久链接, 如: :year/:month/:title/ 对应 2017/04/hexo-永久链接/ 变量除了下列变量外，您还可使用 Front-matter 中的所有属性。 变量 描述 :year 文章的发表年份（4 位数） :month 文章的发表月份（2 位数） :i_month 文章的发表月份（去掉开头的零） :day 文章的发表日期 (2 位数) :i_day 文章的发表日期（去掉开头的零） :title 文件名称 :id 文章 ID :category 分类。如果文章没有分类，则是 default_category 配置信息。 也可以在 permalink_defaults 参数下调整永久链接中各变量的默认值：12permalink_defaults: lang: en]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-生成文件与部署]]></title>
      <url>%2F2017%2F04%2F%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6%E4%B8%8E%E9%83%A8%E7%BD%B2%2F</url>
      <content type="text"><![CDATA[生成文件生成文件一般是用于生成静态资源文件部署服务器用的 12345$ hexo generate快捷方式为:$hexo g 也可以让Hexo在监视到文件变动后立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。1$ hexo generate --watch 一般会跑以下命令，方便在Hexo生成文件后直接部署到Github上123456789$ hexo generate --deploy$ hexo deploy --generate(上面两条命令效果一样)或者简写$ hexo g -d$ hexo d -g(上面两条命令效果一样) 部署服务器在部署之前先要在 _config.yml 将部署信息补充完整，此处以 Github 为例: _config.yml配置12345deploy: type: git # type repo: https://github.com/jsonz1993/jsonz1993.github.io.git # 仓库地址 branch: master # 分支 可不填自动识别 message: "feat(hexo)-生成文件与部署" # 提交的信息 参数说明123repo 库（Repository）地址branch 分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。message 自定义提交信息 (默认为 Site updated: &#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125;) 确保本地安装了 hexo-deployer-git， 可通过以下方法安装1$ npm install hexo-deployer-git --save 你也可以通过 generate 生成静态资源，再手动copy或上传到服务器.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-本地服务器]]></title>
      <url>%2F2017%2F04%2F%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
      <content type="text"><![CDATA[一般安装hexo时会自动安装服务器，如果本地没有安装hexo服务器可通过以下命令安装：1$ npm install hexo-server --save 安装完成后，启动服务器，会启动一个（默认4000端口）本地服务器，可通过 http://localhost:4000 访问，Hexo会监视文件变动自动更新，如果是改动配置，需要手动重启服务：1$ hexo server 缩写1$ hexo s 如果您想要更改端口，或是在执行时遇到了 EADDRINUSE 错误，可以在执行时使用 -p 选项指定其他端口，如下：1$ hexo server -p 5000 自定义IP服务器默认运行在 0.0.0.0，您可以覆盖默认的 IP 设置，如下：1$ hexo server -i 192.168.1.1 指定这个参数后，您就只能通过该IP才能访问站点。例如，对于一台使用无线网络的笔记本电脑，除了指向本机的127.0.0.1外，通常还有一个192.168.*.*的局域网IP，如果像上面那样使用-i参数，就不能用127.0.0.1来访问站点了。对于有公网IP的主机，如果您指定一个局域网IP作为-i参数的值，那么就无法通过公网来访问站点。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-资源文件夹与数据文件夹]]></title>
      <url>%2F2017%2F04%2F%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%A4%B9%2F</url>
      <content type="text"><![CDATA[资源文件资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 ![](/images/image.jpg) 的方法访问它们。 文章资源文件夹可以通过设置 _config.yml 来使生成的每个文章都有对应的静态资源文件夹。 _config.yml1post_asset_folder: true 数据文件有时您可能需要在主题中使用某些资料，而这些资料并不在文章内，并且是需要重复使用的，那么您可以考虑使用 Hexo 3.0 新增的「数据文件」功能。此功能会载入 source/_data 内的 YAML 或 JSON 文件，如此一来您便能在网站中复用这些文件了。 举例来说，在 source/_data 文件夹中新建 menu.yml 文件： 123Home: /Gallery: /gallery/Archives: /archives/ 您就能在模板中使用这些资料： 123&#123;% for link in site.data.menu %&#125; &lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot;&gt;&#123;&#123; loop.key &#125;&#125;&lt;/a&gt;&#123;% endfor %&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tag Plugins]]></title>
      <url>%2F2017%2F04%2Ftag-plugins%2F</url>
      <content type="text"><![CDATA[tag plugins 用于在文章中快速插入特定内容的插件,下面列出常用几种 具体参见https://hexo.io/zh-cn/docs/tag-plugins.html 引用快在文章中插入引言，可包含作者、来源和标题。123&#123;% blockquote @Jsonz http://weibo.com/u/1638841204 %&#125;引用内容&#123;% endblockquote %&#125; 引用内容 @Jsonzweibo.com/u/1638841204 代码块样式可以在 themes&gt;next&gt;source&gt;css修改[language] [title] [url] [link text] code snippet 这是标题,Jsonz's Github1234const a = ()=&gt; &#123; [..."123"].forEach(item=&gt; ++item); return &#123;&#125;;&#125; iframe1&#123;% iframe url [width] [height] %&#125; image插入指定大小图片 1&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello Hexo]]></title>
      <url>%2F2017%2F04%2Fhello-hexo%2F</url>
      <content type="text"><![CDATA[折腾了一晚上终于把搭好自己喜欢的主题的Hexo博客。接下来一步一步配置 Hexo __config.yml 文件Hexo 官网配置项 一步一步跟着改配置，比较麻烦的是每次修改配置都要hexo s 重启一下服务器看效果如果修改配置后重启服务看不到效果，可以先运行hexo clean清除缓存再重启服务 Site 网站123456title: jsonz1993 # 网站标题，也会显示在该主题导航左上角subtitle: # 网站副标题 会生成在导航栏主标题旁边（这里隐藏了）description: 前端开发 Jsonz 张欣欣 # 网站描述，会出现在head，侧边菜单上 主要用做SEOauthor: Jsonz # 博客作者 Your Namelanguage: zh-Hans # 语言，支持的语言可以在themes&gt;your-thems&gt;languages 找到timezone: # 默认使用电脑的时区，一般不填 URL 网址123456url: https://jsonz1993.github.io/root: /# 文章永久链接的格式 [https://hexo.io/zh-cn/docs/permalinks.html]# 可以使用的变量有[:year, :month, :day, :title, :id, :category, Front-matter所有属性]permalink: :year/:month/:day/:title/ permalink_defaults: # 可以给变量指定默认值 Directory 目录123456789# 定义文件目录, 这部分一般用默认的就可以source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render: Writing 文章相关配置123456789101112131415161718# 新文章的名称 我喜欢配合年月按文件夹分类，这样后面方便管理# 此时生成的文件位于: source/_posts/:year/:month/:title.mdnew_post_name: :year/:month/:title.md default_layout: post #命令行 hexo new &lt;layout&gt; name 中 layout默认值titlecase: false # 标题转换为首字母大写external_link: true # 是否在新标签打开连接filename_case: 0 # 文件名大小写转换 (0)不转换（1)小写 (2)大写render_drafts: false # 显示草稿# 启动资源文件夹 看个人可用可不用# 主要每次创建文件都会生成一个同名文件夹用于存放图片等资源post_asset_folder: truerelative_link: false # 把链接改为与根目录的相对位址future: true # 显示下一条文章highlight: # 代码块设置 既现在看到的这块 enable: true line_number: true auto_detect: false tab_replace: Category &amp; Tag 分类&amp;标签123default_category: uncategorized # 默认的分类category_map: # 分类映射（别名）tag_map: # 标签映射（别名） Date / Time format 日期&amp;时间格式12date_format: YYYY-MM-DDtime_format: HH:mm:ss Pagination 分页设置123# 文章数量有限，未实践过该功能per_page: 10 # 每页文章数量 0 为关闭分页pagination_dir: page # 分页的目录 Extensions 其他拓展设置12# 此处有插件与主题设置theme: next #设置的主题应存放在 根目录/themes下 将草稿转为文章1hexo publish [layout] &lt;filename&gt;]]></content>
    </entry>

    
  
  
</search>
