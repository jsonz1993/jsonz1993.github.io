<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[react全家桶 + dva 实践整理总结]]></title>
      <url>%2F2018%2F02%2Freact%E5%85%A8%E5%AE%B6%E6%A1%B6-dva-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[项目背景最近接手组内一个前端大牛的项目，大概理清了里面的总理逻辑与数据流向等， 写个总结 方便以后可以查阅参考。 在之前做的后台管理平台里面，就有用到 dva+antd， 到后面直接用 antd-pro 重新整合了一遍，不得不说 antd-pro 真的是开箱即用 优雅粗暴。 但是里面可能很多和我们平时使用习惯有所不同， 所以这次接触的项目是基于 dva 自己再重组了一下 model router 目录结构等。 使得页面更加的模块化，既 models, routes 不是在一个文件目录里，而是直接按照页面级别来组合。有一个好处就是 本来 models,routes 这些几乎就是不能公用的，那直接按着页面去分 方便问题定位与维护。 目录结构12345678910111213141516171819202122232425262728293031323334353637.├── README.md├── config # 一些关于 webpack babel dll 等项目构件的配置│ ├── babel-plugin-wrap-source.js│ ├── babel-plugin-wrap.js│ ├── build.log│ ├── dist.js│ ├── dll│ ├── server.js│ ├── ssr-middleware.js│ ├── theme.config.js│ ├── webpack.config.common.js│ ├── webpack.config.dll.js│ └── webpack.config.prod.js├── dist # 打包好的文件│ ├── css│ ├── index.html│ └── js├── package-lock.json├── package.json├── src│ ├── assets # 放一些静态资源，如 全局一些 less 文件等│ ├── common # 公共文件， 如 config request utils 等│ ├── components # 通用组件, 如 editor loading 等，用了 antd 之后，这个文件夹的文件较少│ ├── index-ssr.js│ ├── index.js # 项目入口文件│ ├── mock # mock文件│ ├── modules # 业务页面文件夹 代码的绝大部分放在此处│ └── activity # 业务页面 每个业务页面起一个文件夹│ ├── index.js # 当前页面的路由及动态加载文件的配置文件│ ├── model.js # 当前页面的 dva model│ ├── businessUtil.js # │ └── view # 当前页面的 view 文件│ └── index.js│ ├── router.js # 总路由入口│ └── services # 后台接口服务└── webpack.config.js # webpack 配置 项目剖析index.js和其他项目一样 index.js 处理的东西很简单 进行一些关于 dva 的配置初始化 加载配置app model require(modules/app/model) 加载配置app router require(&#39;./router&#39;).default &amp;&amp;&amp;&amp;&amp;&amp;&amp; 启动应用 这里就引出两个分支， model &amp;&amp; router 前端架构中比较关心的两个。 router 管理在 router.js 里面 定义了主 Component 与默认 url router.childRoutes 也是使用模块的方式，只引用了几个大模块，如 require(&#39;modules/activity&#39;)(app), 1234567891011121314151617const Routers = function (&#123; history, app &#125;) &#123; const routes = getRoutes(app); return &lt;Router history=&#123;history&#125; routes=&#123;routes&#125; render=&#123;applyRouterMiddleware(useScroll())&#125; /&gt;;&#125;;function getRoutes(app) &#123; return [ &#123; path: '/', component: App, childRoutes: [ require('modules/activity')(app), ], &#125;, ];&#125; 在 modules/activity/index.js 再去加载构建他的子级路由 1234567891011121314export default app=&gt;(&#123; path: 'url', getComponent (nextState, cb) &#123; require.ensure([], (require) =&gt; &#123; app.model(require('./model')); // 加载当前模块的model cb(null, require('./view')); // 记载当前模块的view &#125;, '模块名'); &#125;, childRoutes:[ require('modules/child1')(app), require('modules/child2')(app) ], ...其他配置&#125;) 就这样一层一层的构建自己的路由， 根据页面去配置也可以更加的细腻可控。不会写成长长的一坨。 modelmodel层用的是 dva 那套， 帮我们整合了 redux, redux-sage and react-router 十分超级好用。 这里只是把目录结构也调整为 页面级别里面，与页面的 路由配置同级。 也是出于更好的定位问题与维护。 一般与model 相关的文件还有各个页面级别文件夹（即modules/activity)里面的 businessUtil.js 文件。 这个文件主要用来辅助处理一些和 model 有关的事情，一般会有三个方法 export { getInitState, convertProps2Params, convertParams2Props }。 分别处理 初始化state, server 端数据与组件 props 之间的差异转换。 mock 数据mock 数据，用了 dva 自带的那套。 我们平时写接口的时候，会在 services/ 下面起一个文件 里面带有某个接口地址 用来请求数据接口的然后在 mock/ 下面也会起一个文件 相同的也会带有一个接口地址这样我们如果这个接口地址改变，岂不是要改两个地方？ 为此，我们在 services/ 下面的文件，只是简单的写了一些原始数据，如 url, method 等 services/feature1123456//@wrapFunction: common/request// @1 上面那行注释是干什么用的呢？export default &#123; url:'api/feature1', method:'POST'&#125; 这样在 mock/ 下面就可以直接引入 services/feature1 就可以拿到相同的url， 接口地址改动的话也只需要改动 services 下的文件。 但是如果只是简单的返回一些原始数据，那和一个 config 文件有何区别，这样完全没有放在 services 下面的必要啊。。。 所以我们用了一行注释来做一些操作 大概的原理是 写了一个 babel 插件，用来处理一些操作。如果匹配到 //@wrapFunction: 则用后面的链接 require 一个方法来包着页面上的代码。 这样就能起到，前端跑代码的时候 feature1 是一个接口功能的文件， mock 的时候是一个单纯的数据输出文件. babel 插件自动处理 services/*.js在上面一小节讲到我们用 babel插件来处理差异化，这里我们具体讲一下是怎么处理的 因为项目用的是 roadhog 搭建的， 所以我们在 .roadhogrc.js 里面配置一下 babel 插件，引进自己插件的文件。 这里我们的插件放置在 /config/babel-plugin-wrap.js; 在 services/*.js 里面添加一行注释代码用作 babel 识别的标识 判断页面上有无对应注释 获取注释与目标路径， 把export default 的输出用函数调用表达式替换掉 具体的 babel插件编写方式可以看官网 https://babeljs.cn/docs/plugins/ 了解编译器原理可以参考 上一篇文一步步实现极简编译器 —— 了解编译器原理 结语剩下的 dll 打包， ssr 以后有用到再去了解。emmm 最近阿里刚出了一个 umiJs 想起知乎上一个评价 用这一时爽 改起来火葬场。在用 antd-pro 的时候就深有体会了。 所以建议如果不是比较小的项目或者灵活性要求高的项目， 还是不要上 antd-pro的好。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[书单]]></title>
      <url>%2F2018%2F02%2F%E4%B9%A6%E5%8D%95%2F</url>
      <content type="text"><![CDATA[2.21 《数学之美》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一步步实现极简编译器 —— 了解编译器原理]]></title>
      <url>%2F2018%2F01%2F%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%AE%9E%E7%8E%B0%E6%9E%81%E7%AE%80%E7%BC%96%E8%AF%91%E5%99%A8-%E2%80%94%E2%80%94-%E4%BA%86%E8%A7%A3%E7%BC%96%E8%AF%91%E5%99%A8%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[welcome今天在看 babel 的时候，无意中被引到一个外链 关于编译器的优秀/简单的教程，请查看 the-super-tiny-compiler ，同时它也从宏观角度上解释了 Babel 本身是如何工作的。 觉得挺感兴趣的，加上代码也不多，就跟着思路自己理解敲了一遍。 本文主要是帮助理解编译器的原理 不做过多的其他扩展 编译器的基本组成一般简单的编译器可以由以下几部分组成: tokenizer 词法分析器 把代码或文本按类型分开，返回: tokens parser 语法剖析器 对分析后的文本按照语法分析转换成 抽象语法树 返回：ast transformer 语法转换器 把语法剖析后的抽象语法树转换成我们想要的: newAst codeGenerator 代码生成器 把AST 转换为 目标代码 babel 初始阶段并没有做任何事，基本上等于 const babel = code=&gt; code;先 tokenizer， parser 解析代码，再 transformer 的时候，完全不改动原来的 ast 接下来以最简单的编译器组成 一个环节一个环节走下去 tokenizer 词法分析器词法分析器其实可以理解为简单的将文本切割，然后将有价值的按照相邻同等类型的 文本组合一起输出。ps:无价值指对代码生成没有影响的部分，比如js里面非文本 一个空格和一百个空格对编译器来说是没有区别的 实现思路： 有一个值存着当前的光标 current 有一个数组用来存放按类型分出来的值 tokens 对文本进行循环， 取 current 的值做 分类型处理 ( ) 空格 数字 字符串 方法名 将处理后的值存进数组 token 并返回 tokenizer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778function tokenizer(input) &#123; let current = 0; const tokens = []; while (current &lt; input.length) &#123; let char = input[current]; if (char === "(" || char === ")") &#123; tokens.push(&#123; type: 'paren', value: char &#125;); current++; continue; &#125; const WHITESPACE = /\s/; if (WHITESPACE.test(char)) &#123; current++; continue; &#125; const LETTERS = /[a-z]/i; if (LETTERS.test(char)) &#123; let name = ""; while (LETTERS.test(char)) &#123; name += char; current++; char = input[current]; &#125; tokens.push(&#123; type: 'name', value: name &#125;); continue; &#125; const NUMBERS = /[0-9]/; if (NUMBERS.test(char)) &#123; let numbers = ""; while(NUMBERS.test(char)) &#123; numbers += char; current++; char = input[current]; &#125; tokens.push(&#123; type: 'number', value: numbers &#125;); continue; &#125; if (char === '"') &#123; let string = ''; current++; char = input[current]; while(char !== '"') &#123; string += char; current++; char = input[current]; &#125; tokens.push(&#123; type: 'string', value: string &#125;); current++; continue; &#125; throw new TypeError('不知道你输入的是什么鬼东西 ' + char); &#125; return tokens;&#125; 123456789101112131415const input = '(add 2 (subtract 4 2 "djwaqp"))';tokenizer(input);// 输出/*[&#123; type: 'paren', value: '(' &#125;,&#123; type: 'name', value: 'add' &#125;,&#123; type: 'number', value: '2' &#125;,&#123; type: 'paren', value: '(' &#125;,&#123; type: 'name', value: 'subtract' &#125;,&#123; type: 'number', value: '4' &#125;,&#123; type: 'number', value: '2' &#125;,&#123; type: 'string', value: 'djwaqp' &#125;,&#123; type: 'paren', value: ')' &#125;,&#123; type: 'paren', value: ')' &#125;];*/ parser语法剖析器就是把 tokens 解析，转化为抽象语法树(AST)🌲🌲🌲，方便后续的处理。 1[&#123; type: 'paren', value: '(' &#125;, ...] =&gt; &#123; type: 'Program', body: [...] &#125; 实现思路： 首先也要有一个 current 对 tokens 进行遍历，每一项 token 进行分析处理 有一棵树，顶级结构为 {type: &#39;Program&#39; , body: [...]} 根据 token.type 进行相应的归类处理: number： 直接返回 {type: &#39;NumberLiteral&#39;, value, } string： 直接返回 {type: &#39;StringLiteral&#39;, value, } paren ( ： 对下一个进行递归，直到出现 paren ) 将处理后的 ast 返回 parser12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function parser(tokens) &#123; let current = 0; const ast = &#123; type: 'Program', body: [] &#125;; function walk() &#123; let token = tokens[current]; if (token.type === 'number') &#123; current ++; return &#123; type: 'NumberLiteral', value: token.value &#125; &#125; if (token.type === 'string') &#123; current ++; return &#123; type: 'StringLiteral', value: token.value &#125; &#125; if (token.type === 'paren' &amp;&amp; token.value === '(') &#123; token = tokens[++current]; let node = &#123; type: "CallExpression", name: token.value, params: [] &#125; token = tokens[++current]; while ((token.type !== 'paren') || (token.type === 'paren' &amp;&amp; token.value !== ')')) &#123; node.params.push(walk()); token = tokens[current]; &#125; current++; return node; &#125; throw new TypeError(token.type); &#125; while(current &lt; tokens.length) &#123; ast.body.push(walk()); &#125; return ast;&#125; 12345678910111213141516171819202122232425262728293031323334353637input:[&#123; type: 'paren', value: '(' &#125;,&#123; type: 'name', value: 'add' &#125;,&#123; type: 'number', value: '2' &#125;,&#123; type: 'paren', value: '(' &#125;,&#123; type: 'name', value: 'subtract' &#125;,&#123; type: 'number', value: '4' &#125;,&#123; type: 'number', value: '2' &#125;,&#123; type: 'string', value: 'djwaqp' &#125;,&#123; type: 'paren', value: ')' &#125;,&#123; type: 'paren', value: ')' &#125;]=&gt;output:&#123; "type": "Program", "body": [&#123; "type": "CallExpression", "name": "ADD", "params": [&#123; "type": "NumberLiteral", "value": "2" &#125;, &#123; "type": "CallExpression", "name": "subtract", "params": [&#123; "type": "NumberLiteral", "value": "4" &#125;, &#123; "type": "NumberLiteral", "value": "2" &#125;, &#123; "type": "StringLiteral", "value": "djwaqp" &#125;] &#125;] &#125;]&#125; transformertransformer 顾名思义，为转换部分，最复杂 也最常用。.babelrc 添加的插件，也只是在这个环节进行操作，将原本的 ast( es6 ) 转换为目标的 newAst (es5)。 1ast &#123; type: 'Program', body: [...] &#125; =&gt; newAst &#123; type: 'Program', body: [...] &#125; 实现思路： 首先，要有一颗树，和 ast 一样。 顶级结构为 { type: &#39;Program&#39;, body: [...] } 在 ast 上建一个引用_context到 newAst.body; 对 ast 树进行处理, 直接处理 _context 对 ast 上 每个类型都做 enter 处理与 exit处理的钩子 Number 或 String 直接处理并添加到树节点上即可 CallExpression 则要创建一个数组去存参数 对类型为：Program 或 CallExpression 对子级进行 递归 4 处理 将处理后的 newAst 返回 transformer 部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495function traverser(node, visitor) &#123; function traverseArray(nodeArr, parent) &#123; nodeArr.forEach(child =&gt; traverseNode(child, parent)); &#125; function traverseNode(node, parent) &#123; const methods = visitor[node.type]; if (methods &amp;&amp; methods.enter) &#123; methods.enter(node, parent); &#125; switch (node.type) &#123; case 'Program': traverseArray(node.body, node); break; case 'CallExpression': traverseArray(node.params, node); break; case 'NumberLiteral': case 'StringLiteral': break; default: throw new TypeError(node.type); &#125; if (methods &amp;&amp; methods.exit) &#123; methods.exit(node, parent); &#125; &#125; traverseNode(node, null);&#125;function transformer(ast) &#123; const newAst = &#123; type: 'Program', body: [] &#125;; ast._context = newAst.body; traverser(ast, &#123; NumberLiteral: &#123; enter(node, parent) &#123; parent._context.push(&#123; type: 'NumberLiteral', value: node.value &#125;); &#125; &#125;, StringLiteral: &#123; enter(node, parent) &#123; parent._context.push(&#123; type: 'StringLiteral', value: node.value, &#125;); &#125; &#125;, CallExpression: &#123; enter(node, parent) &#123; let expression = &#123; type: 'CallExpression', callee: &#123; type: 'Identifier', name: node.name &#125;, arguments: [] &#125; node._context = expression.arguments; if (parent.type !== 'CallExpression') &#123; expression = &#123; type: 'ExpressionStatement', expression: expression &#125; &#125; parent._context.push(expression); &#125; &#125; &#125;); return newAst;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960input:&#123; "type": "Program", "body": [&#123; "type": "CallExpression", "name": "ADD", "params": [&#123; "type": "NumberLiteral", "value": "2" &#125;, &#123; "type": "CallExpression", "name": "subtract", "params": [&#123; "type": "NumberLiteral", "value": "4" &#125;, &#123; "type": "NumberLiteral", "value": "2" &#125;, &#123; "type": "StringLiteral", "value": "djwaqp" &#125;] &#125;] &#125;]&#125;=&gt;output:&#123; "type": "Program", "body": [&#123; "type": "ExpressionStatement", "expression": &#123; "type": "CallExpression", "callee": &#123; "type": "Identifier", "name": "ADD" &#125;, "arguments": [&#123; "type": "NumberLiteral", "value": "2" &#125;, &#123; "type": "CallExpression", "callee": &#123; "type": "Identifier", "name": "subtract" &#125;, "arguments": [&#123; "type": "NumberLiteral", "value": "4" &#125;, &#123; "type": "NumberLiteral", "value": "2" &#125;, &#123; "type": "StringLiteral", "value": "djwaqp" &#125;] &#125;] &#125; &#125;]&#125; codeGenerator最后一步就是 codeGenerator， 用 newAst 递归调用，根据 node 与一系列规则去生成一个 string。 1newAst &#123; type: 'Program', body: [...] &#125; =&gt; call(argumentsA, ...argumentsN); 实现思路： 根据 node.type 做对应逻辑： Program =&gt; 对 node.body 进行递归 ExpressionStatement=&gt; 对 node.expression 进行处理 CallExpression =&gt; 对 node.callee 与 node.arguments 进行处理 Identifier &amp;&amp; NumberLiteral &amp;&amp; StringLiteral 直接返回对应的字段 codeGenerator123456789101112131415161718192021222324function codeGenerator(node) &#123; switch (node.type) &#123; case 'Program': return node.body.map(codeGenerator).join('\n'); case 'ExpressionStatement': return codeGenerator(node.expression) + ';'; case 'CallExpression': return (codeGenerator(node.callee) +'(' + node.arguments.map(codeGenerator).join(', ') + ')'); case 'Identifier': return node.name; case 'NumberLiteral': return node.value; case 'StringLiteral': return '"' + node.value + '"'; default: throw new TypeError(node.type); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637input:&#123; "type": "Program", "body": [&#123; "type": "ExpressionStatement", "expression": &#123; "type": "CallExpression", "callee": &#123; "type": "Identifier", "name": "ADD" &#125;, "arguments": [&#123; "type": "NumberLiteral", "value": "2" &#125;, &#123; "type": "CallExpression", "callee": &#123; "type": "Identifier", "name": "subtract" &#125;, "arguments": [&#123; "type": "NumberLiteral", "value": "4" &#125;, &#123; "type": "NumberLiteral", "value": "2" &#125;, &#123; "type": "StringLiteral", "value": "djwaqp" &#125;] &#125;] &#125; &#125;]&#125;=&gt; output:add(2, subtract(4, 2, "djwaqp")); compiler至此，编译器所需的几个步骤： 词法分析，解析，转换，生成都已经完成。 compiler123456789function compiler(input) &#123; const tokens = tokenizer(input); const ast = parser(tokens); const newAst = transformer(ast); const output = codeGenerator(newAst); return output;&#125;const input = '(add 2 (subtract 4 2 "djwaqp"))';const output = compilter(input); // 'add(2, subtract(4, 2, "djwaqp"));' babelbabel 的工作原理可以理解成就是一个简单的编译器：分析 =&gt; 转换 =&gt; 生成代码 bable 的篇幅太多，下面直接给出 demo源码。具体可以看 官方插件手册 babel-handbook 我们写的babel 插件，都是在转换的部分运行自定义插件 babel-plugin-jsonz12345678910111213141516171819const t = require('babel-types');module.exports= function() &#123; // plugin contents return &#123; visitor: &#123; // visitor contents BinaryExpression(path, state) &#123; // 如果操作符不是 === 则返回 if (path.node.operator !== '===') &#123; return; &#125; // 操作符的左边替换为 sebmck, 右边替换为 dork path.node.left = t.identifier('"sebmck"'); path.node.right = t.identifier('"dork"'); &#125; &#125; &#125;;&#125;; 目标代码./src/test1.js123function demo() &#123; return 1===2;&#125; 安装相关依赖:npm i babel-cli babel-types --save-dev 运行脚本: babel src/ -d build/ 生成后的代码 ./build/test2.js123function demo() &#123; return "sebmck" === "dork";&#125; 最后再推一波关于学习中看到的好网站 源码esprima 解析语法树🌲AST Explorerast名词解释babel-plugin-handbook]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅析Promise (一)]]></title>
      <url>%2F2017%2F12%2F%E6%B5%85%E6%9E%90Promise%2F</url>
      <content type="text"><![CDATA[ppt在此源码 参照 lie背景在ES6流行之前，我们处理异步的方法一般有 事件模式， 回调模式等。 事件模式用户点击按钮或按下键盘上的按钮会触发类似 onClick这样的事件，他会向任务队列添加一个新任务来响应用户的操作。直到事件触发时才执行事件处理程序，且正常执行时上下文与定义时相同demo11234let btn = document.getElementById('btn1');btn.onclick = function(event) &#123; console.log(event);&#125; demo212345import iEvent from 'event';iEvent.on('click', function() &#123; console.log(1);&#125;)iEvent.emit('click'); 事件模型适用于处理简单的交互，如果多个独立的异步调用连接在一起会使应用变得更加复杂。而且要追踪每个事件的事件目标，比如 我先点击 btn1 再给 btn1绑定事件，或者先 emit 再 on 都会不起作用。 回调模式为Java打Call为PHP打Call为javascript打CallBack 为Go打Call… demo1123456789method1(function(data) &#123; method2(function(data) &#123; method3(function(data)) &#123; method4(function(data)) &#123; console.log('金字塔'); &#125; &#125; &#125;);&#125;); 回调模式虽然是js的一大精髓，但是写着写着可能会因为嵌套太多的回调函数，陷入回调地狱 —— 超级金字塔 而且如果要处理类似 两个操作都执行完通知你 或者有一个操作执行完就通知你 那么情况可能会变得比较麻烦 基础知识简单使用demo112345678910111213const promise = new Promise((res, rej)=&gt; &#123; setTimeout(function() &#123; const random = Math.random() if ( random&gt; .5) res(random) else rej(random) &#125;, 1000)&#125;)promise.then(val=&gt; (console.log(val), ++val)) .then(val=&gt; console.log(val)) .catch(error=&gt; console.warn(error))// 输出 random &amp;&amp; random+1 or warn(random) Promise 规范 Promise 规范有很多，如 Promise/A，Promise/B，和Promise/A升级版 =&gt; Promise/A+在这里统一一下 以下所有 resolved 都指fulfilled。 Promise 本质是一个状态机。每个 promise 只能是 3 种状态中的一种：pending、resolved 或 rejected。状态转变只能是 pending -&gt; resolved 或者 pending -&gt; rejected。状态转变不可逆。 then 方法可以被同一个 promise 调用多次。 then 方法必须返回一个 新 promise。 三个状态，状态是不可逆的可以在 chrome 控制台看到内部属性 [[PromiseStatus]] 状态值 pending： Promise的初始状态，也就是未被fulfilled或者rejected的状态。 resolved： 意味着promise代指的操作已经成功完成。 rejected：意味着promise代指的操作由于某些原因失败。 then所有的 Promise 都有 then(onResolve, onReject) 方法，接受两个参数，第一个是当Promise 状态变为 resolved 时调用的函数，与异步操作相关的值会传递给该函数第二个是当Promise 状态变为 rejected 时调用的函数，与失败状态相关（报错）会传递给该函数 then方法可以被同个promise调用多次1234const promise = new Promose(res=&gt; res(1))promise.then(val=&gt; console.log(++val))promise.then(val=&gt; console.log(++val))promise.then(val=&gt; console.log(++val)) then方法必须返回一个新的promise12345const promise = new Promise(res=&gt; res(1))const promiseA = promise.then(val=&gt; ++val)const promiseB = promiseA.then(val=&gt; ++val)const promiseC = promise.then(val=&gt; ++val)console.log( promiseA == promiseB, promiseC == promiseA, promiseB == promiseC); 因为promise每次都会返回一个新的promise 所以支持链式写法，上一个 then 的返回值会当成 下一个then的参数then链式1new Promose(res=&gt; res(1)).then(val=&gt; ++val).then(val=&gt; ++val).then(val=&gt; ++val) 错误情况 在 Promise(fn) fn执行错误 每个执行器内部都隐含一个 try...catch...块demo11234const promise = new Promise(function(res, rej) &#123; throw new Error('喵喵喵')&#125;)promise.catch(err=&gt; console.warn(err)) 以上代码等同于demo212345678const promise = new Promise(function(res, rej) &#123; try &#123; throw new Error('喵喵喵') &#125; catch(ex) &#123; rej(ex) &#125;&#125;)promise.then(null, err=&gt; console.warn(err)) 此处可以看出 promise.catch 其实是 promise.then(null, catchFn) 的一个语法糖 then 函数内部错误 demo1123const promise = new Promise(res=&gt; res(1))promise.then(val=&gt; val+val1) .catch(err=&gt; console.warn(err)) 这里可以简单的理解为 then 内部会生成一个 Promise 示例，把函数体丢到Promise 里去执行，执行完结果当成 res 方法的参数，出错则调用 rej 伪代码12345678910const promise = new Promise(res=&gt; res(1))promise.then(val=&gt; new Promise((res, rej)=&gt; &#123; try &#123; res(val + val1) &#125; catch(e) &#123; rej(e); &#125; &#125;)).catch(err=&gt; console.warn(err)) .catch &amp;&amp; then(null, catchFn) 不能对后续的报错进行捕获 123456const promise = new Promise(res=&gt; res(1))promise.then(val =&gt; ++val).catch(e=&gt; console.warn(e)).then(val=&gt; console.log(val+val1))// 此处会抛错，因为在抛出错误之后 没有一个 catch来处理这个错误 所以一般会在 Promise 的最末端添加一个 catch 对前面可能出现的问题进行处理 thenable上面说了那么多关于 then 的使用，其实只要实现了上述 then 功能的对象都可以叫 thenable。所有的 Promise 都是 thenable 但是不一定所有有then 方法的对象都叫 thenable。12345var thenable = &#123; then: function(res, rej) &#123; res(1) &#125;&#125; 至于 thenable 有什么用 请往下看 resolve上述说到的 Promise 用法，都是 创建一个未完成状态，执行一些操作之后才从 pending 转变为 resolved 或 rejected那么可以直接创建一个完成状态的 Promise 吗？ 这里就要用到 静态方法上面的 resolve。 Promise.resolve(promise); Promise.resolve(thenable); Promise.resolve(object); 参数为 promise 时，返回的也是该promisedemo1123const promise = new Promise(()=&gt; &#123;&#125;)const promiseA = Promise.resolve(promise)promise === promiseA 参数为thenable 时，返回标准的promise对象，这个对象有then方法这里是 resolve 方法用的最多的地方了平时工作用到最多的 thenable 恐怕就是 jQ 或 zepto 的 ajax那么我们如果要把他转为标准的 promise 怎么办呢？ 比如 zepto 的 ajax 返回的就没有 .catche 方法，而是 .fail 这里如果有必要 我们可以做一层封装，把他转变为标准的格式 拥抱未来！！！demo21234const ajax = $.ajax(&#123; url, data &#125;)Promise.resolve(ajax) .then(response=&gt; &#123;&#125;) .catch(err=&gt; console.warn(err)) 参数是其他值的情况，会返回一个状态为 resolved 的 promise。终值为传入的值demo312Promise.resolve(&#123;name: "Jsonz"&#125;) .then(val=&gt; console.log("帅哥是 " + val)) rejectPromise.reject 用法与 Promise.resolve 类似 这里不再赘述 多个情况处理开头的时候说了，如果要处理两个及以上的异步操作： 多个都完成时通知你 有一个完成时通知你那么回调就显得很尴尬，这里 Promise 提供了两个方法来满足你这种小需求 all业务上经常会有情况是 要等a接口与b接口的数据一起回来才做操作 那么可以用到静态方法 Promise.all Promise.all 会接受一个 Array 类似的参数，里面是Promise 类型， 返回一个新的Promise 这里取名 PromiseAll当所有的Promise 都变成 resolved 时，会将 PromiseAll 的状态改为 resolved 参数为每个 promise 的终值如果有一个Promise 为 rejected， 那么 PromiseAll 会直接变为 rejected 状态 参数为 首个变为 rejected 状态的错误信息 demo1123456789101112const p1 = new Promise(res=&gt; res(1))const p2 = new Promise(res=&gt; res(2))const p3 = new Promise((res, rej)=&gt; rej(2))const p4 = Promise.all([p1, p2]);p4.then(val=&gt; &#123; console.log(Array.isArray(val)) val.forEach(item=&gt; console.log(item))&#125;)const p5 = Promise.all([p1, p3])p5.then(v=&gt; console.log(v), err=&gt; console.log(err)) racePromise.race 对应的是 有一个完成时通知你 这种状态，用法与参数与 all 类似但是 Promise.race 的参数为第一个转为 resolved 状态的终值 继承Promise改造如果我们要对原生的 Promise 进行改造，比如添加 success() 或 failure() 方法，那么我们可以直接继承他创建一个新的 JsonzPromise12345678910class JsonzPromise extends Promise &#123; success(resolve, reject) &#123; return this.then(resolve, reject) &#125; failure(reject) &#123; return this.catch(reject) &#125;&#125;new JsonzPromise((res, rej)=&gt; res(1)) .success(val=&gt; console.log(val)); 全局的rejected状态处理123456window.onunhandledrejection = function(e) &#123; console.log(e)&#125;window.onrejectionhandled = function(e) &#123; console.log(e)&#125; node 则是在 process 绑定监听氮素！！！！ 不知道为何还没跑过成功的demo…. 后记emmmmmm 贴出一些比较好的教程吧 深入理解ES6 - Promise 篇章](https://www.amazon.cn/dp/B071GW3JDP/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1514389776&amp;sr=1-1&amp;keywords=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3es6)javascript - Promise 迷你书 Promise/A+ 规范中文 第二期实现自己的 Promise 参考1 参考2 参考3 参考4]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[http与https杂谈]]></title>
      <url>%2F2017%2F12%2Fhttp%E4%B8%8Ehttps%E6%9D%82%E8%B0%88%2F</url>
      <content type="text"><![CDATA[http &amp;&amp; https https://www.zhihu.com/question/19577317 http://www.alloyteam.com/2016/07/httphttp2-0spdyhttps-reading-this-is-enough/ https://juejin.im/entry/58d7635e5c497d0057fae036 http://www.jianshu.com/p/37654eb66b58 http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html https优点http://www.codeceo.com/article/why-http-better-than-https.html SSL/TSL 协议运行机制http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html https 从第一s发生的事情http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html 彭彭的文章，名词解释器http://172.16.30.58:8000/index.php/2017/11/22/http-https-tcp-dns/ 说的是项目的东西 不大沾边http://172.16.30.58:8000/index.php/2017/12/02/local-https-principle/ 说的是代理http://172.16.30.58:8000/index.php/2017/11/29/local-https-proxy/ `http 与 https 页面资源互相访问 https证书获取的方法，自签，机构认证之类的 HTTP 相关常见协议头的分析, 比如下面的头对 GET POST 的影响、对传递参数的影响 “content-type”: “application/x-www-form-urlencoded” “content-type”: “multipart/form-data” HTTP访问控制（CORS）的分析 跨域是什么 为什么有跨域 如何解决 GET 和 POST 的真正区别session 机制缓存机制（跟缓存相关的协议头）想屌点的就加一个简单的实例分析演示；抓包演示等 感觉上面建议这些点，比单纯的罗列 HTTP 的理论会更有意义` 理论篇https = http + ssl/tls ssl =&gt; 安全套接层tls =&gt; 传输层安全性协议 https 作用http 窃听风险：第三方获取通信内容 篡改风险：第三方可以修改通信内容 冒充风险：第三方可以冒充他人身份参与通信 SSL/TLS 所有信息加密传输 无法窃听 校验机制 篡改会被发现 配证书 防止被冒充 SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。 如何保证公钥不被篡改：将公钥放在数字证书中，证书可信你的公钥就是可信 公钥加密计算量太大，如何减少耗用的时间？每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。 （1） 客户端向服务器端索要并验证公钥。（2） 双方协商生成”对话密钥”。（3） 双方采用”对话密钥”进行加密通信。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[flex:1在iOS10.2导致flex-wrap 不起作用]]></title>
      <url>%2F2017%2F08%2Fflex-1%E5%9C%A8iOS10-2%E5%AF%BC%E8%87%B4flex-wrap%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8bug%2F</url>
      <content type="text"><![CDATA[实际上是 flex-basis 的默认值在 iOS10.2及以下为 0 而不是 auto 导致的。 背景项目上有一个列表要有这种效果： 只有一个的情况是一个占一排 有两个的情况是 各占50% 有三个或以上的情况是 每个占 1/3所以这时候用flex是最容易的。大于三个的直接补全至3的倍数即可代码大致思路：12345678910.demo &#123; display: flex; flex-wrap: wrap; height: 100px;&#125;.demo div &#123; border: 1px solid red; flex: 1; min-width: 30%;&#125; 1234567891011121314151617&lt;div class="demo"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="demo"&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="demo"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 本来是完美无缺的，但是在测试过程中，发现说 iOS 10.2 及以下版本会出现 flex-wrap没有正确换行的情况，就算大于三个的情况 全部也都会挤在同一行。 该bug在 10.3不会重现。 解决方案本来有考虑不用 flex 而是用 inline-block 或 float 来解决，但是还是觉得 flex 解决比较优雅一点。所以多番尝试后发现说，不写 flex:1 而是写成 flex:1 1 auto就没问题。 在safari调试了一下，发现 iOS10.2及以下 flex-basis 属性的默认值为 0 而不是 auto.所以所有的项都变成挤在一起。 所以在原来代码上加多一行 flex-basis: auto; 重置掉 flex-basis: 0; 带来的问题即可。 在线demo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浏览器css滚动回弹效果 overflow-scrolling]]></title>
      <url>%2F2017%2F08%2F%E6%B5%8F%E8%A7%88%E5%99%A8css%E6%BB%9A%E5%8A%A8%E5%9B%9E%E5%BC%B9%E6%95%88%E6%9E%9C-overflow-scrolling%2F</url>
      <content type="text"><![CDATA[前几天做全屏fixed布局弹窗的时候，去参考了一下淘宝的布局。 无意中发现里面用到一个没见过的css属性 -webkit-overflow-scrolling 该属性控制元素在移动设备上是否使用滚动回弹效果,会有种拟原生的效果 是属于Safari自己实现的css属性 兼容性支持 iOS 5.0 以上。 123-webkit-overflow-scrolling: touch; /* 当手指从触摸屏上移开，会保持一段时间的滚动 */-webkit-overflow-scrolling: auto; /* 当手指从触摸屏上移开，滚动会立即停止 */ 在线demo 示例demo 只在ios手机上有效 浏览器看不出效果12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div &#123; height: 200px; overflow: auto; &#125; .scrolling1 &#123; background-color: red; -webkit-overflow-scrolling: auto; &#125; .scrolling2 &#123; background-color: yellow; -webkit-overflow-scrolling: touch; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;-webkit-overflow-scrolling: auto;&lt;/h1&gt; &lt;div class="scrolling1"&gt;&lt;/div&gt; &lt;h1&gt;-webkit-overflow-scrolling: touch;&lt;/h1&gt; &lt;div class="scrolling2"&gt;&lt;/div&gt; &lt;script&gt; const divList = Array.from(document.querySelectorAll('div')) let str = '' for (let i= 0;i&lt; 100; i++) &#123; str += `&lt;p&gt;$&#123;i&#125;&lt;/p&gt;` &#125; divList.forEach(item=&gt; &#123; item.innerHTML = str &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参考资料 MDN Safari CSS]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[8月伊始牢骚]]></title>
      <url>%2F2017%2F08%2F8%E6%9C%88%E7%AC%AC%E4%B8%80%E5%91%A8%E7%9A%84%E7%89%A2%E9%AA%9A%2F</url>
      <content type="text"><![CDATA[看了一下 上一次 commit 的时间。jun 25, 2017从去兰卡威玩之前就开始没写博客了。回来之后又一直很懒散 加上工作实在饱和 差点丢了这个习惯 不好 不好 7月的加班时长，平均时长是 11.30 小时 排公司技术第五 七月尾八月初有个小机会 可以用上react全家桶做一个前端的后台管理系统 [前端性能检测后台 sp] 从只自己捣鼓过 react-native 的小菜鸟 一下子要上手全家桶 真的很蛋疼，好几天都在看 文档api demo 幸亏其毅大哥 此处应该有掌声 整天做我的小 Google GoGoGo react/redux/redux-sage/react-router/react-redux-router/antd/dva 期间做热力图的内嵌 第一次用了 postMessage。 然后意外发现 不知道是 redux-tool还是redux 用了 web-worker 来做计算线程。 跟发现新大陆一样 这周五排到我分享，打算把 postMessage 简单说一下，下次有机会的时候 说一下 sp后台和 dva的大概思路 8.26号第一次参加 FEDAY 挺开心的 可以去北京。 加油 Jsonz 加油P3]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[postMessage 消息传递]]></title>
      <url>%2F2017%2F08%2FpostMessage-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%2F</url>
      <content type="text"><![CDATA[背景最近捣鼓一个小项目， 做了一个后台管理平台 里面要对线上项目做一个操作 显示热力图。所以只能采用 iframe 去嵌套，再做其他操作。包括 加载相对的js脚本（热力图脚本 称heatmap.js)， 在后台筛选日期 地点时 heatmap.js 要做对应的操作因为后台的域和前端不一致 所以跨域操作 首选用 postMessage postMessage api12345678910otherWindow.postMessage(message, targetOrigin, [transfer] )otherWindow: 其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。message: 将要发送到其他 window的数据。它将会被结构化克隆算法序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。targetOrigin: 通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串"*"（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的orign属性完全一致，来防止密码被恶意的第三方截获。如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是*。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。transfer 可选是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 需要注意的是 message 不可以包含 dom对象, 可以把验证或校对信息放置在 message 一并发送出去 小demoa.html123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe src="./demo1.html" frameborder="0" name="iframe1"&gt;&lt;/iframe&gt; &lt;script&gt; const iframeWindow = document.iframe1 iframeWindow.addEventListener('load', function() &#123; iframeWindow.postMessage(&#123; type: 'script', evalFn: 'alert(1)' &#125;, '*') &#125;) window.addEventListener('message', ()=&gt; &#123; console.log('parent message ') &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; b.html1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;script&gt; window.addEventListener('message', event=&gt; &#123; console.log(event) const &#123; evalFn, type &#125; = event.data const &#123; source &#125; = event console.log(type, evalFn) if (type === 'script') eval(evalFn) source.postMessage('bilibili', '*') &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实际应用小例子admin-iframe/index.js123456789101112131415161718...const iframeWindow = iframe.contentWindowthis.initMessenger = new postMessage(iframeWindow, 'initPostMessage')this.initMessenger.send(&#123;type: 'asyncLoadScript', data: &#123;src: config.heatmapJs&#125;&#125;)// heatmapMessage 处理与heatmap-show相关的事件this.heatmapMessenger = new postMessage(iframeWindow, 'heatmap')// 每次跳转页面或load 都重新在state 更新事件到heatmap-showthis.targetMessenger.listen('loadSuccess', ()=&gt; &#123; const &#123; startTime, endTime, site, continent, isHeatmap &#125; = this.props.heatmap this.heatmapMessenger.send(&#123;type: 'initFilter', data: &#123; date: [startTime, endTime], site, isHeatmap &#125;&#125;)&#125;)... postMessage.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* * @Author: Jsonz * @Date: 2017-08-05 15:42:15 * @Last Modified by: Jsonz * @Last Modified time: 2017-08-05 16:15:44 * * const messenger = new Messenger(window, 'heatmap') * messenger.send(&#123; type: 'changeType', data: &#123; &#125; &#125;) * messenger.listen(&#123; type: 'changeType', cb: ()=&gt; &#123;&#125; &#125;) */class Messenger &#123; constructor(target, prefix) &#123; this.target = target this.prefix = prefix this.listenFunc = [] this.initListen() &#125; send(msg) &#123; if (!msg.type) throw new Error('postMessage send 没有传type') msg.type = this.prefix + '__' + msg.type this.target.postMessage(msg, '*') &#125; listen(type, cb) &#123; const len = this.listenFunc.length type = this.prefix + '__' + type let cbIsExist = false for (let i= 0; i&lt; len; i++) &#123; if (this.listenFunc[i].type === type) &#123; cbIsExist = true break &#125; &#125; if (!cbIsExist) this.listenFunc.push(&#123; cb, type &#125;) &#125; initListen() &#123; const cb= event=&gt; &#123; let messageObj if (typeof event === 'object' &amp;&amp; event.data) messageObj = event.data if (!messageObj.type || !messageObj.type.includes('__')) return for (let i= 0; i&lt; this.listenFunc.length; i++) &#123; let itemFn = this.listenFunc[i] if (itemFn.type === messageObj.type) itemFn.cb(messageObj.data) &#125; &#125; window.addEventListener('message', cb, false) &#125;&#125;// modules.export = Messengerexport default Messenger 参考githubpostMessage MDN 文档caniuse arale/messenger/index.js]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[兼容多种模式规范]]></title>
      <url>%2F2017%2F07%2F%E5%85%BC%E5%AE%B9%E5%A4%9A%E7%A7%8D%E6%A8%A1%E5%BC%8F%E8%A7%84%E8%8C%83%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617181920;(function(name, definition) &#123; // 检测上下文环境是否为 ADM 或 CMD var hasDefine = typeof define === 'function'; // 检查上下文是否为 node var hasExports = typeof module !== 'undefined' &amp;&amp; module.exports; if (hasDefine) &#123; // AMD环境 或 CMD环境 define(definition); &#125; else if (hasExports) &#123; // 定义为普通Node模块 module.exports = definition(); &#125; else &#123; // 将模块的执行结果挂在window变量中， 在浏览器中 this 指向 window 对象 this[name] = definition(); &#125;&#125;)('hello', function() &#123; var hello = function() &#123;&#125; return hello;&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nodeJs 学习导航]]></title>
      <url>%2F2017%2F06%2FnodeJs-%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%88%AA%2F</url>
      <content type="text"><![CDATA[廖雪峰node教程内置模块fs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253'use strict'const fs = require('fs')// 读取文件fs.readFile('demo1.html', 'utf-8', (err, data)=&gt; &#123; // console.log(err? err: data)&#125;)// 异步读取文件fs.readFile('about-us.png', (err, data)=&gt; &#123; if (err) &#123; console.log(err) &#125; else &#123; // console.log(data) // console.log(data.length + ' bytes') let text = data.toString('utf-8') // console.log(text) let buf = new Buffer(text, 'utf-8') // console.log(buf) &#125;&#125;)// 同步读取文件try &#123; const data = fs.readFileSync('demo2.html', 'utf-8') console.log(data)&#125; catch(err) &#123; console.log(err)&#125;// 写文件const writeData = 'Hello Jsonz'fs.writeFile('output.txt', writeData, err=&gt; &#123; console.log(err || 'ok.')&#125;)// 获取文件信息fs.stat('output.txt', (err, stat)=&gt; &#123; if (err) &#123; console.log(err) &#125; else &#123; console.log('isFile: ' + stat.isFile()) console.log('isDirectory: ' + stat.isDirectory()) if (stat.isFile()) &#123; console.log('size: ' + stat.size) console.log('birth time: ' + stat.birthtime) console.log('modified time: ' + stat.mtime) &#125; &#125;&#125;) stream1234567891011121314151617181920212223242526272829303132333435363738394041'use strict'try &#123; const fs = require('fs') const rs = fs.createReadStream('output.txt', 'utf-8') // 结束 rs.on('end', function() &#123; console.log('END') &#125;) // 错误捕获 rs.on('error', err=&gt; &#123; console.log('ERROR: ' + err) &#125;) // 读取 rs.on('data', chunk=&gt; &#123; console.log('DATA: ', chunk) &#125;) // 写入文本数据 const ws1 = fs.createWriteStream('output1.txt', 'utf-8') ws1.write('使用Stream写入文本数据...\n') ws1.write('END.') ws1.end() // 写入二进制数据 const rs2 = fs.createWriteStream('output2.txt') rs2.write(new Buffer('使用Stream写入文本数据... \n', 'utf-8')) rs2.write(new Buffer('END.', 'utf-8')) rs2.end() // pipe 流 const ws2 = fs.createWriteStream('copied.txt') rs.pipe(ws2, &#123; end: false &#125;) // rs Readable流和 ws2 Writable流用 pipe串起来。 默认Readable流数据读取完毕后关闭 Writeable流。可以传参修改&#125; catch(err) &#123; console.log(err)&#125; HTTP简单的协议入门介绍 简单的http服务器1234567891011const http = require('http')const server = http.createServer((request, response)=&gt; &#123; console.log(request.method + ': ' + request.url) response.writeHead(200, &#123;'Content-Type': 'text/html'&#125;) response.end('&lt;h1&gt; Hello World! &lt;/h1&gt;')&#125;)server.listen(8080)console.log('server is running at http://127.0.0.1:8080') 文件服务器123456789101112131415161718192021222324252627282930313233343536const http = require('http')const url = require('url')const path = require('path')const fs = require('fs')const root = path.resolve(process.argv[2] || '.')console.log('Static root dir: ' + root)// 创建服务器const server = http.createServer((request, response)=&gt; &#123; // 获取URL 的 path, 类似 /css/bootstrap.css const pathname = url.parse(request.url).pathname // 获取对应的本地文件路径， 蕾西 /srv/www/css/bootstrap.css const filepath = path.join(root, pathname) // 获取文件状态 fs.stat(filepath, (err, stats)=&gt; &#123; if (!err &amp;&amp; stats.isFile) &#123; // 没有出错且文件存在 console.log('200 ' + request.url) // 发送200响应 response.writeHead(200) // 将文件流导向response fs.createReadStream(filepath).pipe(response) &#125; else &#123; // 出错了或者文件不存在 console.log('404 ' + request.url) // 发送404 响应 response.writeHead(404) response.end('404 Not Found') &#125; &#125;)&#125;)server.listen(8080)console.log('server is running at http://127.0.0.1:8080') crypto 通用的加密算法和哈希算法crypto实现加密解密12345678910111213141516171819202122232425262728293031323334// 通用的加密和哈希算法const crypto = require('crypto')const hash = crypto.createHash('md5')// 可以直接把 md5v 改为 sha1 或更安全的 sha256 sha512// 可以任意多次调用update 默认字符串编码为 UTF-8hash.update('hello world')hash.update('hello nodejs')console.log(hash.digest('hex'))// AES 对称加密算法function aesEncrypt(data, key) &#123; const cipher = crypto.createCipher('aes192', key) let crypted = cipher.update(data, 'utf8', 'hex') crypted += cipher.final('hex') return crypted&#125;function aesDecrypt(encrypted, key) &#123; const decipher = crypto.createDecipher('aes192', key) let decrypted = decipher.update(encrypted, 'hex', 'utf8') decrypted += decipher.final('utf8') return decrypted&#125;let data = 'Hello, this is a secret message!'const key = 'Jsonz-password'const encrypted = aesEncrypt(data, key)const decrypted = aesDecrypt(encrypted, key)console.log('Plain text: ' + data)console.log('Encrypted text: ' + encrypted)console.log('Decrypted text: ' + decrypted)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react-native 学习总结]]></title>
      <url>%2F2017%2F06%2Freact-native-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[进公司的时候 原部门老大让我去看rn demo 后面项目会用到，于是有了这个项目的开始。 但是一个星期后，我被调去另一个部门，现部门进来之后就一直忙着业务代码 产品迭代。 从github 提交应该也能看出来， 特别从 6.8到6.24 一次commit都没有。 慕课网狗狗说app的开发教程学习，这次的学习可以算是半成品，大概了解了rn 也写了一个较为完整的demo，后面如果有一些简单的rn项目或者app内嵌 上手成本应该低了很多。包括:RN 项目环境配置 折腾了很久 真的很多坑穿插着学了一点点O-C 语法xCode 资源库引用以及常见问题或常见功能使用RN 项目启动 link watchman 等等RN 具体代码 api 组件 学习Koa 与 mongoDB 的简单使用七牛云使用螺丝帽发送验证码使用各种类库 图片插件 倒计时插件 录音 录像 等接下来如果不是项目有使用到的话 应该不会再深入接触rn。 毕竟现在的目标是进军P3 &amp;&amp; 优秀员工。 app部分截图: 最后附上源码 RN 很看 环境和版本，所以跑得起来才是不正常的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[置顶]捣鼓目录]]></title>
      <url>%2F2017%2F06%2F%E6%8D%A3%E9%BC%93%E7%9B%AE%E5%BD%95%2F</url>
      <content type="text"><![CDATA[记录平时工作学习的目录条目， 类似 Jsonz-learn、 Jsonz-wheel 的目录。 预告说了好久 想把精力不局限于前端这一块了。横向扩展一下所以这期开始不把重心放太多到前端领域可能关注多点 后端Node，服务器Linux。前端方面了解的构建方向，性能方面 AMP,PWA等 但是不会太深入，而是了解有这个东西，以后如果项目需要 可以多一个方案 快速上手。 Node.js《node.js实战》《深入浅出node》 Linuximooc Linux《鸟哥的linux私房菜》 目录 排名按时间顺序了解 babel 写个babel 插件 —— 了解编译器原理 实现了一个 极简的编译器 react/dva/antd/antd-pro/roadhog 全家桶 项目用ingpostMessage 简单的对系统自带的postMessage进行封装 支持事件类型监听 更多实现参考 arale/messenger/index.js react-native-dogs 学习react-native 比较全面的一个路径 虽然不完整，但包含了rn 常用的api 库 等 也涉及到 node koa 七牛云等 react-native-countdown ReactNative的倒计时组件 造这个轮子的原因是学习rn的时候，视频推荐额一个组件，但是这个组件已经停止维护 所以只能自己造一个 支持日期与秒数的倒计时 简单粗暴 fixedTop 吸顶效果 一个很小的常用效果 主要细节 在于改变dom为 fixed布局后在该dom后面生成一个占位的，防止兄弟节点的抖动 copyText 复制黏贴板插件 支持h5，PC success, error回调 判断浏览器是否支持该事件接口 heatmap 热力图 老大提的小需求 一两个小时完成 点击页面会间隔(10s)存到sessionLocation。 刷新后会把存在sessionLocation 绘制成热力图展示在页面上 validator 小型表单验证插件 移动端简单的验证插件 支持自己配置验证项 支持多重验证 cookie 封装了一些cookie常用的api get set remove clear getAll ObjectiveC ObjectiveC 基础 为了学 ReactNative 做一点ios基础铺垫 setTimeout &amp;&amp; setIntervalEvent 最简单的事件系统 handlebars 简单的模板引擎http://handlebarsjs.com quickskin 简单的PHP模板， 文档很不全 {value} if for sass 简单的入门语法，因为用过less 所以基本无障碍 chrome-extension 学习chrome插件开发入门 暂存finish，后面会重新学习 比较感兴趣 目前想法是做一个可以在页面比较方便加载js的插件 TODO animate-text 一个简单的文字 &amp;&amp; 数字 动画小插件。 demo 文档 backbone 历史悠久的MVC框架 https://github.com/jashkenas/backbone DesignPattern 后面会继续学习 《JavaScript设计模式》张容铭 亚马逊购买 ECMAScript_6_Primer ES6入门 阮一峰 亚马逊购买 gulp gulp中文 https://github.com/gulpjs/gulp imooc 慕课网上的相关学习 imooc.com 学习占幅越来越低，看视频的效率没有看书和博客来的快 markdown markdown语法学习 github markdown require JS模块化加载规范 AMD产物 AMD require+backbone backbone+require 练习 RiotJs 微型类React框架 http://riotjs.com/ 公司在用，有实战经验 v2兼容ie8 edit_config 常用的编辑器配置 Uncle Tom 汤姆大叔的博客Js教程 强烈推荐!!!! 深入浅出 讲了很多原理性的东西 入门与进阶必备 http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html vue vueJs入门部分demo vue+webpack vue+webpack demo jsonz_old 刚入门的时候写的一个在线简历 停止更新 zhangxinxu 腾讯一个大佬，主要重构方面。 css与html很多疑难杂症 基础知识等都可以在里面找到 http://www.zhangxinxu.com/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react-native-countdown RN的倒计时组件]]></title>
      <url>%2F2017%2F06%2Freact-native-countdown-RN%E7%9A%84%E5%80%92%E8%AE%A1%E6%97%B6%E7%BB%84%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[概述之所以会写这个小组件是因为学习RN的时候，跟着视频敲代码。 视频推荐了一款倒计时组件 因为长期没有维护（最后一次更新是一年前）， 在我的RN环境下报错。 报错的原因大概是 React 把一个功能独立出去，要重新引进就可以了。 不过想着既然我已经看了源码找到问题，那么我何不自己造一个小轮子呢~ 项目github 用法需要手动引入，没有传到npm 懒得再维护 12345678910111213141516171819202122232425import &#123;CountDownText&#125; from 'react-native-sk-countdown';&lt;CountDownText style=&#123;styles.cd&#125; countType='seconds' // 计时类型：seconds / date auto=&#123;true&#125; // 自动开始 afterEnd=&#123;() =&gt; &#123;&#125;&#125; // 结束回调 timeLeft=&#123;10&#125; // 正向计时 时间起点为0秒 step=&#123;-1&#125; // 计时步长，以秒为单位，正数则为正计时，负数为倒计时 startText='获取验证码' // 开始的文本 endText='获取验证码' // 结束的文本 intervalText=&#123;(sec) =&gt; sec + '秒重新获取'&#125; // 定时的文本回调 /&gt;&lt;CountDownText // 倒计时 style=&#123;styles.cd&#125; countType='date' // 计时类型：seconds / date auto=&#123;true&#125; // 自动开始 afterEnd=&#123;() =&gt; &#123;&#125;&#125; // 结束回调 timeLeft=&#123;10&#125; // 正向计时 时间起点为0秒 step=&#123;-1&#125; // 计时步长，以秒为单位，正数则为正计时，负数为倒计时 startText='' // 开始的文本 endText='' // 结束的文本 intervalText=&#123;(date, hour, min, sec) =&gt; date + '天' + hour + '时' + min + '分' + sec&#125; // 定时的文本回调 /&gt; Prop Prop Description Default countType Countdown type, one of ‘seconds’ and ‘date’. None auto Whether to start countdown right now. false timeLeft Seconds lefted to countdown. None step Number to increment in each step. -1 startText Text before countdown. None endText Text after countdown. None intervalText A function to reture a text during countdown. None afterEnd A callback function after countdown. None Methods Method Description Params start start countdown. None end finish countdown. None 源码主要有两个文件，一个是倒计时的逻辑，另一个是夹杂了RN的逻辑。CountDown.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112export default class CountDown &#123; constructor(props) &#123; this.setData(props); &#125; // 获取有多少秒 static getSeconds(time) &#123; let type = typeof time; return (type === 'number' || type === 'string' &amp;&amp; /^\d+$/.test(time)) ? time : new Date(time).getTime() / 1000; &#125; // 位数补全 static ten(t) &#123; return t &lt; 10? '0' + t: t; &#125; // 设置数据 setData(props) &#123; this.countType = props.countType; // 支持两种计时方式，两个日期之间 &amp;&amp; 秒数的倒计时 this.timerId = null; // 计时器 this.endTime = props.endTime; // 计时器结束时间 this.startTime = props.startTime; // 计时器开始时间 this.timeLeft = props.timeLeft; // 计时器剩余秒数， 区别于上面时间段的计时方式 this.timePassed = 0; // 正向为累计时间，反向为剩余时间 this.onInterval = props.onInterval; // 定时的回调 this.onEnd = props.onEnd; // 结束的回调 this.step = props.step; // 计时步长，以秒为单位，正数为正计时，负数为倒计时 this.counter = 0; // 累加器 TODO 疑问 // 数据校验 if (!this.countType) &#123; throw new Error('必须传入一个 countType: seconds || date'); &#125; if ( (this.timeLeft &amp;&amp; (this.endTime || this.startTime)) || (!this.timeLeft &amp;&amp; !(this.endTime || this.startTime)) ) &#123; throw new Error('必须传入一个时间段 [timeLeft] [startTime] [endTime]'); &#125; if (!this.timeLeft &amp;&amp; typeof this.startTime === 'undefined') &#123; this.startTime = Date.now()/ 1000; &#125; if (!this.timeLeft) &#123; this.timeLeft = Math.floor(CountDown.getSeconds(this.endTime) - CountDown.getSeconds(this.startTime)); &#125; this.refreshTime(true); &#125; // 周期启动更新时间 auto() &#123; this.timerId = setTimeout(()=&gt; &#123; // 倒计时到0停止计时 if (this.timePassed &lt;= 0 &amp;&amp; this.step &lt; 0) return this.end(); this.refreshTime(true); &#125;, 1000 * Math.abs(this.step)); // 时间间隔为整数， 对step求绝对值 &#125; refreshTime(isStart) &#123; this.timePassed = (this.timeLeft * 1000 + this.step * 1000 * this.counter++) / 1000; if (this.countType === 'date') &#123; let _timePassed = this.timePassed, second = CountDown.ten(_timePassed % 60); _timePassed = parseInt(_timePassed / 60); let minute = CountDown.ten(_timePassed % 60); _timePassed = parseInt(_timePassed / 60); let hour = CountDown.ten(_timePassed % 24); _timePassed = CountDown.ten(parseInt(_timePassed / 24)); this.onInterval(_timePassed,hour,minute, second); &#125; else if (this.countType === 'seconds') &#123; this.onInterval(this.timePassed); &#125; isStart &amp;&amp; this.auto(); // 是否开始计时 &#125; // 开始计时 start() &#123; clearTimeout(this.timerId); this.refreshTime(true); &#125; // 结束： 没有清空计数 + 停止计时 end() &#123; clearTimeout(this.timerId); this.onEnd(this.timeLeft); &#125; reset() &#123; this.counter = 0; clearTimeout(this.timerId); this.refreshTime(false); &#125;&#125; CountDownText.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import React, &#123;Component&#125; from 'react';import &#123; Text&#125; from 'react-native';import CountDown from './CountDown';class CountDownText extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; text: this.props.startText, &#125;; &#125; counter= null; static isTimeEquals(t1, t2) &#123; return Math.abs(t1 - t2) &lt; 2; &#125; componentWillReceiveProps(nextProps) &#123; let updating = true; // 倒计时的情况 if (this.props.step === nextProps.step &amp;&amp; this.props.step &lt; 0) &#123; if (this.props.endTime) &#123; // 1. 按起始日期来计时 updating = !CountDownText.isTimeEquals(this.props.endTime, nextProps.endTime); &#125; else &#123; // 2. 按间隔秒数来计时 updating = !CountDownText.isTimeEquals(nextProps.timeLeft, this.counter.timePassed); &#125; &#125; if (updating) &#123; // 重置： 清空计数 + 停止计时 this.counter.reset(); this.counter.setData(Object.assign(&#123;&#125;, nextProps, &#123; onInterval: this.onInterval.bind(this), onEnd: this.onEnd.bind(this), &#125;)); if (nextProps.auto) &#123; this.start(); &#125; &#125; &#125; componentDidMount() &#123; this.counter = new CountDown(Object.assign(&#123;&#125;, this.props, &#123; onInterval: this.onInterval.bind(this), onEnd: this.onEnd.bind(this), &#125;)); if (this.counter.timeLeft &lt;= 0 &amp;&amp; this.counter.step &lt;= 0) &#123; return this.end(); &#125; if (this.props.auto) this.start(); &#125; componentWillUnmount() &#123; this.reset(); &#125; start() &#123; this.counter.start(); &#125; end() &#123; this.counter.end(); &#125; reset() &#123; this.counter.reset(); &#125; render() &#123; return ( &lt;Text style=&#123;this.props.style&#125;&gt; &#123;this.state.text&#125; &lt;/Text&gt; ) &#125; getTimePassed() &#123; return this.counter.timePassed; &#125; onInterval(...args) &#123; this.setState(&#123;text: this.props.intervalText.apply(null, args)&#125;) &#125; onEnd(timePassed) &#123; this.setState(&#123; text: this.props.endText, &#125;); this.props.afterEnd(timePassed); &#125;&#125;CountDownText.defaultProps = &#123; countType: 'seconds', onEnd: null, timeLeft: 0, step: -1, startText: null, intervalText: null, endText: null, auto: false, afterEnd: ()=&gt; &#123;&#125;,&#125;;export default CountDownText; 后记大量借鉴 https://github.com/shigebeyond/react-native-sk-countdown 项目 其实说白了只是在原来代码上优化改进，主要兼容新版的React-Native、React 和用 ES6语法改写。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端浏览器默认请求 apple-touch-icon.png 问题]]></title>
      <url>%2F2017%2F06%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E9%BB%98%E8%AE%A4%E8%AF%B7%E6%B1%82-apple-touch-icon-png-%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[概述项目有做埋点与请求的记录， 早上发现有用户老是会请求一个location.origin + &quot;/apple-touch-icon.png&quot; 或 location.origin + &quot;/apple-touch-icon-76x76.png&quot;的问题。 这就很纳闷了， 首先，按照我们的代码风格是不会出现 根目录指向的图片 而且后台也不会输出这么系统化的图片名。 一看就知道是 apple 搞的鬼。 于是乎 google 了一下 大概就是ios8及以上safari浏览器的保存桌面操作请求的一张图，用于做icon。 场景： 解决方法：可以在head加上这段1&lt;link rel="apple-touch-icon" href="/custom_icon.png"&gt; 如果要更加精准一点，根据设备来用不同的icon，则可以这样1234&lt;link rel="apple-touch-icon" href="touch-icon-iphone.png"&gt;&lt;link rel="apple-touch-icon" sizes="152x152" href="touch-icon-ipad.png"&gt;&lt;link rel="apple-touch-icon" sizes="180x180" href="touch-icon-iphone-retina.png"&gt;&lt;link rel="apple-touch-icon" sizes="167x167" href="touch-icon-ipad-retina.png"&gt; 如果没有找到符合设备的尺寸，那么会优先选用比预期尺寸大的最小图标。比如设备的适当图标大小为58 x 58，系统会按照下面寻找 apple-touch-icon-80x80.png apple-touch-icon.png 默认是去更目录寻找，不过你可以指定一个路径。 后记更多资料]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[工作日常 吸顶效果]]></title>
      <url>%2F2017%2F05%2F%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%B8%B8-%E5%90%B8%E9%A1%B6%E6%95%88%E6%9E%9C%2F</url>
      <content type="text"><![CDATA[概述吸顶 最常见的就是我们平时网站浏览的时候，下滑到某个程度之后 导航栏就固定到顶部而不随页面滚动而滚动（简单而言就是 fixed 布局 ).最常见的实现方式思路就是 判断页面滚动高度，到某个高度的时候就让这个div改变定位方式 具体实现引入 jq ，并加一判断，如果jq(zepto) 没有 outerHeight/outerWidth 手动实现。12345678910111213141516171819202122232425262728import $ from './jquery-2.1.1';// 如果没有 outerWidth 或 outerHeight 手动实现outerWidth &amp;&amp; outerHeight(()=&gt; &#123; if (typeof $.outerHeight === 'function') return; ['height', 'width'].forEach(dimension=&gt; &#123; let Dimension = dimension.replace(/./, m=&gt; m[0].toUpperCase()); $.fn['outer' + Dimension] = function(margin) &#123; if (this) &#123; let size = this[dimension](), sides = &#123; 'width': ['left', 'right'], 'height': ['top', 'bottom'], &#125;; sides[dimension].forEach(side=&gt; &#123; if (margin) size += parseInt(this.css('margin-' + side), 10); &#125;); return size; &#125; else &#123; return null; &#125; &#125; &#125;);&#125;)(); 实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const fixedTop = &#123; /** * @param el 具体要 fixed 的 dom 的字符串或jqueryDom 或dom * @param opts 其他配置，目前只有 hold 是否要生成一个占位div防止div 脱离文档流后兄弟节点抖动 */ init(el, opts=&#123; hold: true&#125;) &#123; // 初始化需要的el this.$el = el instanceof $? el: $(el); // 获取后面要改变样式的具体参数 let offset = this.$el.offset(); this.offsetTop = offset.top; this.defaultHeight = this.$el.outerHeight(true); this.defaultState = &#123; position: this.$el.css('position'), width: this.$el.css('width') || 'auto', top: this.$el.css('top') || 'auto', &#125;; this.changeState = &#123; position: 'fixed', width: this.$el.outerWidth(), top: '0', left: offset.left, &#125;; // 如果有 hodl 参数， 配置好要生成的 占位dom this.holdEl = opts.hold? `&lt;div class="J-fixedTop-pad" style="height:$&#123;this.defaultHeight&#125;px; visibility: hidden;"&gt;&lt;/div&gt;`: ''; // 绑定事件 this.bindEvent(); &#125;, bindEvent() &#123; let $win = $(window); $win.scroll(()=&gt; &#123; let isTop = ($win.scrollTop() - this.offsetTop) &gt;= 0, isFixed = this.$el.data('fixed'); // 判断 如果大于top 并且当前的dom元素没有被改变样式，则执行逻辑 if (isTop &amp;&amp; !isFixed) &#123; this.$el.data('fixed', true); if (!this.$el.next().hasClass('J-fixedTop-pad')) &#123; this.$el.after(this.holdEl); &#125; this.addCss(); &#125; else if (!isTop &amp;&amp; isFixed)&#123; // 反之 还原dom样式 this.$el.data('fixed', false); this.removeCss(); this.holdEl &amp;&amp; this.$el.next().remove(); &#125; &#125;) &#125;, addCss() &#123; this.$el.css(this.changeState); &#125;, removeCss() &#123; this.$el.css(this.defaultState); &#125;&#125;; 调用1fixedTop.init('#div'); 后记很简单的小需求， 是在工作中看到小伙伴的脚本后改进的。 主要是之前没有想到要生成一个占位dom来防止后面的抖动项目源码链接 目前只支持吸顶， 后面可以对代码改造，改成可以支持左右上下的 然后有一个css样式可以直接达到这个效果，但是兼容性不乐观， 对布局也有所要求，有兴趣的可以去了解一下.sticky demo。sticky caniuse]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ios body事件委托的坑]]></title>
      <url>%2F2017%2F05%2Fios-body%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E5%9D%91%2F</url>
      <content type="text"><![CDATA[部门老大: 这个套餐怎么超出一屏之后点击没反应的… 起因有一个套餐列表是靠接口异步渲染的，所以事件我直接绑定在body上，通过事件委托去触发。这原本没什么问题， 要命的是 reset.css 中把 body, html 高度设置为 100%。 这就可能出现下面的情况 页面过长，拉上去的时候 body 只有 100% 高度，没有覆盖到下面， 所以这时候点击下面的套餐，不算是点击到body上 委托也就无从下手。 解决方法解决方法很简单…. 只需要在页面重置掉那个样式即可 如 body=&gt; height: auto。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ios9 下 domArray forEach 报错]]></title>
      <url>%2F2017%2F05%2Fios9-%E4%B8%8B-domArray-forEach-%E6%8A%A5%E9%94%99%2F</url>
      <content type="text"><![CDATA[起因是这样的，产品需求需要输入框输入后，要根据内容高度自适应，最高不能超过3行， 于是写了一个小函数 123456789101112131415const textareaAutoHeight = (className, &#123;multiple=3&#125;=&#123;&#125;)=&gt;&#123; let domList = document.querySelectorAll(className); domList.forEach(item=&gt; &#123; let _height = item.offsetHeight; // item.offsetHeight 用zepto 的 height保险一点 item.addEventListener('keyup', (e)=&gt; updateHeight(e, _height*multiple)); &#125;); function updateHeight(e, _height) &#123; let o = e.target; o.style.height = '1px'; o.style.height = Math.min(o.scrollHeight, _height) + 'px'; &#125;&#125; 传入dom标识加上行数，用的很开心。没毛病 没问题。 项目上线后，发现说在某些机型下会报错，后面排查到是这个函数的错。原因是 ios9 一下。 domList 不是一个数组。 所以改动了一下 1234567891011121314151617const textareaAutoHeight = (className, &#123;multiple=3&#125;=&#123;&#125;)=&gt;&#123; try &#123; let domList = [...document.querySelectorAll(className)]; domList.forEach(item=&gt; &#123; let _height = item.offsetHeight; // item.offsetHeight 用zepto 的 height保险一点 item.addEventListener('keyup', (e)=&gt; updateHeight(e, _height*multiple)); &#125;); function updateHeight(e, _height) &#123; let o = e.target; o.style.height = '1px'; o.style.height = Math.min(o.scrollHeight, _height) + 'px'; &#125; &#125; catch(e) &#123; console.warn('JSONZ textareaAutoHeight', e)&#125;&#125; 加了一个 try...catch... 并且把 domList 用es6转为数组类型. 以后写工具类方法，尽量加多一个 try..catch... 至少保证不影响主流程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack 代码分割(异步加载加快首屏速度)]]></title>
      <url>%2F2017%2F05%2Fwebpack-%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2-%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E5%8A%A0%E5%BF%AB%E9%A6%96%E5%B1%8F%E9%80%9F%E5%BA%A6%2F</url>
      <content type="text"><![CDATA[概述对于单页应用，将所有代码打包成一个文件，可以减少网络请求，并且后面页面不需要再去加载js 可以减少白页时间。 但是对于首页需要快速加载的情况，我们可能需要重新考虑一下， 是否可以把一些不需要第一时间执行的代码异步加载进来。 Webpack有一个功能可以将您的代码库分解成按需加载的“块”，这个功能叫 代码分割。 Webpack的对于块的执行是， 异步创建&lt;script&gt;标签，把需要加载的脚本加载进来再执行。 具体有两种使用方法: CommonJs: require.ensure AMD: requireES6 Modules 暂不支持 AMD: require12345require(dependencies, callback)require(["module-a", "module-b"], function(a, b) &#123; // ...&#125;); dependencies: 模块依赖数组 callback: 回调函数 CommonJs: require.ensure12345require.ensure(dependencies, callback, chunkName);require.ensure(["module-a", "module-b"], function() &#123; var a = require("module-a"); // ...&#125;); dependencies: 依赖的模块数组 callback: 回调函数，该函数调用时会传一个require参数 chunkName: 模块名，用于构建时生成文件时命名使用 对于 CommonJs 方法， 个人在项目中都是这么用的 12345678require.ensure([],require=&gt;&#123; const menuBar = require('./menuBar'); const upcomingTrips = require('./upcomingTrips'); require('./c'); menuBar.init(); upcomingTrips.init();&#125;,'index_later'); 依赖不写dependencies 而是直接写在 回调里面。 因为webpack会去递归拿依赖模块，所以就算我 menuBar里面依赖到其他模块，也会被下载下来 所以问题不大。 但是如果对于多模块互相依赖的情况，建议按照官方demo写法 防止重复嵌套打包。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[cookie.js 简单的cookie操作插件]]></title>
      <url>%2F2017%2F05%2Fcookie-js-%E7%AE%80%E5%8D%95%E7%9A%84cookie%E6%93%8D%E4%BD%9C%E6%8F%92%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[对操作cookie做一些接口, 包括 set, get, remove, clear, getAll 等， 都支持批量处理。 用法12345678910111213141516// 获取Cookie.get('name');// 设置Cookie.set(&#123;key: val, key1: val1&#125;, opts);Cookie.set('key', 'val');// 移除某个值Cookie.remove(name);Cookie.remove([name1, name2]);// 清除CookieCookie.clear();// 获取所有cookieCookie.getAll(); // &#123;key: val&#125; 源码解析set设置cookie, 如果之前没有接触过cookie.set 可以参考文档 https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/cookies/set 添加cookie比较特殊，直接用 document.cookie = 你要设置的cookie 就可以了。 1234567891011121314151617181920set(name, value, opts) &#123; if (isObject(name)) &#123; for (let key in name) &#123; if (name.hasOwnProperty(key)) this.set(key, name[key], value); &#125; &#125; else &#123; let opt = isObject(opts)? opts: &#123; expires: opts&#125;, expires = typeof opt.expires === 'undefined'? '': opt.expires, expiresType = typeof expires, path = typeof opt.path === 'undefined'? ';path=/': `;path=$&#123;opt.path&#125;`, domain = opt.domain? `;domain=$&#123;opt.domain&#125;`: '', secure = opt.secure? ';secure': ''; if (expiresType === 'string' &amp;&amp; expires) expires = new Date(expires); else if (expiresType === 'number') expires = new Date(+new Date + 1000 * 60 * 60 * 24 * expires); if (expires !== '' &amp;&amp; 'toGMTString' in expires) expires = ';expires=' + expires.toGMTString(); document.cookie = [name, '=', encodeURI(value), expires, path, domain, secure].join(''); &#125;&#125;, get获取cookie 其实就是遍历 document.cookie 然后根据 name 去匹配 1234567891011get(name) &#123; let cookieName = name + '=', ca = document.cookie.split(';'); for (let i = 0; i &lt; ca.length; i++) &#123; let cItem = (ca[i][0] === ' ')? ca[i].slice(1): ca[i]; if (cItem.indexOf(cookieName) === 0) return decodeURI(cItem.substr(cookieName.length+1)); &#125; return false;&#125;, remove移除cookie其实就是把这个cookie 设置为过期。 1234567remove(name) &#123; let names = Array.isArray(name)? name: [name]; for (let i= 0; i&lt; names.length; i++) &#123; this.set(names[i], '', -1); &#125; return names;&#125;, clear遍历document.cookie 把所有的cookie 调用一次remove. 123clear(name) &#123; return name? this.remove(name): this.remove(Object.keys(this.getAll()));&#125;, getAll获取本地所有的cookie， 返回 {key: value} 形式 123456789getAll() &#123; if (document.cookie === '') return &#123;&#125;; let cookies = document.cookie.split('; '), result = &#123;&#125;; for (let i= 0; i&lt; cookies.length; i++) &#123; let item = cookies[i].split('='); result[decodeURI(item[0])] = decodeURI(item[1]); &#125; return result;&#125; 源码Jsonz-github 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const isObject = obj=&gt; !!value &amp;&amp; Object.prototype.toString.call(obj) === '[object Object]';const Cookie = &#123; get(name) &#123; let cookieName = name + '=', ca = document.cookie.split(';'); for (let i = 0; i &lt; ca.length; i++) &#123; let cItem = (ca[i][0] === ' ')? ca[i].slice(1): ca[i]; if (cItem.indexOf(cookieName) === 0) return decodeURI(cItem.substr(cookieName.length+1)); &#125; return false; &#125;, set(name, value, opts) &#123; if (isObject(name)) &#123; for (let key in name) &#123; if (name.hasOwnProperty(key)) this.set(key, name[key], value); &#125; &#125; else &#123; let opt = isObject(opts)? opts: &#123; expires: opts&#125;, expires = typeof opt.expires === 'undefined'? '': opt.expires, expiresType = typeof expires, path = typeof opt.path === 'undefined'? ';path=/': `;path=$&#123;opt.path&#125;`, domain = opt.domain? `;domain=$&#123;opt.domain&#125;`: '', secure = opt.secure? ';secure': ''; if (expiresType === 'string' &amp;&amp; expires) expires = new Date(expires); else if (expiresType === 'number') expires = new Date(+new Date + 1000 * 60 * 60 * 24 * expires); if (expires !== '' &amp;&amp; 'toGMTString' in expires) expires = ';expires=' + expires.toGMTString(); document.cookie = [name, '=', encodeURI(value), expires, path, domain, secure].join(''); &#125; &#125;, remove(name) &#123; let names = Array.isArray(name)? name: [name]; for (let i= 0; i&lt; names.length; i++) &#123; this.set(names[i], '', -1); &#125; return names; &#125;, clear(name) &#123; return name? this.remove(name): this.remove(Object.keys(this.getAll())); &#125;, getAll() &#123; if (document.cookie === '') return &#123;&#125;; let cookies = document.cookie.split('; '), result = &#123;&#125;; for (let i= 0; i&lt; cookies.length; i++) &#123; let item = cookies[i].split('='); result[decodeURI(item[0])] = decodeURI(item[1]); &#125; return result; &#125;&#125;; 参考https://github.com/jaywcjlove/cookie.jshttps://developer.mozilla.org/en-US/search?q=cookie]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[置顶]收藏夹]]></title>
      <url>%2F2017%2F05%2F%E6%94%B6%E8%97%8F%E5%A4%B9%2F</url>
      <content type="text"><![CDATA[一般是看到比较好的网站或文章，learn 学习完就放这边备份以后可能用到。 技术文章前端性能优化PRPL模式(PWA+) √ 框架 &amp;&amp; 库polymer NodeNode.js 应用的可视化调试与性能分析 √ egg webbilibili前端之路 pageshow 安卓webview内存 viewport shadow DOM 前端学习路线 正对其他设备的移动版网站搜索引擎优化SEO chrome 开发工具 浏览器重绘 重排等 浏览器加速 HSTS Progressive Web App √ PWA中文版 lavas (vue &amp;&amp; pwa) pwa 推文 √ JavaScript是如何工作的：内存管理 + 如何处理4个常见的内存泄漏 如何管理好10万行代码的前端单页面应用 聊聊 JavaScript 与浏览器的那些事 - 引擎与线程 2018年·玉伯《从前端技术到体验科技（附演讲视频）》 AMP官网 √ AMP小站 √ iosios touch事件与点击穿透问题 ios滚动条问题 ios滚动条问题 JavaScriptTypescript玩转设计模式 之 创建型模式 - 掘金 React-Native 开源项目学习 weex react无状态组件 react 验证组件思路 react 高阶组件 react PureComponent vue模板编译原理 vue变化侦测原理 css毛玻璃效果 css新姿势 styled styled 其他扫雷学习 扫雷学习 俄罗斯方块 2048 HTTP2 HTTP,HTTP2.0,SPDY,HTTPS你应该知道的一些事 面向前端工程师的机器学习引导课 开发文档开发者社区mozilla-devloper chrome-devtools 掘金 众成翻译 w3c基础东西 工具类脑图/流程图 百度脑图 next 置顶文章 navigation timing api测试网站加载速度 webPageTest 测速优化 本地映射公网 string line String类型线路图 其他翻墙MonoCloud翻墙搬瓦工vps每天坚持英语学习为什么还是学不好？怎样才能从英语很糟糕的人变成英语很厉害的人？你有什么相见恨晚的英语学习方法？怎么练好英语口语？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CORS 跨域资源共享]]></title>
      <url>%2F2017%2F05%2FCORS-%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%2F</url>
      <content type="text"><![CDATA[CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing） 出于安全考虑，浏览器会限制某些跨域请求。 而 cors 允许浏览器想跨源服务器发起 XMLHttpRequest 和 Fetch 接口请求。 同源策略同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。 那么浏览器是根据什么规则来判定是否为同源呢 http://www.zuzuche.com:80 协议: http 端口: 80 (默认为80 如果没写 浏览器会帮我们做这些工作) 域名 www.zuzuche.com 如果协议， 端口， 域名一致，那么浏览器就会认定我们是在同个源下面。否则就会出现跨域问题。 具体文档等可见 简单请求与非简单请求简单请求指的是 请求方法是以下方法之一 GET POST HEAD 不自定义某些头部字段 Accept Accept-Language Content-Language Content-Type （需要注意额外的限制） DPR Downlink Save-Data Viewport-Width Width Content-Type 为以下值之一 application/x-www-form-urlencoded multipart/form-data text/plain 非简单请求(预检请求)指的是 使用了下面任一HTTP方法： PUT DELETE CONNECT OPTIONS TRACE PATCH 人为设置某些头部字段 Accept Accept-Language Content-Language Content-Type (but note the additional requirements below) DPR Downlink Save-Data Viewport-Width Width Content-Type的值不属于下列之一 application/x-www-form-urlencoded multipart/form-data text/plain 发起一个简单的请求1fetch(''); 此时会发起一个简单请求，和我们平时写的ajax没多大区别 发起一个非简单请求123456789101112131415var invocation = new XMLHttpRequest();var url = &apos;http://bar.other/resources/post-here/&apos;;var body = &apos;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;person&gt;&lt;name&gt;Arun&lt;/name&gt;&lt;/person&gt;&apos;; function callOtherDomain()&#123; if(invocation) &#123; invocation.open(&apos;POST&apos;, url, true); invocation.setRequestHeader(&apos;X-PINGOTHER&apos;, &apos;pingpong&apos;); invocation.setRequestHeader(&apos;Content-Type&apos;, &apos;application/xml&apos;); invocation.onreadystatechange = function()&#123;&#125;; invocation.send(body); &#125;&#125;callOtherDomain(); 此时发起的是一个非简单请求，所以浏览器会先发一个options请求服务器，以获知浏览器是否允许实际请求，如果允许再会发多一个真实请求。 cors我们要跨域获取资源，主要要后台人员配合。 一般情况我们只需要把报错信息给后台人员看就知道怎么做了，比如我直接调用 报了一个跨域问题 Fetch API cannot load https://www.baidu.com/. No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘https://developer.mozilla.org‘ is therefore not allowed access. If an opaque response serves your needs, set the request’s mode to ‘no-cors’ to fetch the resource with CORS disabled. 直接把错误丢给后台人员，他们就知道设置一个属性 Access-Control-Allow-Origi 一般设置为 * 谁都可以访问 也可以根据情景设定特定的域名。 参考 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[获取滚动条宽度]]></title>
      <url>%2F2017%2F05%2F%E8%8E%B7%E5%8F%96%E6%BB%9A%E5%8A%A8%E6%9D%A1%E5%AE%BD%E5%BA%A6%2F</url>
      <content type="text"><![CDATA[平时工作的时候，我们经常会遇到需要全局 loading 加 遮罩层 的功能。这时候一般会设置 body { overflow: hidden } 防止页面滚动。 但是在 pc 端 如果一个页面有滚动条，突然给设置为没有的话， 可能会出现抖动的现象。 所以我们的解决思路是 在设置样式之后，给body(也可以是其他) 加多一个 padding-right来填充原本滚动条的宽度。 123456789101112131415161718192021function getScrollBarWidth() &#123; var div = document.createElement('div'), styles = &#123; width: '100px', height: '10px', overflow: 'scroll' &#125;, scrollWidth = 0; for (var key in styles) &#123; div.style[key] = styles[key]; &#125; document.body.appendChild(div); scrollWidth = div.offsetWidth - div.clientWidth; div.remove(); return scrollWidth;&#125;// 伪代码思路&#123; body.overflow = hidden; body.paddingRight += getScrollBarWidth();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端长按弹出复制等选项设置]]></title>
      <url>%2F2017%2F05%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%95%BF%E6%8C%89%E5%BC%B9%E5%87%BA%E5%A4%8D%E5%88%B6%E7%AD%89%E9%80%89%E9%A1%B9%E8%AE%BE%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[今儿产品大佬吐槽一句: 在手机端chrome 浏览器下 点一个文字老是要弹出一个让我划词 好烦。能不能让他不要弹出那些东西来 其实现在很多的 app 内嵌 h5 页面都是喜欢把手机默认的长按弹出菜单[选择， 复制， 剪切] 等禁掉。 1234567// 给所有样式都加上进制弹出长按菜单属性。* &#123; -webkit-user-select: none; user-select: none; &#125;// 记得要给表单排除，一般表单都有复制黏贴的需求input,textarea &#123;-webkit-user-select: text;user-select: text;&#125; 兼容问题 移动端基本兼容]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React-Native 错误总结]]></title>
      <url>%2F2017%2F05%2FReact-Native-%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[No bundle URL present.github issues 项目创建大概一个月了，最近突然想再捡起react-native学习， 直接跑react-native run-ios就报红屏 No bundle URL present.github 上的 issues 给出了几种解决方法。 重新安装依赖 Run “react-native run-ios” When the error appears, run “npm install” Then run “react-native run-ios” again. adding NSAllowsLocalNetworking to Info.plist这个解决方法慎重，如果修改了没有解决 请还原该代码12345678910&lt;key&gt;NSAppTransportSecurity&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSAllowsArbitraryLoadsInWebContent&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSAllowsLocalNetworking&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt;&lt;/key&gt; 8081端口被占用mac下kill 该接口，再重新跑 run-ios 12sudo lsof -i :8071kill -9 &lt;PID&gt; 在 xCode 中启动项目删除本地项目中的 ios/build 重新跑 run-ios build项目关闭本地代理，或者设置不去代理 127.0.0.1手动查找解决问题在终端跑 react-native bundle --platform ios --dev false --entry-file index.ios.js --bundle-output ./ios/release/main.jsbundle --assets-dest ./ios/release/main.jsbundle 可以找到报错原因， 比如我是 12345678bundle: startbundle: finishbundle: Writing bundle output to: ./ios/release/main.jsbundleENOENT: no such file or directory, open &apos;./ios/release/main.jsbundle&apos;少了 PureRenderMixin 组件npm i --save react@16.0.0-alpha.6 重新设置 本地loaclhost1234$ sudo vi /private/etc/hosts# Add this line127.0.0.1 localhost 让 xcode 获取权限再重试123sudo xcodebuild -licensereact-native run-ios 开两个终端第一个终端跑 npm start第二个终端再跑 react-native 清除项目 重装1234567brew updatebrew unlink watchmanbrew install watchmanrm -rf ios/build; rm -rf ios/build; rm -rf android/build; rm -rf android/app/build; rm -rf $TMPDIR/react* ; rm -f ios/main.jsbundle; rm -rf node_modules; rm yarn.lock || true; npm cache clean; yarn cache cleanyarn install or npm install 我自己的解决方法把自己的项目代码拷贝出来后，整个项目删了重新安装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** * Sample React Native App * https://github.com/facebook/react-native * @flow */import React, &#123; Component &#125; from &apos;react&apos;;import &#123; AppRegistry, StyleSheet, Text, View&#125; from &apos;react-native&apos;;class Parent extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; hit: false &#125;; &#125; // 次数清零 timeReset() &#123; &#125; willHit() &#123; &#125; componentWillMount() &#123; &#125; componentDidMount() &#123; &#125; shouldComponentUpdate() &#123; return true; &#125; componentWillUpdate() &#123; &#125; componentDidUpdate() &#123; &#125; render() &#123; return ( &lt;View style=&#123;srtles.container&#125;&gt; &#123; this.state.hit ? &lt;Child /&gt; : null &#125; &lt;Text style=&#123;styles.welcome&#125; onPress=&#123;this.timeReset.bind(this)&#125;&gt; 老子心情好，不揍你了 &lt;/Text&gt; &lt;Text style=&#123;styles.instructions&#125; onPress=&#123;this.willHit.bind(this)&#125;&gt; 老子揍你一次 &lt;/Text&gt; &lt;Text style=&#123;styles.instructions&#125; onPress=&#123;this.willHitT.bind(this)&#125;&gt; 老子要揍你三次 &lt;/Text&gt; &lt;/View&gt; ) &#125;&#125;class Child extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; times: 0 &#125; &#125; timesPlus() &#123; let time = this.state.times; times++; this.setState(&#123; times &#125;); &#125; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125; onPress=&#123;this.timesPlus.bind(this)&#125;&gt; 儿子不服 &lt;/Text&gt; &lt;Text style=&#123;styles.instructions&#125;&gt; 你打了我 &#123;this.state.times&#125; 次 &lt;/Text&gt; &lt;/View&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: &apos;center&apos;, alignItems: &apos;center&apos;, backgroundColor: &apos;#F5FCFF&apos;, &#125;, welcome: &#123; fontSize: 20, textAlign: &apos;center&apos;, margin: 10, &#125;, instructions: &#123; textAlign: &apos;center&apos;, color: &apos;#333333&apos;, marginBottom: 5, &#125;,&#125;);AppRegistry.registerComponent(&apos;imooc&apos;, () =&gt; Parent); Cannot Find entry file index.ios.js in any of the project roots红屏 报错，找不到入口文件。 检查自己的 index.ios.js 里面有没有调用初始化的函数如 AppRegistry.registerComponent(&#39;Your project name&#39;, () =&gt; indexComponents);https://github.com/facebook/react-native/issues/4968github 里面列举了截止编写 300+ 条评论。可以搜， 不过原因应该是某个node_module 升级依赖造成的， 所以没事不要乱升级啊。 TypeError: Network request failedios 下请求老是失败，莫名其妙的失败。 后面发现说是因为之前 clean project。 没有重新设置 ios 的请求 http 权限。 打开xCode 找到 Info.plist 在 Information Property List 下新增 NSAppTransportSecurity 这时候会提示你已经有了 NSAppTransportSecurity 是否要修改， 点击是 此时你会发现 NSAppTransportSecurity 已经改名为 App Transport Security Settings。 本机xCode 版本为 8.3.2; 点击 App Transport Security Settings 右边的加号 添加NSAllowsArbitraryLoads(8.3.2版本为 Allow Arbitrary Loads) 后面的值改为 YES。 重启项目即可 具体可见https://stackoverflow.com/questions/31254725/transport-security-has-blocked-a-cleartext-http react-native-image-picker 问题选择图片时奔溃错误其实是因为安装 react-native-image-picker 不够细心，只看到自动安装的时候写着 1react-native link 没看到还要手动在 Info.plist 上添加一些信息，用于备注需要 访问照片权限，麦克风权限（录像需要）， 相机权限等。 所以程序会报一个 SIGABRT 的错误. Cannot read property ‘showImagePicker’ of undefinde如果遇到这个问题，是因为你安装该组件后没有重现编译ios代码，重新编译一次即可。 如果还不起作用可以检查一下是否安装正确，再跑命令 rm -rf ios/build &amp;&amp; react-native run-ios React-Native 坑真的是遇过最多的一个]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[imooc React-Native 文字小游戏]]></title>
      <url>%2F2017%2F05%2Fimooc-React-Native-%E6%96%87%E5%AD%97%E5%B0%8F%E6%B8%B8%E6%88%8F%2F</url>
      <content type="text"><![CDATA[文字小游戏需求： 老子 &amp;&amp; 儿子 -老子打儿子： - 可以打一次 记仇次数+1 - 可以打三次 记仇次数+3 - 可以给个糖 记仇次数清零 儿子反驳老子： 儿子不服 老子打一次 儿子骂老子 老子打三次 儿子买啤酒给老子 记仇次数清零]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[setTimeout && setInterval 学习]]></title>
      <url>%2F2017%2F05%2FsetTimeout-setInterval-%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[定时器大家平时做js开发都不陌生了 最常见的应用应该就是验证码的倒计时 或 某段函数的异步执行了。 概述js的定时器主要有 setTimeout 和 setInterval. 这两个函数执行后，都会返回一个整数，表示定时器的编号，后面可以通过clearTimeout 或 clearInterval来清除该定时器。 setTimeout和setInterval的运行机制都是 将代码移除本次执行，等待下一轮的 Event Loop再检查是否到执行的时间。所以可以用 setTimeout(()=&gt; {}, 0) 来模拟执行异步操作。 setTimeout执行函数setTimeout 是用来制定某段函数或代码，在多少毫秒延迟后执行。如果传入的是一段代码，必须是字符串类型的。这时候js会调用eval来执行该代码， 出于安全与性能考虑 建议直接传入一个函数的形式来执行。delay 为延迟的时间，单位是ms1var timerId = setTimeout(func|code, delay); 参数setTimeout可以有多个参数，第三个参数开始为传入运行方法的参数。很经典的闭包面试题就可以用setTimeout传参来解决12for (var i = 0; i&lt; 10; i++) &#123; setTimeout(function() &#123; console.log(i)&#125; ,0) &#125; // 运行结果是输出10个10for (var i = 0; i&lt; 10; i++) &#123; setTimeout(function(i) &#123; console.log(i)&#125; ,0, i) &#125; // 运行结果是输出0-9 运行环境setTimeout的运行环境是全局(eval)。demo1123456789var x = 1;var o = &#123; x: 2, y: function() &#123; console.log(this.x); &#125;&#125;setTimeout(o.y, 0); // 此时输出的是1，因为全局(window)上的x属性是1 demo2123456789function User(login) &#123; this.login = login; this.sayHi = function() &#123; console.log(this.login); &#125;&#125;var user = new User('John');setTimeout(user.sayHi, 0); // undefined 因为执行的时候 全局对象没有 login这个属性 解决方法一： 放到一个匿名函数里面执行方法1123setTimeout(function() &#123; user.sayHi();&#125;); 解决方法二： 缓存当前的this变量方法2123456document.body.addEventListener('click', function() &#123; var _this = this; setTimeout(function() &#123; _this.value = 'ok'; &#125;)&#125;, false); 解决方法三： 目前项目中最常用， 用es6的箭头函数方法31setTimeout(()=&gt; user.sayHi(), 0); setIntervalsetInterval的使用方法与参数和setTimeout一致。 不过setInterval是间隔 Xms 执行一次该函数。但实际上 函数执行需要时间，所以两次执行函数之间的间隔会小于 setInterval指定的时间. setInterval 执行时间假定setInterval指定每100ms执行一次，每次执行的函数耗时为 5ms, 那么第一次执行结束后的 95ms 后会执行第二段函数。如果某次执行特别耗时 如 105ms, 那么 当它结束后，会立即执行下一次的函数。 此段为某博客看到的，个人实践得出执行时间有快与慢的偏差没有绝对提前执行 下面看代码例子demo31234567891011121314151617function init() &#123; // 耗时 5ms 的某个操作 handleMouseClick(); // 耗时 5ms 的某个操作 setInterval(timerTask, 10); // 耗时 5ms 的某个操作&#125;function handleMouseClick() &#123; // 耗时 8ms 的某个操作&#125;function timerTask() &#123; // 耗时 2ms 的某个操作&#125;init(); 网上博客说法（此处保留意见）：0-15ms: 运行init15-23ms: 运行handleMouseClick函数。请注意，这个函数是在5ms时触发的，应该在那个时候就立即运行，但是由于单线程的关系，必须等到init函数完成之后再运行。23-25ms: 运行timerTask函数。 规定每10ms运行一次，既在20ms， 30ms， 40ms会运行。但是由于当前还有任务在运行，因此必须延迟到前面任务完成后再运行30-32ms: 运行timerTask40-42ms: 运行timerTask 由于平时debug调试时，在handleMouseClick应该不会等到init运行后再执行。于是抱着学习的态度自己写了一段代码demo412function _init() &#123; demo(10);console.log(1); demo(10); handle(); demo(10);console.log(2); setInterval(()=&gt; console.log('setInterval'), 1000); console.log(3) &#125;; function handle() &#123;demo(15); console.log('handle')&#125;;function demo(i) &#123;var sum = 0; for (var j = 0; j &lt; i * 1000000; j++) &#123;sum += j;&#125;&#125;;_init(); 利用for循环来造成运行实践的延长运行 _init() 结果是：① 输出1 隔26ms后 输出handle 隔10ms后 输出2 同一时间输出3(此处可以理解成执行的时间小于1ms)。此时 _init()执行结束 由于没有返回值，所以会默认返回 undefined② _init()执行结束之后 再去跑 setInterval定时器 所以 隔 1000ms(实际是1005ms) 后输出第一个setInterval。间隔 999ms后输出第二个setInterval 间隔 997ms后输出第三个 setInterval所以觉得说setInterval是当前所有函数运行后才开启定时的，而不是执行到setInterval的时候开始计时。而且运行的间隔不是固定偏多或偏少 最后再给出一个例子理解setTimeout的异步执行机制demo512345678910111213141516171819setTimeout(function() &#123; console.log("Timeout");&#125;, 0);function a(x) &#123; console.log("a() 开始运行"); b(x); console.log("a() 结束运行");&#125;function b(y) &#123; console.log("b() 开始运行"); console.log("传入的值为" + y); console.log("b() 结束运行");&#125;console.log("当前任务开始");a(42);console.log("当前任务结束"); 运行结果为当前任务开始a() 开始运行b() 开始运行传入的值是 42b() 运行结束a() 运行结束当前任务结束timeout 后记无。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webstorm 快捷键整理]]></title>
      <url>%2F2017%2F05%2Fwebstorm%2F</url>
      <content type="text"><![CDATA[alt =&gt; optioncommand =&gt; 开始control =&gt; ctrlbutton 1 click 鼠标左键button 2 click 鼠标右键斜体 为不常用粗体 为常用 Editor Actions Add or Remove Caret =&gt; 类似sublime的多行编辑功能 =&gt; alt + button1 Click Add Rectangular selection on mouse drag =&gt; 鼠标矩形选择 =&gt; remove keyMap 没啥卵用 Backspace =&gt; 退格（既删除）=&gt; Backspace 键盘上的退格键，没什么可说的 Move Caret Backward a Paragraph =&gt; 移动光标到上一个段落（既上一个空行处） =&gt; 默认无 Choose lookup item =&gt; Enter =&gt; 既选择当前智能提示的项 Choose Lookup Item and Invoke Complete Statement =&gt; 不知道有什么用 Choose Lookup Item and Insert Dot =&gt; 选择当前项并再最后加入. 既自动完成Enter + . Choose Lookup Item Replace =&gt; 不知道有什么用 Clone Caret Above =&gt; 在当前行上创建多一个光标，不常用 Clone Caret Below =&gt; 在当前行下创建多一个光标，不常用 Move Caret to Code Block End =&gt; 将光标移至块代码结束 =&gt; command + ] || alt + ] Move Caret to Code Block Start =&gt; 将光标移至块代码开始 =&gt; command + [ || atl + [ Move Caret to Code Block End with Selection =&gt; 将光标移至块代码结束并选择, 不常用 Move Caret to Code Block Start with Selection =&gt; 将光标移至块代码开始并选择, 不常用 Complete Current Statement =&gt; 完成当前声明（语句），既如果该行结束则加; 如果是 if (a = 10) 则开一个{} 并将光标移至花括号内 =&gt; 默认 ctrl + shift + enter 不常用 Create Rectangular Selection =&gt; 创建矩形选择 =&gt; alt+shift+button2 click Cut Line Backward =&gt; 从当前光标向前选择并剪切 Cut up to Line End =&gt; 从当前光标向后选择并剪切 Decrease Font Size =&gt; 缩小字体 Delete =&gt; 删除 (和Backspace用起来效果一致) =&gt; 退格键 Delete Line =&gt; 删除整行 一般我都会用 command + x || ctrl + x 代替，既直接剪切整行 Delete to Line End =&gt; 当前光标删除到行尾，一般我用command + 箭头 + shift选中后再删除 Delete to Line Start 同上 Delete to word end &amp;&amp; Delete to word start 等同理不赘述 Down with Selection 向下并选择 Shift + 向下箭头 Duplicate Line or Selection 复制该行 =&gt; 默认为ctrl + d， 但我移除了 Move caret forward a Paragraph 同上 Hungry Backspace 不知道有什么用 Increase Font Size 放大字体 Join Lines =&gt; 把下一行添加到本行，既删除换行符与空格 =&gt; ctrl + shift + j Kill selected region，Save to Kill Ring ，kill the word end, kill the word start 不知道有什么用 Move Caret to Line End =&gt; 将光标移至行尾，类似win上的end =&gt; command + → TODO: window 上修改成一致 Move Caret to Line End with Selection 移动光标至行尾并选中 =&gt; command + shift + → TODO: window上修改一致 Move Caret to Matching Brace 将光标移至当前匹配的括号 =&gt; control + m TODO: window 上的确定 Move Caret to Page Bottom 将光标移至页面底部 =&gt; command + 下箭头 Move Caret to Page Top with Selection 将光标移至页首并选中 Move Caret to Next Word 移动光标到下一个单词 =&gt; alt + → TODO: window确定 Move Caret to Prev Word 等同理 Move Cartet to Next Word with Selection 移动光标到下个单词并选中 =&gt; alt + shift + → Page Down 页面向下滚动一屏 fn + 下箭头 TODO: window Page Down with Selection 页面向下滚动一屏并选中该屏 =&gt; fn + shift + 下箭头 TODO: window Page Up &amp;&amp; Page Up with Selection 同理 Paste from X clipboard 不知道有什么用 Paste Simple 不知道有什么用 Reset Font Size 重置字体大小 Right Left Down Up 等…. Scroll To Bottom, Scroll Down …等等 都是滚动方向 Duplicate Line or Selection 复制整行或选中的区域 一般都会手动选择整行去复制 Duplicate Entire Lines Extend Selection 扩展选择 alt + 上箭头 解除 Split Line 光标下添加多一行 =&gt; command + enter TODO: window Start New Line 开启新的一行 相当于光标移至行尾，回车 =&gt; shift + enter TODO: window Start New Line Before Current 在当前行的上一行新建一行并将光标移至此处 相当于光标移到上行尾再回车 Swap selection boundaries 交换选择边界 Tab tab Move Caret to Text End, Move Caret To Text Start 等 Toggle Case 光标在大小写切换 Toggle Insert/Overwrite =&gt; 切换插入/替换 window 上的 insert 功能 shrink Selection 缩小选择 =&gt; shift + 下箭头 不知道有什么用 ​Emacs tab, Fill Paragraph, Expand Live Template / Emmet Abbreviation, Next Paramete, Prev Paramete 不知道什么用 Main menu列举平日用得到的 ##### new =&gt; 新建文件 =&gt; command + N new Scratch File 新建临时文件，比如可以新建一个es6语法的临时文件，里面写完再复制到某些地方 提供语法支持 =&gt; shift + command + n Preferences 打开设置 =&gt; command + , window: alt + ctrl + s Synchronize 重新加载磁盘文件并同步 =&gt; alt + command + y Navigate File… =&gt; 按文件名查找文件 =&gt; command + shift + O 改 command + p 和sublime Text保持一致 Edit Undo =&gt; 撤销 =&gt; command + z Redo =&gt; 撤销的反方向 =&gt; shift + command + z Cut =&gt; 剪切 =&gt; command + x Copy =&gt; 复制 =&gt; command + c Copy Paths =&gt; 复制路径 =&gt; command + c + shift Paste =&gt; 黏贴 =&gt; command + v— Paste from History =&gt; 打开黏贴板历史 =&gt; command + shift + v Find… =&gt; 查找 =&gt; command + f Replace… =&gt; 替换 =&gt; Command + r Add Selection for Next Occurrence =&gt; 选中相同的词 =&gt; 默认 ctrl + g 改 ctrl + d Select All =&gt; 选择所有 =&gt; command + A 自己修改的比较常见的 Select In… =&gt; alt 1 then 1 定位到当前正在编辑的文件，这个功能vscode 自动完成的 还是比较常用 以前很喜欢用webstorm, 后面在mac上面不习惯快捷键就放弃转战其他 atom等。 这次特地下来回来，设置了快捷键但最后 还是用回了vs code。最后附上配置Mac]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简单的网页点击热力图]]></title>
      <url>%2F2017%2F05%2F%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E9%A1%B5%E7%82%B9%E5%87%BB%E7%83%AD%E5%8A%9B%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[前两天老大突然喊我和一小伙子出去开会，说有个好玩的东西给你们玩。 想给网站做个简单的热力图， 记录用户点击了什么位置。要求是，怎么简单怎么实现 先做一版出来 后面再慢慢迭代优化， 定的工作量大概是两人一天。。。。 之前没接触过图表，虽然有接触过埋点统计/talkingData 不过对于这种都是一知半解。具体有两个步骤，一个是数据的记录（入库），一个是展示模式（读取）。 于是下班回到家后没事就先查了资料，想大概写个能定位置的出来看着先。 需求分析 需要传递给后台保存的数据 url 当前页面url(包不包括search, hash 等) screenHeight 屏幕高度 screenWidth 屏幕高度 list 具体坐标的数组 {x: 鼠标相对于屏幕x轴坐标, y: 鼠标相对于屏幕y轴坐标, pageX: 鼠标相对于dom文档的x轴坐标, pageY: 鼠标相对于dom文档的y轴坐标} 代表用户的一个code 不能每次点击都发送，间隔10秒发送一次 后台还没做先在本地sessionLocation做模拟测试 具体实现鼠标点击对象属性特别推荐 Mozilla 开发者平台，现在基本上js html等东西想了解具体或详细的属性都会上这个网站查询https://developer.mozilla.org/zh-CN/大部分有多语言标签。 可以先到这里查看鼠标的具体属性解析developer.mozilla 12345678以下两个指的都是已可视区域左上角为原点(0, 0) 向右 向下正坐标MouseEvent.clientX clientX属性代表点击在元素上的鼠标指针的X坐标；MouseEvent.clientY clientY属性代表点击在元素上的鼠标指针的Y坐标；以下两个指的都是物理屏幕以左上角为原点（0， 0） 向右 向下正坐标MouseEvent.screenXMouseEvent.screenY 这里传递给后台的 x 采用的是 MouseEvent.clientX; y 取的是 MouseEvent.clientY; pageX 取的是 页面滚动宽度 + x; PageY 取的是 页面滚动高度 + y 12页面滚动高度: document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop || 0页面滚动宽度: document.documentElement.scrollLeft || window.pageXOffset || document.body.scrollLeft || 0 具体页面滚动高度与宽度的兼容问题可以查看 http://www.cnblogs.com/xwgli/p/3490466.html 屏幕高度宽度屏幕高度宽度 1234window.screen.height, 屏幕高度window.screen.width, 屏幕宽度window.screen.availHeight, 屏幕可用工作区高度，如mac的除去顶部工具条外的高度window.screen.availWidth 同上 监听url变化后期优化需求，因为还不确定是要每条基本location.namepath当成一个页面还是要把每个不同的 search、hash都当成一个独立的页面。 绘制热力图绘制热力图暂时的展示效果在原页面添加一个文档大小的canvas，然后采用一个js 热力图插件https://github.com/pa7/heatmap.js传递坐标来生成热力图。 源码因为只是晚上回家临时写了一个可以看效果的，所以没有代码分离 脏数据检查 等功能app.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215// style Util Fnconst styleFn = (el, styleObj = &#123;&#125;) =&gt; &#123; if (!el) throw new Error(el); for (let [key, value] of Object.entries(styleObj)) &#123; el.style[key] = value; &#125; return el;&#125;;/** * 需要发送到后台的数据 */class HeatCollect &#123; constructor(opts = &#123;&#125;) &#123; this.initProps(opts); // 初始化属性 this.setDataForServer(); // 启动定时器 定时发送数据给服务器 return this; &#125; initProps(opts) &#123; this.list = []; this.url = location.href; this.screenHeight = window.screen.height; this.screenWidth = window.screen.width; this.serverCode = '1001'; this.index = 0; this.timer = null; this.time = opts.time || 10; // 默认10秒 this.maxLength = opts.maxLength || 100; // 默认最多可以存100个坐标 this.Time = 0; this.queue = []; // 队列 暂存请求的坐标 &#125; // 向当前类添加坐标 push(obj) &#123; obj.index = ++this.index; this.list.push(obj); this.list = this.list.splice(0, 100); // 防止恶意过长 return this.list; &#125; // 获取向服务器传递的数据格式 getServerData() &#123; return &#123; list: this.queue, url: this.url, screenHeight: this.screenHeight, screenWidth: this.screenWidth, serverCode: this.serverCode, timestamp: Date.now(), &#125; &#125; // 发送数据到服务器 setDataForServer() &#123; clearTimeout(this.timer); this.timer = setTimeout(() =&gt; &#123; this.queue = this.list.splice(0, Math.min(this.list.length, 100)); if (!this.queue.length) return this.setDataForServer(); Server.setData(this.getServerData()).then((&#123; code &#125;) =&gt; &#123; if (code === 0) &#123; this.queue = []; &#125; else &#123; this.list = this.queue.concat(this.list); &#125; &#125;, () =&gt; &#123; this.list = this.queue.concat(this.list); &#125;).then(() =&gt; &#123; this.setDataForServer(); &#125;); &#125;, this.time * 1000) &#125;&#125;/** * 绘制函数 */class Draw &#123; constructor() &#123; this.initCanvas(); return this; &#125; // 初始化展示的dom initDom() &#123; let dom = document.createElement('div'), domParent = document.createElement('div'); dom.id = 'heatmapContainer'; domParent.id = 'heatmapContainerWrapper'; domParent.appendChild(dom); domParent.style.height = document.documentElement.offsetHeight + 'px'; domParent.style.width = document.documentElement.offsetWidth + 'px' ; document.body.appendChild(domParent); &#125; // 初始化展示的canvas initCanvas() &#123; this.initDom(); this.heatmap = h337.create(&#123; container: document.getElementById('heatmapContainer'), maxOpacity: .6, radius: 50, blur: .90, backgroundColor: 'rgba(0, 0, 0, 0)' &#125;); &#125; // 遍历绘制canvas上的热点 draw(list) &#123; for (let i = 0; i &lt; list.length; i++) &#123; this.heatmap.addData(this.getDrawData(list[i])); &#125; &#125; // 获取要绘制的数据格式 getDrawData(data) &#123; return &#123; x: data.pageX, y: data.pageY, value: 1 &#125; &#125;&#125;/** * 处理兼容等工具类 */const Util = &#123; // 获取鼠标坐标 getMouseInfo(e) &#123; let &#123; officeX, officeY &#125; = this.getPageOffice(), &#123; clientX: x, clientY: y &#125; = e; return &#123; pageX: officeX + x, pageY: officeY + y, x, y, &#125; &#125;, // 获取页面高宽 getPageOffice() &#123; let officeY = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop || 0, officeX = document.documentElement.scrollLeft || window.pageXOffset || document.body.scrollLeft || 0; return &#123; officeX, officeY &#125; &#125;,&#125;;/** * 入口函数 */const Main = &#123; init() &#123; this.infoData = new HeatCollect(); this.draw = new Draw(); document.documentElement.addEventListener('click', (e) =&gt; this.mouseEvent(e)); &#125;, mouseEvent(e) &#123; let _mouseData = Util.getMouseInfo(e); this.infoData.push(_mouseData); &#125;, drawFn() &#123; let list = JSON.parse(sessionStorage.getItem('test') || '&#123;&#125;').list || []; this.draw.draw(list); &#125;&#125;;Main.init();Main.drawFn();// 模拟发送请求const Server = &#123; setData(data) &#123; return new Promise((res, rej) =&gt; &#123; setTimeout(() =&gt; &#123; let isSuccess = Math.random() &lt; .95; if (isSuccess) &#123; let oldData = sessionStorage.getItem('test'); if (oldData) &#123; oldData = JSON.parse(oldData); oldData.list = oldData.list.concat(data.list); &#125; else &#123; oldData = data; &#125; sessionStorage.setItem('test', JSON.stringify(oldData)); console.log('success', oldData.list); res(&#123; code: 0, data &#125;) &#125; else &#123; rej(&#123; code: 5000 &#125;) &#125; &#125;, 2000); &#125;); &#125;&#125;; index.html1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;style&gt; body, html &#123; height: 3000px; width: 2000px; &#125; #heatMap &#123; height: 100%; width: 100%; position: relative; border:1px solid red; &#125; #heatmapContainer &#123; width:100%; height:100%; &#125; #heatmapContainerWrapper &#123; position:absolute; left: 0; right: 0; top: 0; bottom: 0;&#125;&lt;/style&gt;&lt;script src="heatmap.js"&gt;&lt;/script&gt;&lt;script src="app.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; html中引入的热力图 后话效果图至此 简单的热力图实现完成， 隔天回到公司，老大说 公司已经和第三方服务平台购买了统计之类的服务。。。。。。于是乎当做是自己饭后无聊写点代码消遣消遣。不过热力图很多东西需要处理，不是一两个人短时间可以完成的。最后附上效果与项目目录]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[imooc-react-native实战 项目入门知识学习]]></title>
      <url>%2F2017%2F05%2Fimooc-react-native%E5%AE%9E%E6%88%98-%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[选用的版本的 v0.22.2 组件生命周期初始化开始 =&gt; getDefaultProps =&gt; getInitialState =&gt; componentWillMount =&gt; render =&gt; componentDidMount =&gt; 组件运行中， state状态改变 =&gt; shouldComponentUpdate 判断是否要更新 return true =&gt; componentWillUpdate =&gt; render 继续循环 =&gt; 外部props改变 =&gt; componentWillReceiveProps =&gt; unmount 卸载组件 =&gt; componentWillUnmount 等等]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ios网络操作基础教程]]></title>
      <url>%2F2017%2F05%2Fios%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[demo源码 网络解析与网络请求有关的类 NSURL: 客户端访问哪台服务器的制定资源 NSURLRequest: 客户端发起的网络请求内容 : 客户端服务器建立的网络连接 NSURLResponse: 服务端给予客户端的响应结果 发起第一个网络请求AppDelegate.m123456789101112131415161718192021- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. // 创建一个url对象 用来表示访问的服务器 NSURL *url = [NSURL URLWithString:@"http://www.imooc.com"]; // 客户端发起的网络请求的请求内容 NSURLRequest *request = [NSURLRequest requestWithURL: url]; NSURLConnection *connection = [[NSURLConnection alloc] initWithRequest:request delegate:self]; // 启动网络请求 [connection start]; return YES;&#125;- (void) connection: (NSURLConnection *) connection didReceiveResponse: (NSURLResponse * )response &#123; // 服务器给客户端的响应结果 NSLog(@"response: %@", response);&#125; 键入以上代码后按cmd+r运行一下，此时控制台并没有输出我们想要的结果，而是输出了1App Transport Security has blocked a cleartext HTTP (http://) resource load since it is insecure. Temporary exceptions can be configured via your app&apos;s Info.plist file. 提示我们已经阻止了明文http请求，因为他是不安全的，可以通过Info.plist配置解除请求。在项目根目录里打开Info.plist， 添加 App Transport Security Settings 并在App Transport Security Settings下添加Allow Arbitrary Loads值为YES。 然后重新运行就好了 使用Get方式发送请求搭建用户信息界面api接口已经返回的参数格式结构 新建项目新建cocoa Class=&gt;UserInfoViewController继承UIViewController新建cocoa Class=&gt;KeyValueView继承UIView如图 先在KeyValueView.h 声明所需的变量已经方法KeyValueView.h12345678@interface KeyValueView : UIView@property (nonatomic, strong) UILabel *keyLabel;@property (nonatomic, strong) UILabel *valueLabel;- (void) setupKey: (NSString *)key value:(NSString *)value;@end 并在KeyValueView.m实现KeyValueView.m1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#import "KeyValueView.h"@implementation KeyValueView-(id) initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; // 添加keyLabel // 如果存在父级，则创建一个 UILabel x:0, y:0, 宽：父级宽度1/3, 高: 父级高度 _keyLabel = [[UILabel alloc] initWithFrame: CGRectMake(0, 0, CGRectGetWidth(self.frame) /3, CGRectGetHeight(self.frame))]; // 设置背景色为透明 _keyLabel.backgroundColor = [UIColor clearColor]; // 文字居左对齐 _keyLabel.textAlignment = NSTextAlignmentLeft; // 设置字体大小 _keyLabel.font = [UIFont systemFontOfSize: 16]; // 设置字体颜色 _keyLabel.textColor = [UIColor blackColor]; // 添加到父级 [self addSubview: _keyLabel]; // 添加valueLabel // 如果存在父级，则创建一个 UILabel x:0, y:0, 宽：父级宽度1/3, 高: 父级高度 _valueLabel = [[UILabel alloc] initWithFrame: CGRectMake(CGRectGetWidth(self.frame) /3, 0, CGRectGetWidth(self.frame) * 2 /3, CGRectGetHeight(self.frame))]; // 设置背景色为透明 _valueLabel.backgroundColor = [UIColor clearColor]; // 文字居左对齐 _valueLabel.textAlignment = NSTextAlignmentLeft; // 设置字体大小 _valueLabel.font = [UIFont systemFontOfSize: 16]; // 设置字体颜色 _valueLabel.textColor = [UIColor blackColor]; // 添加到父级 [self addSubview: _valueLabel]; &#125; return self;&#125;-(void)setupKey:(NSString *)key value:(NSString *)value&#123; // 给keyLabel &amp;&amp; valueLabel 赋值的方法 [_keyLabel setText:key]; [_valueLabel setText:value];&#125; 接着我们要在UserInfoViewController去调用keyValueView的UIView类UserInfoViewController.h1234567891011121314#import &lt;UIKit/UIKit.h&gt;// 引入keyvalue#import "KeyValueView.h"@interface UserInfoViewController : UIViewController// 把所有个人信息录到这里 ( 声明 )@property (nonatomic, strong) KeyValueView *userNameView; // 用户名信息@property (nonatomic, strong) KeyValueView *userSexView; // 用户性别@property (nonatomic, strong) KeyValueView *birthdayView; // 生日@property (nonatomic, strong) KeyValueView *emailView; // email@property (nonatomic, strong) KeyValueView *phoneView; // 手机号@end UserInfoViewController.m1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#import "UserInfoViewController.h"//定义两个宏 屏幕宽度与高度，一般项目都会定义方便使用#define KScreenWidth [[UIScreen mainScreen] bounds].size.width#define KScreenHeight [[UIScreen mainScreen] bounds].size.height@interface UserInfoViewController ()@end@implementation UserInfoViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. // 给父级加背景色 [self.view setBackgroundColor: [UIColor whiteColor]]; // 手动创建一个标题 UILabel *titleLable = [[UILabel alloc] initWithFrame:CGRectMake(0, 40, KScreenWidth, 20)]; // 设置标题信息 [titleLable setText:@"个人用户信息"]; titleLable.textAlignment = NSTextAlignmentCenter; titleLable.font = [UIFont systemFontOfSize:18]; titleLable.backgroundColor = [UIColor clearColor]; [self.view addSubview: titleLable]; // 创建一个用户名控件 _userNameView = [[KeyValueView alloc] initWithFrame:CGRectMake(100, 70, KScreenWidth - 100 * 2, 30)]; _userNameView.backgroundColor = [UIColor clearColor]; [self.view addSubview:_userNameView]; // 创建一个用户性别控件 _userSexView = [[KeyValueView alloc] initWithFrame:CGRectMake(100, 70 + 30, KScreenWidth - 100 * 2, 30)]; _userSexView.backgroundColor = [UIColor clearColor]; [self.view addSubview:_userSexView]; // 创建一个用户生日控件 _birthdayView = [[KeyValueView alloc] initWithFrame:CGRectMake(100, 70+30*2, KScreenWidth - 100 * 2, 30)]; _birthdayView.backgroundColor = [UIColor clearColor]; [self.view addSubview:_birthdayView]; // 创建一个用户邮箱控件 _emailView = [[KeyValueView alloc] initWithFrame:CGRectMake(100, 70 + 30*3, KScreenWidth - 100 * 2, 30)]; _emailView.backgroundColor = [UIColor clearColor]; [self.view addSubview:_emailView]; // 创建一个用户手机号控件 _phoneView = [[KeyValueView alloc] initWithFrame:CGRectMake(100, 70 + 30*4, KScreenWidth - 100 * 2, 30)]; _phoneView.backgroundColor = [UIColor clearColor]; [self.view addSubview:_phoneView];&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;/*#pragma mark - Navigation// In a storyboard-based application, you will often want to do a little preparation before navigation- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123; // Get the new view controller using [segue destinationViewController]. // Pass the selected object to the new view controller.&#125;*/@end view &amp;&amp; controller都写好之后，我们去修改一下AppDelegate，因为默认主view为项目根目录的ViewControll，所以如果我们没有把view设置为我们的UserInfoViewController 运行是没有任何效果的。 AppDelegate.m1234567- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // 第二节 get请求 UserInfoViewController *userInfoVC = [[UserInfoViewController alloc] init]; self.window.rootViewController = userInfoVC; [self.window makeKeyAndVisible]; return YES;&#125; 修改完成后再次运行看效果。此时只出现了标题。 这时候我们可以打开调试看一下为什么我们只出现标题，没有出现KeyValueView呢依次打开xCode菜单Debug=&gt;View Debugging=&gt;Show View Frames这时候可以看到我们的labelView其实是有被加到view中，只是没有数据展示 所以看不出来，接下来我们正式开始发起网络请求数据填充view 发起网络请求数据http://www.imooc.com/video/11982 imooc ios网络操作学习指南]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS基础教程之界面初体验]]></title>
      <url>%2F2017%2F04%2FiOS%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E7%95%8C%E9%9D%A2%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
      <content type="text"><![CDATA[demo源码 如果找不到，则到finish文件下找 创建项目因为要学的是 UIwindow， 所以创建的不再是之前的Command Line Tool。 选择iOS=&gt;Single View Application.语言选择ObjectiveC, 项目名根据自己喜欢的取。 Hello UIwindowmain.m 入门文件不再出现在根目录上，而是在Supporting Files下。默认引用了 &lt;UIKit/UIKit.h&gt; 和 &quot;AppDelegate.h&quot; 点击项目文件 删除 Main Interface的默认值Main 然后打开AppDelegate.m 开始来手动来设置一下mainInterfacez AppDelegate.m123456789101112- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. // 设置大小和位置 `UIScreen mainScreen` 可以得到手机主屏幕 `bounds`是获得大小 _window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; // 设置颜色为红色 _window.backgroundColor = [UIColor redColor]; // 设置根视频控制器 _window.rootViewController = [[UIViewController alloc] init]; // 将window设置为我们的主window [_window makeKeyAndVisible]; return YES;&#125; 修改后按 cmd(⌘)+R或按左上角的三角形按钮来 run app。骚等片刻就可以看到 一个全屏红色的模拟器.; UIView新建一个项目。 UI的基类， 基础 UIView的属性 UIView的方法 UIView的自适应 ViewController.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129//// ViewController.m// UIwindow//// Created by Jsonz on 2017/4/27.// Copyright © 2017年 Jsonz. All rights reserved.//#import "ViewController.h"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; NSLog(@"bilibili"); [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 视图 UIView *view1 = [[UIView alloc] init]; // 实例化view // 状态栏高度为20px 所以写view的时候一般会让出20px view1.frame = CGRectMake(10, 30, 375-20, 667-20); // 背景颜色 view1.backgroundColor = [UIColor redColor]; // 将视图加入到父视图中 [self.view addSubview: view1]; // self.view 是view1的父视图 NSLog(@"frame = x:%f y:%f w:%f h:%f", view1.frame.origin.x, view1.frame.origin.y, view1.frame.size.width, view1.frame.size.height); // 一般叫边框大小， x &amp;&amp; y 永远为0 w&amp;&amp;h 一致 NSLog(@"bounds = x:%f y:%f w:%f h:%f", view1.bounds.origin.x, view1.bounds.origin.y, view1.bounds.size.width, view1.bounds.size.height); // center - 中心点 NSLog(@"center - x:%f y:%f", view1.center.x, view1.center.y); // 图片 1.png // 如果是二倍视网膜屏幕 准备 1@2x.png // 同理还有 1@3x.png NSLog(@"w:%f h:%f",[[UIScreen mainScreen] bounds].size.width, [[UIScreen mainScreen] bounds].size.height); // 父视图 只会有一个 UIView *superView = view1.superview; superView.backgroundColor = [UIColor greenColor]; UIView *view2 = [[UIView alloc] init]; view2.frame = CGRectMake(10, 100, 300, 300); // 坐标全是根据自身父视图来设置的，不会跨层 // 给view设置唯一标识，方便父级视图获取辨认 view2.tag = 2; view2.backgroundColor = [UIColor blackColor]; [view1 addSubview:view2]; UIView *view3 = [[UIView alloc] init]; view3.frame = CGRectMake(20, 50, 100, 100); view3.tag = 3; view3.backgroundColor = [UIColor purpleColor]; [view1 addSubview:view3]; // 子视图 会有多个 NSArray *subViewsArray = view1.subviews; for (UIView *view in subViewsArray) &#123; if (view.tag == 2) view.backgroundColor = [UIColor whiteColor]; // view2变白色 &#125; // 如果知道子视图的tag 可以通过tag得到对应的子视图 UIView *subView = [view1 viewWithTag:3]; subView.backgroundColor = [UIColor greenColor]; // 修改层级 类似css 的 zIndex // 当层交换之后， 对应的子视图的数组下标也会进行改变 // 同一个父视图中，先加入的view层级会比较低 UIView *view4 = [[UIView alloc] init]; view4.frame = CGRectMake(0, 100, 300, 300); view4.backgroundColor = [UIColor yellowColor]; [self.view insertSubview:view4 atIndex:0]; // 这时候 view4会盖住view1的所有界面 // 交换两个层的视图 [superView exchangeSubviewAtIndex:0 withSubviewAtIndex:1]; //插入一个视图到指定层 UIView *view5 = [[UIView alloc] init]; view5.frame = CGRectMake(7, 80, 200, 200); view5.backgroundColor = [UIColor blackColor]; [view1 insertSubview:view5 atIndex:1]; // 将一个view 放最顶层或最底层 [view1 bringSubviewToFront:view2]; // 顶层 [view1 sendSubviewToBack: view2]; // 底层 // 自适应 UIView *backView = [[UIView alloc] init]; backView.frame = CGRectMake([UIScreen mainScreen].bounds.size.width / 2 - 25, [UIScreen mainScreen].bounds.size.height /2 - 25, 50, 50); // 自适应到屏幕中部 backView.backgroundColor = [UIColor orangeColor]; backView.tag = 1001; // 准许子视图自适应 backView.autoresizesSubviews = YES; [self.view addSubview: backView]; UIView *topView = [[UIView alloc] init]; topView.frame = CGRectMake(10, 10, 30, 30); topView.backgroundColor = [UIColor greenColor]; // 再设置子视图的适应方式 左侧适应 topView.autoresizingMask = UIViewAutoresizingFlexibleRightMargin | UIViewAutoresizingFlexibleLeftMargin | UIViewAutoresizingFlexibleTopMargin | UIViewAutoresizingFlexibleBottomMargin | UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight; // 右， 左， 上， 下， 宽， 高 跟随父级自适应 [backView addSubview: topView]; // 按钮 下节课会讲到 UIButton *btn = [UIButton buttonWithType: UIButtonTypeSystem]; btn.frame = CGRectMake(10, 550, 355, 30); btn.backgroundColor = [UIColor brownColor]; [btn addTarget:self action:@selector(btnClick) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview: btn];&#125;-(void)btnClick&#123; UIView *view = [self.view viewWithTag:1001]; view.frame = CGRectMake(view.frame.origin.x - 5, view.frame.origin.y -5, view.frame.size.width + 10, view.frame.size.height + 10);&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end UILabel 文本标签 UIColor 颜色类 新建一个项目 ViewController12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 文本标签 UILabel *label = [[UILabel alloc] init]; label.frame = CGRectMake(10, 100, 300, 30); label.backgroundColor = [UIColor yellowColor]; // 文本 label.text = @"我是一个IOS FONT"; // 文字布局 NSTextAlignmentCenter NSTextAlignmentLeft NSTextAlignmentRight 等等 label.textAlignment = NSTextAlignmentCenter; // 文字颜色 // clearColor透明色 // colorWithRed green blue alpha 类似css的rgba label.textColor = [UIColor colorWithRed:.1 green:.8 blue:.2 alpha:1]; // label的透明度 label.alpha = .9; // 字体设置 label.font里面 label.font = [UIFont systemFontOfSize: 25]; // 字号 // 加粗或倾斜 label.font = [UIFont boldSystemFontOfSize:25];// 加粗和25号字，会覆盖前面设置 label.font = [UIFont italicSystemFontOfSize:25]; // 倾斜 // 看系统有哪些字体 for (NSString *name in [UIFont familyNames]) &#123; NSLog(@"font = %@", name); &#125; // 设置字体 label.font = [UIFont fontWithName:@"Bodoni 72 Smallcaps" size:25]; // 文字阴影// label.shadowColor = [UIColor redColor];// label.shadowOffset = CGSizeMake(1, 1); // 多文字处理 会自动出现... label.text = @"topView.autoresizingMask = UIViewAutoresizingFlexibleRightMargin | UIViewAutoresizingFlexibleLeftMargin | UIViewAutoresizingFlexibleTopMargin | UIViewAutoresizingFlexibleBottomMargin | UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight; // 右， 左， 上， 下， 宽， 高 跟随父级自适应[backView addSubview: topView]"; // 如果要换行 // 1. 首先label要足够大 // 2. 设置换行模式 // 3. 设置显示行数 label.frame = CGRectMake(20, 20, [UIScreen mainScreen].bounds.size.width - 40, [UIScreen mainScreen].bounds.size.height - 40); label.lineBreakMode = NSLineBreakByCharWrapping; label.numberOfLines = 2; // 如果设置到-1或0 就不会限制行数，能显示多少行就显示多少行 [self.view addSubview:label]; &#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125; UIImageView 图片view新建一个项目,添加自己喜欢的照片到项目里。 比如我 肯定是添加GAKKI的 ViewController.m12345678910111213141516171819202122232425262728293031323334353637383940- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 首先 随便加载几张图片到项目中 // 获取图片路径 NSString *path = [[NSBundle mainBundle] resourcePath]; // 工程目录 NSString *imgPath = [NSString stringWithFormat: @"%@/2.jpg", path]; // 拼接图片路径 // 后面参数为图片路径 UIImage *image = [[UIImage alloc] initWithContentsOfFile: imgPath]; // 加载完会释放，不会存在内存中，不过每次都会去加载// image = [UIImage alloc] initWithData:&lt;#(nonnull NSData *)#&gt; 2进制格式图片加载// UIImage *image1 = [UIImage imageNamed:@"2"]; // 这种直接写文件名，如果是png格式的，可以省略后缀名 这种方式直接把图片放到内存中，占用内存但是下次调用会很快。 比如qq表情，可以放到缓存（内存）中 // 图片显示必须要有载体 UIImageView *imageView = [[UIImageView alloc] initWithImage: image]; // image.size.width image.size.height imageView.frame = CGRectMake(10, 100, 400, 400); // 内容模式 居中： UIViewContentModeCenter // 默认为UIViewContentModeScaleToFill 拉伸充满整个载体 // UIViewContentModeScaleAspectFit 拉伸但不改变比例，充满小的边框 // UIViewContentModeScaleAspectFill 拉伸但不改变比例，充满大的边框 // 学过css的 应该都很容易理解 background-size模式 imageView.contentMode = UIViewContentModeScaleAspectFit; // UIImageView 动画 - 播放序列图 略! // 图片显示在屏幕上的大小是载体来控制的 [self.view addSubview: imageView]; &#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Foundation 入门]]></title>
      <url>%2F2017%2F04%2FFoundation-%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[Foundation(基础框架) 课程知识比较多，所以后面会每个学习内容新建一个类去写。 新建一个项目， 文章源码,找不到则到finish里面找 String新建一个String类String.h12345#import &lt;Foundation/Foundation.h&gt;@interface String : NSObject-(void) stringBaseFn; // 声明一个函数，后面有关的字符串函数知识都写在该方法内@end main.m123456789101112// 引入并调用该方法，主要是一些字符串的方法 以及输出#import &lt;Foundation/Foundation.h&gt;#import "String.h"int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; String *str = [[String alloc] init]; [str stringBaseFn]; &#125; return 0;&#125; String.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132//// String.m// foundation//// Created by Jsonz on 2017/4/23.// Copyright © 2017年 Jsonz. All rights reserved.//#import "String.h"@implementation String-(void) stringBaseFn&#123; char *s = "Hello C"; // c语言字符串 char 类型 *号代表对象 // OC 中@代表对象 NSString *str = @"Hello ObjectiveC"; // OC 字符串 NSString 类型 *号代表对象 // OC 与 C字符串的类型转换 // C -&gt; OC NSString *str1 = [NSString stringWithUTF8String:s]; NSLog(@"str1 = %@", str1); // OC -&gt; C NSLog(@"str2 = %s", [str UTF8String]); // 这样创建字符串，不需要自己手动去释放内存等 NSString *str3 = @"IOS"; // 这种需要手动释放内存 NSString *str4 = [[NSString alloc] init]; str4 = @"ios"; // **格式化字符串** 重要 int a = 10; NSString *str5 = [NSString stringWithFormat:@"a = %d str3 = %@", a, str3]; NSLog(@"str5 为 %@", str5); // 拼接字符串 NSString *str6 = [str5 stringByAppendingString: [NSString stringWithUTF8String: s]]; NSLog(@"str6 = %@", str6); // 大小写的转换问题 NSString *str7 = @"HELLO JSONZ"; NSString *str8 = [str7 lowercaseString]; NSLog(@"str8 = %@", str8); // 转换大写 NSString *str9 = [str8 uppercaseString]; NSLog(@"str9 = %@", str9); // 前缀和后缀的判断 NSString *str10 = @"www.imooc.com"; // 判断前缀 BOOL hasPreFix = [str10 hasPrefix:@"www."]; if (hasPreFix) NSLog(@"有对应前缀"); else NSLog(@"没有对应前缀"); // 后缀 BOOL hasSuffix = [str10 hasSuffix:@".com"]; if (hasSuffix) NSLog(@"有对应后缀"); else NSLog(@"没有对应后缀"); // 判断字符串是否相同 NSString *str11 = @"Hello"; NSString *str12 = @"Hello"; if ([str11 isEqualToString:str12]) NSLog(@"str11 与 str12 一致"); else NSLog(@"不一致"); // 分割字符串 // 1. 按照指定字符分割字符串 返回数组 NSString *str13 = @"a,b,c,d,e,f,g"; NSArray *strArray = [str13 componentsSeparatedByString:@","]; for (NSString *str in strArray) &#123; NSLog(@"str = %@", str); &#125; // 2. 按照范围截取字符串 NSRange range = NSMakeRange(1, 5); NSString *str14 = [str13 substringWithRange:range]; NSLog(@"str14 = %@", str14); // 3. 从某一位开始截取到结束 NSString *str15 = [str13 substringFromIndex:2]; NSLog(@"str15 = %@", str15); // 4.从开头到某一位 NSString *str16 = [str13 substringToIndex:7]; NSLog(@"str16 = %@", str16); // 5.将字符串拆分为每一个字符, 从字符串取出某一位 for (int i = 0; i &lt; [str13 length]; i++) &#123; NSLog(@"%c", [str13 characterAtIndex:i]); &#125; // 查找 NSString *str17 = @"ab cd ef gh ij ab"; // 查找指定字符串的位置 正向查找 NSRange range1 = [str17 rangeOfString:@"ab"]; NSLog(@"range1.location: %ld range1.length: %ld", range1.location, range1.length); // 替换 NSString *str18 = @"Hello ios, Hello imooc"; // 替换某一个范围的内容 NSString *str19 = [str18 stringByReplacingCharactersInRange:NSMakeRange(0, 5) withString:@"你好"]; NSLog(@"str19 = %@", str19); // 用指定字符串替换原字符串 NSString *str20 = [str18 stringByReplacingOccurrencesOfString:@"Hello ios" withString: @"第一个参数为源字符串中要被替换的内容， 第二个为替换成的字符串"]; NSLog(@"str20 = %@", str20); // 读取文件 // 1. 本地文件； 2.网络文件 // 路径类 NSString *str21 = @"www.baidu.com"; // 网络路径 NSURL *httpURL = [NSURL URLWithString:str21]; //本地路径// NSString *fileURL = [NSURL fileURLWithPath:str21]; // 读取网络文件 NSString *httpStr = [NSString stringWithContentsOfURL:httpURL encoding:NSUTF8StringEncoding error:nil]; NSLog(@"httpStr = %@", httpStr); // 读取本地文件 NSString *fileStr = [NSString stringWithContentsOfFile: @"/Users/jsonz/Documents/learn/Objective-c/foundation/foundation/app.txt" encoding:NSUTF8StringEncoding error: nil]; NSLog(@"fileStr = %@", fileStr); // 写入文件 NSString *str22 = @"Hello JSer"; BOOL isOk = [str22 writeToFile:@"/Users/jsonz/Documents/learn/Objective-c/foundation/foundation/app.js" atomically:YES encoding:NSUTF8StringEncoding error:nil]; if (isOk) NSLog(@"文件写入成功"); else NSLog(@"文件写入失败");&#125;@end NSMutableString 可变字符串新建一个 NSMutableStringClass 类。 NSMutableString是字符串的子类 NSMutableString.h12345678910111213//// NSStringClass.h// foundation//// Created by Jsonz on 2017/4/25.// Copyright © 2017年 Jsonz. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@interface NSMutableStringClass : NSObject-(void) ShowNSMutableString;@end NSMutableString.m123456789101112131415161718192021222324252627282930313233343536373839404142//// NSStringClass.m// foundation//// Created by Jsonz on 2017/4/25.// Copyright © 2017年 Jsonz. All rights reserved.//#import "NSMutableStringClass.h"@implementation NSMutableStringClass-(void) ShowNSMutableString&#123; // 可变字符串的简单方法 // 可变字符串是字符串的子类 // 实例化 NSMutableString *str = [[NSMutableString alloc] initWithCapacity:10]; // 分类长度不可以超过10， 性能优化。不过超过10 也不会报错 [str setString:@"hello "]; // 1.追加字符串 [str appendString:@"ObjectiveC"]; NSLog(@"str = %@", str); // 追加格式化字符串 int a = 10; [str appendFormat:@" - %d", a]; NSLog(@"str = %@", str); // 2.替换字符串 NSRange range = [str rangeOfString:@"ObjectiveC"]; [str replaceCharactersInRange:range withString:@"IOS"]; NSLog(@"str = %@", str); // 3. 插入字符串 [str insertString:@"A" atIndex: 4]; NSLog(@"str = %@", str); // 4. 删除字符串 NSRange range1 = [str rangeOfString:@"IOS"]; [str deleteCharactersInRange:range1]; NSLog(@"str = %@", str);&#125;@end main.m 调用前记得引入类12NSMutableStringClass *_NSMutableString = [[NSMutableStringClass alloc] init];[_NSMutableString ShowNSMutableString]; NSArray 不可变数组新建一个arr类 Arr.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//// Arr.m// foundation//// Created by Jsonz on 2017/4/26.// Copyright © 2017年 Jsonz. All rights reserved.//#import "Arr.h"@implementation Arr-(void) showArrFn&#123; NSLog(@"不可变数组"); // OC数组。 可以存储不同类型对象,只能存储对象.(int, char)不可以 // 只存对象指针（js一样) NSArray *arr1 = [[NSArray alloc] initWithObjects:@"1", @"2", @"3", @"4", @"5", nil]; // 数组长度 int count = (int)arr1.count; NSLog(@"count = %d", count); // 判断是否有该对象 BOOL isHave = [arr1 containsObject: @"2"]; if (isHave) NSLog(@"存在"); else NSLog(@"不存在"); // 取得数组中所需元素 NSString *str = [arr1 lastObject]; NSLog(@"最后一个对象为 %@", str); str = [arr1 firstObject]; NSLog(@"第一个对象为 %@", str); str = [arr1 objectAtIndex: 3]; NSLog(@"第三个元素为 %@", str); // 查找某个对象为第几个下标, 不存在则 -1 int index = (int)[arr1 indexOfObject:@"3"]; NSLog(@"查找某个对象为第几个下标 %d", index); // 数组的遍历 1.for; 2. for in; 3.枚举迭代 // for 循环 注意类型问题 for (int i = 0; i &lt; arr1.count; i++) &#123; NSString *str1 = [arr1 objectAtIndex:i]; NSLog(@"for str1 = %@", str1); &#125; // 快速枚举 数组的元素类型要保持一致 for (NSString *str2 in arr1) &#123; NSLog(@"for in str2 = %@", str2); &#125; // 迭代枚举(慕课没有该点视频) [arr1 enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123; NSLog(@"id= %@", obj); &#125;];&#125;@end NSMutableArr 可变数组与可变字符串一样，数组也有可变的。一般项目中如果有修改数组的就用这个，如果不希望数组被修改则用不可变数组 NSMutableArrClass.m123456789101112131415161718192021222324252627282930313233343536373839404142434445//// NSMutableArrClass.m// foundation//// Created by Jsonz on 2017/4/26.// Copyright © 2017年 Jsonz. All rights reserved.//#import "NSMutableArrClass.h"@implementation NSMutableArrClass-(void)showArrFn&#123; NSMutableArray *array = [[NSMutableArray alloc] init]; NSString *str1 = @"bili"; // 添加元素 [array addObject: str1]; NSArray *arr1 = [[NSArray alloc] initWithObjects:@"1", @"2", @"3", @"4", @"5", nil]; [array addObject:arr1]; NSLog(@"array = %@", array); // 删除所有元素 [array removeAllObjects]; NSLog(@"删除后的 array = %@", array); [array addObject:arr1]; [array addObject: str1]; // 删除最后一个元素 [array removeLastObject]; NSLog(@"删除后的 array = %@", array); [array addObject: str1]; // 删除指定元素 [array removeObject:@"bili"]; NSLog(@"删除后的 array = %@", array); // 删除指定index的元素 [array removeObjectAtIndex:0]; NSLog(@"删除后的 array = %@", array); [array addObject:arr1]; [array addObject: str1]; // 交换元素位置 [array exchangeObjectAtIndex:1 withObjectAtIndex:0]; NSLog(@"交换后 %@", array);&#125;@end 字典 NSDictionary相当于js 里的对象{}. 新建一个类NSDic NSDictionary.h12345678910111213//// NSDictionary.h// foundation//// Created by Jsonz on 2017/4/26.// Copyright © 2017年 Jsonz. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@interface NSDic : NSObject-(void) showNSDictionaryFn;@end NSDictionary.m12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//// NSDictionary.m// foundation//// Created by Jsonz on 2017/4/26.// Copyright © 2017年 Jsonz. All rights reserved.//#import "NSDic.h"@implementation NSDic-(void) showNSDictionaryFn&#123; NSLog(@"test");// 字典： 相当于js的对象~ py的字典。 // 声明后不可以改 NSDictionary *dict1 = [NSDictionary dictionaryWithObject:@"1" forKey:@"a"]; NSLog(@"dict1 = %@", dict1); // 多个键值对 NSDictionary *dict2 = [NSDictionary dictionaryWithObjects:[NSArray arrayWithObjects:@"1", @"2", @"3", nil] forKeys:[NSArray arrayWithObjects:@"a", @"b", @"c", nil]]; NSLog(@"dict2 %@", dict2); // 简便写法 NSDictionary *dict3 = @&#123; @"1": @"a", @"2": @"b" &#125;; NSLog(@"dict3 %@", dict3); // 长度 int count = (int)[dict2 count]; NSLog(@"count %d", count); // 获取对应key的 value NSString *value = [dict2 valueForKey: @"b"]; NSLog(@"value = %@", value); NSString *value2 = [dict2 objectForKey: @"b"]; NSLog(@"value2 = %@", value2); // 数组 字典所有的值 NSArray *allValues = [dict2 allValues]; NSLog(@"allValues = %@", allValues); // 数组 所有的key NSArray *allKeys = [dict2 allKeys]; NSLog(@"allKeys = %@", allKeys); // 遍历 NSArray *array = [dict2 objectsForKeys:[NSArray arrayWithObjects: @"a", @"b", @"d", nil] notFoundMarker:@"Not Fount"]; NSLog(@"array = %@", array); // 遍历字典 for (NSString *key in dict2) &#123; NSLog(@"%@ = %@", key, [dict2 objectForKey:key]); &#125; // 枚举器 NSEnumerator *en = [dict2 keyEnumerator]; id key = nil; while (key = [en nextObject]) &#123; NSLog(@"key = %@", key); &#125; [dict2 enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123; NSLog(@"id = %@, obj = %@", key, obj); &#125;]; &#125;@end 可变字段 NSMutableDictionaryNSDic2.h12345678910111213//// NSDic2.h// foundation//// Created by Jsonz on 2017/4/26.// Copyright © 2017年 Jsonz. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@interface NSDic2 : NSObject-(void) showFn;@end NSDic2.m1234567891011121314151617181920212223242526272829303132333435//// NSDic2.m// foundation//// Created by Jsonz on 2017/4/26.// Copyright © 2017年 Jsonz. All rights reserved.//#import "NSDic2.h"@implementation NSDic2// 可变字典-(void) showFn&#123; NSMutableDictionary *dict = [[NSMutableDictionary alloc] init]; // 添加键值对 [dict setObject:@"1" forKey: @"a"]; [dict setObject: @"2" forKey: @"b"]; // 删除键值对 [dict removeObjectForKey:@"a"]; NSLog(@"dict 删除forKey %@", dict); // 删除所有 [dict removeAllObjects]; NSLog(@"dict 删除所有 %@", dict); [dict setObject:@"1" forKey: @"a"]; [dict setObject: @"2" forKey: @"b"]; [dict setObject: @"3" forKey: @"c"]; [dict removeObjectsForKeys: [NSArray arrayWithObjects:@"a", @"b", nil]]; NSLog(@"dict 批量删除 %@", dict); &#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Objective-C 面向对象初体验]]></title>
      <url>%2F2017%2F04%2FObjective-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
      <content type="text"><![CDATA[面向对象简介语言的面向对象都是换汤不换药 来来去去那几个概念 OOP（Object Oriented Programming) 基本概念 对象 （男人，女人，程序员） 抽象 - 类（人） 类和对象的关系 创建类(人)、得到对象（程序员） 成员变量： 内部使用，比如 大脑 眼睛 嘴 属性： 给外部使用 比如 职业 类的实例为对象 创建demo 同征战Objective-C一样 创建一个Command Line Tool 写示例代码 创建一个文件，类型为Cocoa Class,name: People, Subclass of: NSObject, language: Objective-C 。点击Next之后会生成两个文件 People.h,People.m。 引入与实例化在 main.m 里面引入文件并实例化对象, 后面如果没有特别说明， 都是在 main @autoreleasepool 里面写代码main.m12345678910111213141516171819#import &lt;Foundation/Foundation.h&gt;#import "People.h" // 引入类int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // 实例化对象 // 类名 对象名(星号代表是指针类型) = [[类名/对象名] 方法名] // People p1/p2 = [[People alloc] init] // alloc - 为对象分配内存空间 // init - 进行初始化操作 People *p1 = [[People alloc] init]; People *p2 = [[People alloc] init]; People *p3 = [People new]; // new 在Objective-C 用得少 NSLog(@"p1 - %p", p1); NSLog(@"p2 - %p", p2); NSLog(@"p3 - %p", p3); &#125; return 0;&#125; 创建成员变量与属性People.h12345678910// 姓名，年龄，性别// 类内使用成员变量(m)， 类外使用属性(h)@interface People : NSObject&#123;&#125;// 声明类的属性 声明后 main.m 就可以通过 p1.peopleName = @"Jsonz"; 访问修改属性// 属性就是成员变量的外部接口 h 文件写。外部使用//设置与获取Name@property(nonatomic, strong)NSString *peopleName;@end People.m1234567891011121314151617#import "People.h"// 成员变量 m 文件定义 内部使用@implementation People&#123; int _peopleAge; int _peopleSex;&#125;- (instancetype) init&#123; self = [super init]; if (self) &#123; _peopleName = @"张三"; // 成员变量 类内使用 &#125; return self;&#125;@end 此时main.m 可以使用peopleName属性 main.m12345// 属性的使用p1.peopleName = @"jsonz";p2.peopleName = @"李四";NSLog(@"p1.peopleName - %@", p1.peopleName);NSLog(@"p2.peopleName - %@", p2.peopleName); 函数加号方法 减号方法 的声明与调用在People.h 声明方法People.h123456789/** * - 、+ (减号代表对象方法，加号代表类方法) * 对象方法既是在实例上调用，而类方法则是在类上面调用，如: People *p1 = [[People alloc] init] * 此时 People是类， p1是对象 * h 文件进行声明， m 进行实现 */-(void) report; // 减号方法+(void) report1; // void 代表不用返回， +号方法-(int) returnInt; // 改变返回值的函数 在People.m实现该方法People.m1234567891011121314151617181920- (void) report&#123; NSLog(@"减号 Report"); // 如何在减号方法调加号方法 // [People report1]; &#125;static NSString *_peopleName1; // 静态变量，供加号方法内调用+(void) report1&#123; NSLog(@"加号 Report"); _peopleName1 = @"张三"; // 调用静态变量 不能调用成员变量 // 如何在加号方法调减号方法 // [[People alloc] report]&#125;-(int) returnInt&#123; // 前面是int，所以该函数必须返回一个int类型 return 0;&#125; 调用main.m123456People *p1 = [[People alloc] init][p1 report]; // 减号方法[People report1]; // 加号方法// [[People alloc] init]// [People alloc]会返回一个对象，这时候才能调用 init 所以 alloc是加号方法， init是减号方法 函数参数类型People.h 声明123// 函数参数问题-(int)showWithA: (int) a; // 有一个int类型参数 函数名为 `showWithA:`-(int)showWithA: (int)a andB:(int)b; // 有两个int类型参数 函数名为 `showWithA: andB:` People.m 实现123456789//参数问题-(int)showWithA:(int)a&#123; return a;&#125;-(int)showWithA:(int)a andB:(int)b&#123; return a + b;&#125; main.m 调用12345// 函数的参数使用int a1 = [p1 showWithA:10];int a2 = [p1 showWithA:20 andB:30];NSLog(@"a1 = %d", a1);NSLog(@"a2 = %d", a2); 初始化方法平时调用一个类的对象方法都是这么调用的 People *p1 = [[People alloc] init]， 但此时这个init具体做了什么事情，我们并不知道。 我们可以在类里面重写掉这个init 方法; People.h1234// 对于初始化方法来说 id || instancetype 没有区别，对于其他方法，一般 instancetype 比 id用的多// -(id)init; // 万能类型，可以返回各种类型对象-(instancetype)init; // 当前类的类型，比如当前类是People类型，那么instancetype就是People类型-(void) showPeopleProperty; // 定义一个方法来输出类的属性 People.m 重写init123456789101112131415161718192021// 如果此时提示 Duplicate declaration of method ‘init' 则代表你上面本来就声明了一个init 此时删除该init 或者把逻辑移到那个函数内即可// init 固有的模式- (instancetype) init&#123; self = [super init]; // 自己继承父级的 init 此处是 NSObject // 内部进行一些初始化的设定 if (self) &#123; _peopleName = @"Jsonz"; // 成员变量 类内使用 _peopleAge = 30; _peopleSex = 1; &#125; return self; // 返回自身&#125;// 输出People的对象初始化值-(void) showPeopleProperty&#123; NSLog(@"peopleName = %@", _peopleName); NSLog(@"peopleAge = %d", _peopleAge); NSLog(@"peopleAge = %d", _peopleSex);&#125; 接下来我们来自定义一个初始化的方法People.h1-(instancetype)initWithPeopleName:(NSString *) peopleName andPeopleAge:(int)peopleAge People.m123456789101112// 既然我们是自定义一个初始化方法，那也要按照初始化方法的写法，把一些结构给加上-(instancetupe)initWithPeopleName:(NSString *)peopleName andPeopleAge:(int)peopleAge&#123; // 初始化方法的结构 self = [super init]; if (self) &#123; _peopleName = peopleName; _peopleAge = peopleAge; &#125; return self;&#125; main.m1234// 自己实现的初始化方法People *pSelf = [[People alloc] initWithPeopleName:@"Jsonz" andPeopleAge: 23];NSLog(@"自己实现的init 的属性有哪些: ---- ");[pSelf showPeopleProperty]; 面向对象三部曲新建一个项目，避免学习太混乱 封装新建一个类，叫MyClassMyClass.h1234567891011121314151617181920#import &lt;Foundation/Foundation.h&gt;@interface MyClass : NSObject&#123; // 成员变量访问修饰符的问题 // 默认为 protected 受保护的 @public // 公有 - 在类内 类外都可以使用，并且可以被继承 int _classInt; @private // 私有 - 在类内可以使用， 类外无法调用 并且无法被继承 @protected // 受保护 - 默认的 在类内可以使用，类外无法调用 并且可以被继承 NSString *_classStr; @package // 框架权限 - 在框架内相当于受保护(可被调用与继承)， 在框架外相当于私有(类外无法使用与继承)&#125;@property(nonatomic, strong)NSString *className;// 方法是没有访问修饰符的， 同C语言一样。// 如果想要一个方法可以在类外可以使用，则要在h声明，m实现。// 如果不想在类外使用， 直接在m写实现， h 不写声明。-(void) report;@end MyClass.m12345678910#import "MyClass.h"@implementation MyClass-(void)report&#123; _classStr = @"ClassStr bilibilii"; NSLog(@"ClassName - %@", _className); NSLog(@"classInt - %d", _classInt);&#125;@end main.m12345678910111213141516#import &lt;Foundation/Foundation.h&gt;#import "MyClass.h"int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; MyClass *mc = [[MyClass alloc] init]; mc.className = @"我的类"; // 类外使用 public 成员变量 mc-&gt;_classInt = 1001; // 使用指向来调用类中的公有成员变量 [mc report]; &#125; return 0;&#125; 继承创建两个类 父类 ParentClass 子类 ChildClass, 创建的时候记得选上继承 ParentClass， 如果忘了选也没关系 后面手动修改一下就可以 ParentClass.h12345678910111213141516#import &lt;Foundation/Foundation.h&gt;// NSObject - 基类 此处的:(冒号)是代表继承关系@interface ParentClass : NSObject&#123; // 受保护变量 可继承 不可外部调用 int _classInt; // 私有变量 @private NSString *_classStr; &#125;@property(nonatomic, strong)NSString *className;-(void)report; // 如果此处不声明，则类外不能调。 子类也不继承@end ParentClass.m123456789101112#import "ParentClass.h"@implementation ParentClass-(void)report&#123; _classInt = 1002; _classStr = @"Jsonz's 私有变量"; NSLog(@"ClassName - %@", _className); NSLog(@"classInt - %d", _classInt); NSLog(@"classStr - %@", _classStr); // 此处在 ChildClass 中也会被打印出来，因为继承了该方法，所以会被打印&#125;@end ChildClass.h12345#import "ParentClass.h"@interface ChildClass : ParentClass-(void)show;@end ChildClass.m12345678910#import "ChildClass.h"@implementation ChildClass-(void)show&#123; _classInt = 1003; NSLog(@"show 此处_classInt 变化了 - %d", _classInt);// NSLog(@"show 打印父类的私有方法NSString %@", _classStr); 此处因为是父级的私有变量，所以外部无法访问&#125;@end main.m1234567891011// 调用// 父类ParentClass *pc = [[ParentClass alloc] init];pc.className = @"parentClass ClassName";[pc report];// 子类ChildClass *cc = [[ChildClass alloc] init];cc.className = @"ChildClass ClassName"; // 此处为父类继承过来的属性[cc show];[cc report]; // 此处还是1002 因为 cc中的 report 继承 pc 的report，此处重新复制了并打印。所以是1002 多态 方法重写 基于父类方法继承重写，返回值，函数名，参数等都一致 方法重载 (OC 不支持) 函数名一致，返回值 参数 参数类型等都不一致 创建一个类ColorPrint 用于演示多态，后面会基于 ParentClass, ChildClass 与ColorPrint 来说明多态。 父类实现一个打印机方法ParentClass.h1-(void) print; ParentClass.m1234-(void) print&#123; NSLog(@"普通打印机");&#125; 子类重写不需要声明，直接在m文件去重写实现即可ChildClass.m1234-(void)print&#123; NSLog(@"我是黑白打印机");&#125; ColorPrinter.m12345678-(void)print&#123; // 如果此处要调用父类的方法可以这么写： [super print]; // 调用当前类的方法可以用 self 父类可以用 super // [self print]; NSLog(@"我是彩色打印机");&#125; main.m12345678910// 调用ChildClass *cc = [[ChilClass alloc] init];[cc print]; // 黑白ColorPrinter *cc2 = [[ColorPrinter alloc] init];[cc2 print]; // 彩色打印机// 如果已经引入了子类的头文件，默认父类h文件（子类头文件所引入的头文件）也会被引入了。// 可以这么写ParentClass *color = [[ColorPrinter alloc] init];[color print]; // 此处也是才是打印机 demo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[征战Objective-C]]></title>
      <url>%2F2017%2F04%2F%E5%BE%81%E6%88%98Objective-C%2F</url>
      <content type="text"><![CDATA[Objective-C 下面简称OC 源代码文件扩展名对比一般来说，头文件是放声明， 实现文件放实现的代码 头文件 实现文件 c语言 .h .c c++语言 .h .cpp oc语言 .h .m oc&amp;c++ .h .mm 面向对象概览类的定义123// 当前的SimpleClass 继承 NSObject 类@interface SimpleClass: NSObject@end 类的属性申明12345678910111213141516@interface Person:NSObject@property NSString*firstName;@property NSString*lastName;@property NSNumber *yearOfBirth;@property int yearOfBirth;@property (readonly) NSString *firstName;@end 减号方法（普通方法又称对象方法）声明12345@interface Person: NSObject- (void) someMethod;- (void) someMethodWithValue: (SomeType)value;- (void) someMethodWithFirstValue: (SomeType)info1 secondValue: (AnotherType)info2;@end 加号方法 (类方法， 又称静态方法) 声明123456789@interface NSString: NSObject+(id)string;+(id)stringWithString:(NSString *)aString;+(id)stringWithFormat:(NSString *)format, ..;+(id)stringWithContentsOfFile: (NSString *)pathencoding: (NSStringEncoding)enc error:(NSError **)error;+(id)stringWithCString: (const char *)cStringencoding: (NSStringEncoding)enc;@end 类的实现123#import 'XYZPerson.h'@implementation XYZPerson@end 完成的例子XYZPerson.h 文件123@interface XYZPerson: NSObject-(void)sayHello;@end XYZPerson.m 文件1234567#import "XYZPerson.h"@implementation XYZPerson-(void)sayHello &#123; NSLog(@"Hello, World!");&#125;@end Hello World首先去app store 下载xCode. 打开xCode 选择左侧 Create a new Xcode project=&gt;macOS=&gt; Command Line Tool ，选择保存项目的位置。 进入项目后点击左上角箭头运行，如果下面控制台有输出 hello world 则代表运行成功了。 1234567#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // 真正开始写代码的地方 &#125; return 0;&#125; ObjectiveC 变量与表达式声明变量与简单运算12345int a = 0;int b = 1;b = 3;int c = a + b;NSLog(@"变量a+ b的值等于: %d", c); // %d 格式化输出，后面加个逗号再加变量 基础类型123456int int a = 0; 整数 占32位2进制float float a = 1.0; 浮点数 占32位2进制double double num; 双精度 占64位 可以保存更大的数char char c = 'A'; 单字符串 单引号NSString: @"Hello world" 使用比较多 双引号 (高级类型)C语言字符串类型 "hello world" 使用比较少 限定词12345long: long int a; 比int 更大的整形long long: long long int a; 比 long int 更大 具体应用才会涉及 比如大数据等short: short int a; short a; 小于或等于整形， 16位 比较省类型，但是比较少用这些，一般直接用 intunsigned: unsigned int a; 无符号signed: signed int a; 有符号(正负类型) 运算12345678910int a = 1;a++;++a;a--;--a;一元 ++, --,二元 +, -, *, /, %三元 2&gt;3?Yes:Not逻辑符号 &lt;, &gt;, &gt;=, &lt;=, ==, != if12345678// 如果是真的会返回 1，如果未假返回 0;if (True) &#123; // is True&#125; else &#123; // do something&#125;// 只要非0就是真的。if (1) NSLog(@"对"); else NSLog(@"错"); // 单行可以不写括号 goto语法1234567 int i = 0;a: &#123; i++; NSLog(@"i的值为 %d", i); // 先输出一个 i = 0;&#125; if (i &lt; 5) goto a; // 执行到这里i &lt; 5 跳转到a 去执行。 直到 i == 5 // 最后输出 0, 1, 2, 3, 4 while 循环 比较常用12345int a = 0;while ( a &lt; 5) &#123; a++; NSLog(@"a的变量是 %d", a);&#125; for循环 比较常用123for (int i= 0; i &lt; 10; i++) &#123; NSLog(@"i=%d", i);&#125; do while 肯定会执行一次再判断是否循环123do &#123; NSLog(@"hehe");&#125; while (0); break continue12break 可以在 循环中 退出循环continue 可以在 循环中 跳出当前循环，继续下一项循环 switch12345678910111213141516int i = 10.0; // char int float switch (i) &#123; case 1: NSLog(@"i = 1"); break; case 2: NSLog(@"i = 2"); break; case 10: NSLog(@"i = 10"); break; default: NSLog(@"i = 10.0"); &#125; // 最后会输出一个 10。 函数123456789101112131415161718192021// 求矩形面积的函数 s = a * b;// 返回的类型 函数名 ([(参数类型， 参数名)， (参数类型， 参数名)])double qiumianji(double a, double b) &#123; double s = a * b; return s;&#125;// 调用 main 函数内。// 一个相同类型的变量来接收返回值double s = qiumianji(10.0, 5.0);NSLog(@"s 的值为 %f", s); // %d 输出整数， %f 输出浮点数// 如果没有返回值，则调用函数的时候不用一个变量去接收void show() &#123; NSLog(@"this is a test !"); NSLog(@"this is a test2 !"); NSLog(@"this is a test3 !");&#125;// main 函数内调用show(); main函数中的默认参数12345NSLog(@"argc=%d", argc);// argv 参数为 命令行输入命令运行的参数如： les1 -h -c -a -l 则有5个参数[les1, -h, -c, -a, -l]for (int i =0; i &lt; argc; i++) &#123; NSLog(@"%s", argv[i]);&#125; 输出目前遇到的总结1234567NSLog(@"type %d", a); - %d int; - %s char *; - %f float;- %p 指针类型- %@ NSString- %ld 目前遇到过的有 NSRange.length || NSRange.location]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简单事件系统]]></title>
      <url>%2F2017%2F04%2F%E7%AE%80%E5%8D%95%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
      <content type="text"><![CDATA[最简单的事件系统 应该包含四个接口 on, off, once, trigger。 初始化方法1234567function E() &#123;&#125;E.prototype = &#123; on: function()&#123;&#125;, off: ..., trigger: ..., once: ...,&#125; on 事件绑定12345678on: function(name, cb, ctx) &#123; var e = this.e || (this.e = &#123;&#125;); (e[name] || (e[name] = [])).push(&#123; fn: cb, ctx: ctx &#125;); return this;&#125;, off 事件解绑1234567891011121314off: function(name, cb, ctx) &#123; var e = this.e || (this.e = &#123;&#125;); var evts = e[name]; var liveEvents = []; if (evts &amp;&amp; cb) &#123; for (var i= 0, len= evts.length; i&lt; len; i++) &#123; if (evts[i].fn !== cb &amp;&amp; evts[i].fn._ !== cb) liveEvents.push(evts[i]); &#125; &#125; (liveEvents.length) ? e[name] = liveEvents : delete e[name]; return this;&#125; once 绑定单次123456789once: function(name, cb, ctx) &#123; var self = this; function listener() &#123; self.off(name, listener); cb.apply(ctx, arguments); &#125; listener._ = cb; return this.on(name, listener, ctx);&#125; trigger 事件触发12345678910trigger: function(name) &#123; var data = [].slice.call(arguments, 1); var evtArr = ((this.e || (this.e = &#123;&#125;))[name] || []).slice(); var i = 0; var len = evtArr.length; for (i; i&lt; len; i++) &#123; evtArr[i].fn.apply(evtArr[i].ctx, data); &#125; return this;&#125; 简单的调用12345678910111213141516171819&lt;script src="./e.js"&gt;&lt;/script&gt;&lt;script&gt;var e = new E();e.on('bilibili', function() &#123; console.log('on');&#125;).once('once', function() &#123; console.log('once')&#125;).on('off', function() &#123; console.log('off')&#125;);window.addEventListener('load', function() &#123; document.body.addEventListener('click', function() &#123; e.trigger('off') .off('off') .trigger('bilibili') .trigger('once'); &#125;);&#125;)&lt;/script&gt; 最后附上源码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[复制黏贴板插件-CopyText]]></title>
      <url>%2F2017%2F04%2F%E5%A4%8D%E5%88%B6%E9%BB%8F%E8%B4%B4%E6%9D%BF%E6%8F%92%E4%BB%B6-CopyText%2F</url>
      <content type="text"><![CDATA[最近公司有个需求是要在移动端实现操作黏贴板功能，简单来说就是点击一个一个评论弹出菜单，其中有一个就是复制的选项。其中安卓和ios中的app还好，有原生提供接口，web端就要自己去实现了。 公司原本有一个copy的插件，但是亲测没效，找到github上面一些copy的插件用的start最高的是clipboard 截止此文有16k个start。 官方说明是 Modern copy to clipboard. No Flash. Just 3kb gzipped. 只有3k!而且官方插件提供的接口不是我想要的那种，遂有了造个自己用的小轮子念头。 简单思路创建一个虚拟的textarea 设置好样式让其显示在用户看不到的界面1234567891011121314151617181920212223selectFake() &#123; const isRTL = document.documentElement.getAttribute('dir'); this.removeFake(); this.fakeHandlerCallback = ()=&gt; this.removeFake(); this.fakeHandler = document.addEventListener('click', this.fakeHandlerCallback) || true; this.fakeEl = document.createElement('textarea'); let yPosition = window.pageYOffset || document.documentElement.scrollTo; styleFn(this.fakeEl, &#123; fontSize: '12pt', border: '0', margin: '0', padding: '0', position: 'absolute', [isRTL? 'right': 'left']: '-9999px', top: `$&#123;yPosition&#125;px`, &#125;); this.fakeEl.setAttribute('readonly', ''); this.fakeEl.value = this.text; document.body.appendChild(this.fakeEl); this.selectedText = this.selectDom(this.fakeEl); this.copyText(); &#125; 选择该dom，既选中textarea的文字区域1234567selectDom(el) &#123; let selectedText; el.select(); el.setSelectionRange(0, el.value.length); el.removeAttribute('readonly'); return el.value;&#125; 执行copy事件123456789copyText() &#123; let succeeded; try &#123; succeeded = document.execCommand('copy'); &#125; catch(e) &#123; succeeded = fale; &#125; this.handleResult(succeeded); // 事件回调处理&#125; 源码加注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/** * Created by Jsonz@github.com/jsonz1993 on 17/04/16 * CopyText 将文本copy到剪切板 支持pc &amp;&amp; web。 有兼容问题 H5 建议用原生copy接口 * @param &#123;Object&#125; options 配置参数 * @property &#123;String&#125; text 要复制的文本 * @property &#123;Function&#125; success 成功回调 * @property &#123;Function&#125; error 失败回调 * * CopyText.isSupported 判断当前环境是否支持copy事件 */export default class CopyText &#123; constructor(options) &#123; this.resolveOptions(options); this.init(); &#125; // 配置参数 resolveOptions(options= &#123;&#125;) &#123; this.text = options.text; this.successCb = typeof options.success === 'function'? options.success: ()=&gt; &#123;&#125;; this.errorCb = typeof options.error === 'function'? options.error: ()=&gt; &#123;&#125;; &#125; // 初始化函数 init() &#123; if (CopyText.isSupported()) this.selectFake(); else this.handleResult(false); &#125; // 创建虚拟dom &amp;&amp; copy selectFake() &#123; const isRTL = document.documentElement.getAttribute('dir'); this.removeFake(); this.fakeHandlerCallback = ()=&gt; this.removeFake(); this.fakeHandler = document.addEventListener('click', this.fakeHandlerCallback) || true; this.fakeEl = document.createElement('textarea'); let yPosition = window.pageYOffset || document.documentElement.scrollTo; styleFn(this.fakeEl, &#123; fontSize: '12pt', border: '0', margin: '0', padding: '0', position: 'absolute', [isRTL? 'right': 'left']: '-9999px', top: `$&#123;yPosition&#125;px`, &#125;); this.fakeEl.setAttribute('readonly', ''); this.fakeEl.value = this.text; document.body.appendChild(this.fakeEl); this.selectedText = this.selectDom(this.fakeEl); this.copyText(); &#125; // 移除虚拟dom removeFake() &#123; if (this.fakeHandler) &#123; document.body.removeEventListener('click', this.fakeHandlerCallback); this.fakeHandler = null; this.fakeHandlerCallback = null; &#125; if (this.fakeEl) &#123; document.body.removeChild(this.fakeEl); this.fakeEl = null; &#125; &#125; // 选择dom selectDom(el) &#123; let selectedText; el.select(); el.setSelectionRange(0, el.value.length); el.removeAttribute('readonly'); return el.value; &#125; // copy copyText() &#123; let succeeded; try &#123; succeeded = document.execCommand('copy'); &#125; catch(e) &#123; succeeded = fale; &#125; this.handleResult(succeeded); // 事件回调处理 &#125; // 回调 handleResult(succeeded) &#123; succeeded? this.successCb(): this.errorCb(); &#125; // 判断是否支持该事件 static isSupported(action= 'copy') &#123; return !!document.queryCommandSupported &amp;&amp; !!document.queryCommandSupported(action); &#125;&#125;const styleFn = (el, opts)=&gt; &#123; if (typeof opts !== 'object' || !el.nodeType) return; for (let key in opts) &#123; el.style[key] = opts[key]; &#125; return el;&#125; 使用方法12345678import CopyText from './CopyText';new CopyText(&#123; text: '文本复制', success() &#123;&#125;, error() &#123;&#125;&#125;);// 可以自行判断环境是否支持copy事件CopyText.isSupported() // Boolean]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sublime text 3 配置]]></title>
      <url>%2F2017%2F04%2Fsublime-text-3-%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[这篇博客主要讲怎么配置自己的sublime text， 安装可以去官网下载自行安装。 Package Control之后我们要安装Package Control, 既sublime的包管理工具 后面我们的包下载安装都用他。 按快捷键ctrl + ` 调出或者菜单view&gt; show Control 调出control 复制下面代码到control sublime Text 31import urllib.request,os,hashlib; h = &apos;2915d1851351e5ee549c20394736b442&apos; + &apos;8bc59f460fa1548d1514676163dafc88&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) sublime Text 21import urllib2,os,hashlib; h = &apos;df21e130d211cfc94d9b0905775a7c0f&apos; + &apos;1e3d39e33b79698005270310898eea76&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &apos;wb&apos; ).write(by) if dh == h else None; print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h) if dh != h else &apos;Please restart Sublime Text to finish installation&apos;) 复制完敲回车就可以安装，稍等片刻出现即可，安装完成后在 Preferences菜单下会出现 Package Control 选项 详细安装可看Package Control 插件打开 Package Control或按快捷键cmd/ctrl + shift + p， 输入 install package 选中第一个选项既进入安装插件的列表。 这时候可能需要等一会加载远程仓库，具体在左下角会有一个loading标识， 加载完在弹窗输入要安装的插件即可。 所有的插件都可以在https://packagecontrol.io/ 找到，下面列出比较常用的几个插件 Themesublime 编辑器虽然轻巧强大，但是默认的主题实在有点看不下去。主题可以在https://packagecontrol.io/browse/labels/theme 找自己喜欢的。目前个人使用的是 Material Theme 。 直接在install package 弹窗输入 Material Theme 选第一个即可（后面安装方法类似）。 安装完成后会弹出一个README，根据提示修改一下配置。打开Preferences &gt; settings &gt; User添加以下配置，保存即可生效12&quot;color_scheme&quot;: &quot;Packages/Material Theme/schemes/Material-Theme.tmTheme&quot;,&quot;theme&quot;: &quot;Material-Theme.sublime-theme&quot;, Material Theme 个人比较喜欢的主题还有 ayu Agila Theme Emmet前端工程师使用sublime编辑的必备插件，可以极大提高开发效率。最简单的应用就是在空白的.html页面输入!再按 tab键会自动生成html5基本页面解构。还有基本如 #div1&gt;span.child{这是子级}*2+button.name[disabled]{按钮}快捷语法等具体看emmet, Emmet-package SideBarEnhancementssublime 自带的侧边栏文件（夹）功能特别少，这个插件可以为其添加很多其他功能。docs BracketHighlighter前后标签高亮的插件，如[], (), {}, &quot;&quot;, &#39;&#39;, &lt;tag&gt;&lt;/tag&gt;等，可以比较方便看清代码块的起始点。docs AutoFileName按照路径提示该路径目录下的文件名，对于引入文件资源等很有帮助 All AutoComplete让代码自动完成的匹配从所有打开的文件里去匹配，而不是只在当前文件里匹配。 HTML-CSS-JS Prettifyhtml, css, js &amp;&amp; Json 的格式化插件。需要本地安装了node。默认格式化快捷键为ctrl+shift+h END基本上比较通用的插件就这些，可以发现这些插件基本上都在package Control前十位。学会举一反三，工作中用到的另一些插件再上https://packagecontrol.io/ 搜索关键字安装如 git, less, vuejs等等。 最后附上自己的配置12345678910111213141516&#123; "color_scheme": "Packages/Material Theme/schemes/Material-Theme-Lighter.tmTheme", "ignored_packages": [ "Vintage" ], "always_show_minimap_viewport": true, "theme": "Material-Theme-Lighter.sublime-theme", "word_wrap":true, "wrap_width": 120, "font_size": 10, "line_padding_bottom": 2, "line_padding_top": 2, "highlight_line":true, "font_face": "Monaco"&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[chrome插件开发]]></title>
      <url>%2F2017%2F04%2Fchrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[先放上入门的英语文档https://developer.chrome.com/extensions/getstarted 后面的教程是参照文档学习的。 新建配置文件首先创建一个manifest.json 用于整个项目的配置文件， 类似平时 js 的 package.json。 包含了项目的版本号， 项目名（扩展插件名）， 描述等。 12345678910111213141516171819202122232425262728293031&#123; "manifest_version": 2, "name": "Getting started example", "description": "This extension shows a Google Image search result for the current page", "version": "1.0", "browser_action": &#123; "default_icon": "icon.png", "default_popup": "popup.html" &#125;, "permissions": [ "activeTab", "https://ajax.googleapis.com/" ]&#125;&#123; "manifest_version": 2, // 版本号 "name": "Getting started example", // 项目名 "description": "This extension shows a Google Image search result for the current page", // 描述 "version": "1.0", // 项目版本号 "browser_action": &#123; "default_icon": "icon.png", // 默认icon "default_popup": "popup.html" // 默认弹窗 &#125;, "permissions": [ "activeTab", // "https://ajax.googleapis.com/" ]&#125; 资源文件在配置文件中我们定义了一个 default_icon 和 default_popup， 现在让我们来创建他们。 default_icondefault_icon 指向的是用于显示在工具栏的图标 可以选自己喜欢的图片，不过要选取 19px 的 .png文件。 可以用google提供的例子 icon.png popup.htmlpopup.html用于用户点击时弹出的一个操作框。为html 文件 所以你可以自己捣鼓自己想显示的东西。 可以用google提供的例子 popup.html 主要的逻辑以外部js的格式独立写在一个js文件里。 popup.js 现在你的文件夹里应该有四个文件: icon.png popup.html popup.js manifest.json 这些完成之后，我们接下来就在chrome加载我们的插件 加载插件调试chrome 访问 chrome://extensions 或手动从菜单进入 扩展程序 打开右上角的开发者模式 如果电脑没有装chrome….趁早装一个 点击加载已压缩的扩展程序，即可看到自己编写的第一个Hello Chrome 扩展插件此时双击审查代码可以调试写的插件。 附上后续学习链接https://developer.chrome.com/extensions]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[animate-text]]></title>
      <url>%2F2017%2F04%2Fanimate-text%2F</url>
      <content type="text"><![CDATA[animate-text文字动画和数字动画 animate text查看DEMO git仓库 轻巧的文字动画库, 使用简单, 文件大小4k可以给文字添加出现动画, 支持字符串打字效果和数字变化效果, 支持监听动画结束事件 项原项目地址, 这里对其代码改造优化。 使用方法12345678910111213141516import AnimateText from './animate-text'// 最简单的使用方法new AnimateText('.text')// 如果需要定义动画时间可以这样初始化new AnimateText('.text', 1000)// 如果还有其它设置 请这样写new AnimateText('.text', &#123; time: 1000, // 动画时长 isNumber: true, // 是否渲染为数字动画 startNumber: 0, // 渲染为数字动画时 动画的开始数字 changeCount: 32, // 数字动画数字变化次数 onAnimated: function () &#123;console.log('动画结束')&#125; // 动画结束事件回调&#125;) 参数说明AnimateText接收两个参数, 例如: new AnimateText(element, options) 参数 类型 是否必填 描述 element String or Object 是 可以是选择器或者dom节点对象(请保证这个节点内只有文本而没有其它节点) options Number or Object 否 如果第二个参数是数字, 则当作动画时间处理, 如果有其他参数, 以对象格式传递, 具体每个属性的描述请看下方的 options说明 options说明第二个参数options详细说明 参数 类型 默认值 是否必填 描述 time Number 500 否 动画持续的时间 isNumber Boolean false 否 是否渲染为数字动画 startNumber Number 0 否 数字动画的开始数字 changeCount Number 32 否 数字动画变化次数 也就是数字经过多少次跳动才变为最终数字 onAnimated Function null 否 动画结束监听函数 实例对象方法说明1234567// 实例化var animateText = new AnimateText('.text')// 实例化对象后 对象提供play方法重新播放动画// 接受参数作为动画时间// 不传递参数则使用实例化的时间animateText.play(1000)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-第三方服务集成]]></title>
      <url>%2F2017%2F04%2F%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90%2F</url>
      <content type="text"><![CDATA[静态站点拥有一定的局限性，因此我们需要借助于第三方服务来扩展站点的功能。 以下是 NexT 目前支持的第三方服务，你可以根据你的需求集成一些功能进来。 评论系统NexT 支持多款评论系统。如需取消某个 页面/文章 的评论，在 md 文件的 front-matter 中增加 comments: false 暂没开评论，多说准备下架。 站内搜索本站用 Hexo 提供的 Local Search， 原理是通过hexo-generator-search插件在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。 安装安装 hexo-generator-search1$ npm install hexo-generator-search 安装 hexo-generator-searchdb1$ npm install hexo-generator-searchdb --save 修改站点配置编辑 站点配置 根目录下的_config.yml.12345search: path: search.xml field: post format: html limit: 10000 站内搜索原文教程-EZLippi-浮生志]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[next-主题设置]]></title>
      <url>%2F2017%2F04%2Fnext-%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[下面的主题配置指的是 themes&gt;Next&gt;_config.yml, 站点配置指的是根目录下的_config.yml; 添加[标签]页面新建「标签」页面，并在菜单中显示「标签」链接。「标签」页面将展示站点的所有标签，若你的所有文章都未包含标签，此页面将是空的。 底下代码是一篇包含标签的文章的例子： 12345title: 标签测试文章tags: - Testing - Another Tag--- 新建tags页面使用hexo new page tags 新建一个页面，命名为tags:12$ cd you-hexo-site$ hexo new page tags 设置新建的tags页面类型，改为tags123456---title: tagsdate: 2017-04-03 11:35:36type: "tags"comments: false # tags页面自定义是否要开启评论（前提你已经集成了评论）--- 修改主题配置文件，把tag添加到menu中1234menu: home: / archives: /archives tags: /tags 添加[分类]页面新建「分类」页面，并在菜单中显示「分类」链接。「分类」页面将展示站点的所有分类，若你的所有文章都未包含分类，此页面将是空的。 底下代码是一篇包含分类的文章的例子： 123title: 分类测试文章categories: Testing--- 分类和标签的区别详见Hexo的分类与标签文档 新建页面在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 categories ：1234567891011$ cd your-hexo-site$ hexo new page categories``` #### 设置页面类型编辑刚新建的页面，将页面的 `type` 设置为 `categories` ，主题将自动为这个页面显示分类。页面内容如下：```ymltitle: 分类date: 2014-12-22 12:39:04type: "categories"--- 修改菜单在菜单中添加链接。编辑 主题配置文件 ， 添加 categories 到 menu 中，如下:1234menu: home: / archives: /archives categories: /categories 设置字体Next提供了5个特定范围的字体设定 全局字体：定义的字体将在全站范围使用 标题字体：文章内标题的字体（h1, h2, h3, h4, h5, h6） 文章字体：文章所使用的字体 Logo字体：Logo 所使用的字体 代码字体： 代码块所使用的字体 该配置中的 external 可以用来控制是否使用外链字体库。 开放此属性方便你设定那些已经安装在系统中的字体，减少不必要的请求（请求大小）。 设置代码高亮主题NexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是 白色的 normal 主题，可选的值有 normal，night， night blue， night bright， night eighties：可以自行更改 highlight_theme 字段， 设置成你自己喜欢的高亮主题。 侧边栏社交链接侧栏社交链接的修改包含两个部分，第一是链接，第二是链接图标。 两者配置均在 主题配置文件 中。 设置链接在 主题配置 中找到 social字段， 其格式为 显示文本: 链接地址。 scoial123social: Github: https://github.com/jsonz1993 微博: http://weibo.com/u/1638841204 设置图标在 主题配置 中找到 social_icons字段， 其格式为 匹配键: Font Awesome 图标名称。enable 为是否显示图标控制。 注意此时的匹配建要与 social的键一致,图标依旧是Font Awesome图标 站点建立时间这个时间将在站点的底部显示，例如 © 2013 - 2015。 编辑 主题配置文件，新增字段 since。 1since: 2013 设置「动画效果」NexT 默认开启动画效果，效果使用 JavaScript 编写，因此需要等待 JavaScript 脚本完全加载完毕后才会显示内容。 如果您比较在乎速度，可以将设置此字段的值为 false 来关闭动画。编辑 主题配置文件， 搜索 use_motion，根据您的需求设置值为 true 或者 false 即可：1use_motion: true # 开启动画 设置「背景动画」NexT 自带两种背景动画效果 编辑 主题配置文件， 搜索 canvas_nest 或 three_waves，根据您的需求设置值为 true 或者 false 即可：只能同时开启一种背景效果， 建议酌情开启，会影响电脑网页性能(macbook pro或笔记本容易出现过热现象).12canvas_nest: false //关闭动画three_waves: true //开启动画]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hello next]]></title>
      <url>%2F2017%2F04%2Fhellp-next%2F</url>
      <content type="text"><![CDATA[next 入门配置 主题安装下面Next下的_config称主题配置， 根目录Hexo的_config称站点配置 安装next 到目录 themes/next:注意安装完themes下应该有一个 next 文件夹1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启动主题修改 站点配置:1theme: next 验证主题先清除缓存再启动服务，启动完成后打开 http://localhost:4000/1$ hexo clean &amp;&amp; hexo s 主题设定选择SchemeScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。在主题配置配置中的Scheme选项。目前提供三种方案： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 目前使用的是 scheme: Mist方案 设置语言在站点配置 language 中设置 zh-Hans (简体中文)。支持的语言可在 themes/next/languages 中查看 设置菜单菜单格式为 item name: link此处只是将 url映射到对应 菜单上，若要具体显示文案需要到语言配置文件修改123456menu: home: / # 主页 categories: /categories # 分类 archives: /archives # 归档 tags: /tags # 标签 about: /about # 关于我 设置菜单图标图标可从http://fontawesome.io/选择123456789menu_icons: enable: true # 是否显示图标 # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 设置侧栏 设置侧栏位置：主题配置 修改 sidebar.position 的值，支持 left &amp; right但目前只有Pisces Scheme支持该设置 设置侧栏显示的时机主题配置 修改 sidebar.display，目前支持的有： post 默认行文，文展页面自动展开 首页等不自动展开 always 所有页面都自动展开 hide 所有页面都隐藏，可以手动展开 remove 完全移除 设置头像主题配置 修改 avatar字段。支持互联网URI 如 https://www.img.com/img.jpg或站内地址 /images/avatar.jpg 集成第三方服务百度统计 登录百度统计， 定位到站点的代码获取页面 复制 hm.js? 后面那串统计脚本 id，如:hm.src = &quot;https://hm.baidu.com/hm.js?dksjklsajdlkasjkl&quot;;则id = dksjklsajdlkasjkl 修改主题配置 baidu_analytics 字段，改为上述id 骚等一段时间后可以自行登录百度统计查看PV,UV等数据。 文章阅读量统计为Next主题添加文章阅读量]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo-辅助函数]]></title>
      <url>%2F2017%2F04%2Fhexo-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[主要用于模板中辅助的函数，如 date(Date, &#39;YYYY-DD-MM&#39;) 详见https://hexo.io/zh-cn/docs/helpers.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo-变量]]></title>
      <url>%2F2017%2F04%2Fhexo-%E5%8F%98%E9%87%8F%2F</url>
      <content type="text"><![CDATA[变量主要用于 layout 等的应用 全局变量 变量 描述 site 网站变量 page 针对该页面的内容以及 front-matter 所设定的变量。 config 网站配置 theme 主题配置。继承自网站配置。 _ (单下划线) Lodash 函数库 path 当前页面的路径（不含根路径） url 当前页面的完整网址 env 环境变量 网站变量 变量 描述 site.posts 所有文章 site.pages 所有分页 site.categories 所有分类 site.tags 所有标签 页面变量页面page 变量 描述 page.title 页面标题 page.date 页面建立日期（Moment.js 对象） page.updated 页面更新日期（Moment.js 对象） page.comments 留言是否开启 page.layout 布局名称 page.content 页面的完整内容 page.excerpt 页面摘要 page.more 除了页面摘要的其余内容 page.source 页面原始路径 page.full_source 页面的完整原始路径 page.path 页面网址（不含根路径）。我们通常在主题 中使用 url_for(page.path)。 page.permalink 页面的完整网址 page.prev 上一个页面。如果此为第一个页面则为 null。 page.next 下一个页面。如果此为最后一个页面则为 null。 page.raw 文章的原始内容 page.photos 文章的照片（用于相簿） page.link 文章的外部链接（用于链接文章） 文章post与page类似 但是添加了下列变量 变量 描述 page.published 如果该文章已发布则为True page.categories 该文章的所有分类 page.tags 该文章的所有标签 首页 index 变量 描述 page.per_page 每页显示的文章数量 page.total 总文章数 page.current 目前页数 page.current_url 目前分页的网址 page.posts 本页文章 page.prev 上一页的页数。如果此页是第一页的话则为 0。 page.prev_link 上一页的网址。如果此页是第一页的话则为 ‘’。 page.next 下一页的页数。如果此页是最后一页的话则为 0。 page.next_link 下一页的网址。如果此页是最后一页的话则为 ‘’。 page.path 当前页面的路径（不含根目录）。我们通常在主题中使用 url_for(page.path)。 归档 (archive)与 index 布局相同， 但新增了以下变量 变量 描述 page.archive 等于 true page.year 年份归档 (4位) page.month 月份归档 (没有前导零的2位数) 分类 (category)与 index 布局相同， 但新增了以下变量 变量 描述 page.category 分类名称 标签(tag)与 index 布局相同， 但新增了以下变量 变量 描述 page.tag 标签名称]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo-模板]]></title>
      <url>%2F2017%2F04%2Fhexo-%E6%A8%A1%E6%9D%BF%2F</url>
      <content type="text"><![CDATA[模板决定了网站内容的呈现方式，每个主题至少都应包含一个 index 模板，以下是各页面相对应的模板名称： 模板 用途 回调 index 首页 post 文章 index page 分页 index archive 归档 index category 分类归档 archive tag 标签归档 archive 布局 Layout布局这块可参考 next 主题看, Hexo 默认的引擎模板为swig 如果页面结构类似，例如两个模板都有页首（Header）和页脚（Footer），您可考虑通过「布局」让两个模板共享相同的结构。一个布局文件必须要能显示 body 变量的内容，如此一来模板的内容才会被显示，举例来说： index.ejs1index layout.ejs1234&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt;&lt;%- body %&gt;&lt;/body&gt;&lt;/html&gt; 生成1234&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt;index&lt;/body&gt;&lt;/html&gt; 每个模板都默认使用 layout 布局，您可在 front-matter 指定其他布局，或是设为 false 来关闭布局功能，您甚至可在布局中再使用其他布局来建立嵌套布局。 局部模板 Partial局部模板让您在不同模板之间共享相同的组件，例如页首（Header）、页脚（Footer）或侧边栏（Sidebar）等，可利用局部模板功能分割为个别文件，让维护更加便利。 官网说的都是ejs语法， 目前next采用的是swig 语法。 TODO 后面再补上 Next主题学习 &amp;&amp; swig]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo-主题概述]]></title>
      <url>%2F2017%2F04%2Fhexo-%E4%B8%BB%E9%A2%98%E6%A6%82%E8%BF%B0%2F</url>
      <content type="text"><![CDATA[了解一款主题的文件结构可以让你在有自定义需求的时候，快速定位到目标文件，也为后面的定制化主题做铺垫。 创建 Hexo 主题非常容易，您只要在 themes 文件夹内，新增一个任意名称的文件夹，并修改 _config.yml 内的 theme 设定，即可切换主题。一个主题可能会有以下的结构： 123456.├── _config.yml├── languages├── layout├── scripts└── source _config.yml主题的配置文件。修改时会自动更新，无需重启服务器。 languages语言文件夹。请参见 国际化 (i18n)。 layout布局文件夹。用于存放主题的模板文件，决定了网站内容的呈现方式，Hexo 内建 Swig 模板引擎，您可以另外安装插件来获得 EJS、Haml 或 Jade 支持，Hexo 根据模板文件的扩展名来决定所使用的模板引擎，例如：12layout.ejs - 使用 EJSlayout.swig - 使用 Swig 详细见 模板 scripts脚本文件夹。在启动时，Hexo 会载入此文件夹内的 JavaScript 文件，详细见 插件 。 source资源文件夹，除了模板以外的 Asset，例如 CSS、JavaScript 文件等，都应该放在这个文件夹中。文件或文件夹开头名称为 _（下划线线）或隐藏的文件会被忽略。 如果文件可以被渲染的话，会经过解析然后储存到 public 文件夹，否则会直接拷贝到 public 文件夹 发布（略）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo-永久链接]]></title>
      <url>%2F2017%2F04%2Fhexo-%E6%B0%B8%E4%B9%85%E9%93%BE%E6%8E%A5%2F</url>
      <content type="text"><![CDATA[你可以在_config.yml &gt; permalink配置网站的永久链接或者每篇文章的Front-matter自定义该文章的永久链接, 如: :year/:month/:title/ 对应 2017/04/hexo-永久链接/ 变量除了下列变量外，您还可使用 Front-matter 中的所有属性。 变量 描述 :year 文章的发表年份（4 位数） :month 文章的发表月份（2 位数） :i_month 文章的发表月份（去掉开头的零） :day 文章的发表日期 (2 位数) :i_day 文章的发表日期（去掉开头的零） :title 文件名称 :id 文章 ID :category 分类。如果文章没有分类，则是 default_category 配置信息。 也可以在 permalink_defaults 参数下调整永久链接中各变量的默认值：12permalink_defaults: lang: en]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-生成文件与部署]]></title>
      <url>%2F2017%2F04%2F%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6%E4%B8%8E%E9%83%A8%E7%BD%B2%2F</url>
      <content type="text"><![CDATA[生成文件生成文件一般是用于生成静态资源文件部署服务器用的 12345$ hexo generate快捷方式为:$hexo g 也可以让Hexo在监视到文件变动后立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。1$ hexo generate --watch 一般会跑以下命令，方便在Hexo生成文件后直接部署到Github上123456789$ hexo generate --deploy$ hexo deploy --generate(上面两条命令效果一样)或者简写$ hexo g -d$ hexo d -g(上面两条命令效果一样) 部署服务器在部署之前先要在 _config.yml 将部署信息补充完整，此处以 Github 为例: _config.yml配置12345deploy: type: git # type repo: https://github.com/jsonz1993/jsonz1993.github.io.git # 仓库地址 branch: master # 分支 可不填自动识别 message: "feat(hexo)-生成文件与部署" # 提交的信息 参数说明123repo 库（Repository）地址branch 分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。message 自定义提交信息 (默认为 Site updated: &#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125;) 确保本地安装了 hexo-deployer-git， 可通过以下方法安装1$ npm install hexo-deployer-git --save 你也可以通过 generate 生成静态资源，再手动copy或上传到服务器.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-本地服务器]]></title>
      <url>%2F2017%2F04%2F%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
      <content type="text"><![CDATA[一般安装hexo时会自动安装服务器，如果本地没有安装hexo服务器可通过以下命令安装：1$ npm install hexo-server --save 安装完成后，启动服务器，会启动一个（默认4000端口）本地服务器，可通过 http://localhost:4000 访问，Hexo会监视文件变动自动更新，如果是改动配置，需要手动重启服务：1$ hexo server 缩写1$ hexo s 如果您想要更改端口，或是在执行时遇到了 EADDRINUSE 错误，可以在执行时使用 -p 选项指定其他端口，如下：1$ hexo server -p 5000 自定义IP服务器默认运行在 0.0.0.0，您可以覆盖默认的 IP 设置，如下：1$ hexo server -i 192.168.1.1 指定这个参数后，您就只能通过该IP才能访问站点。例如，对于一台使用无线网络的笔记本电脑，除了指向本机的127.0.0.1外，通常还有一个192.168.*.*的局域网IP，如果像上面那样使用-i参数，就不能用127.0.0.1来访问站点了。对于有公网IP的主机，如果您指定一个局域网IP作为-i参数的值，那么就无法通过公网来访问站点。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-资源文件夹与数据文件夹]]></title>
      <url>%2F2017%2F04%2F%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%A4%B9%2F</url>
      <content type="text"><![CDATA[资源文件资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 ![](/images/image.jpg) 的方法访问它们。 文章资源文件夹可以通过设置 _config.yml 来使生成的每个文章都有对应的静态资源文件夹。 _config.yml1post_asset_folder: true 数据文件有时您可能需要在主题中使用某些资料，而这些资料并不在文章内，并且是需要重复使用的，那么您可以考虑使用 Hexo 3.0 新增的「数据文件」功能。此功能会载入 source/_data 内的 YAML 或 JSON 文件，如此一来您便能在网站中复用这些文件了。 举例来说，在 source/_data 文件夹中新建 menu.yml 文件： 123Home: /Gallery: /gallery/Archives: /archives/ 您就能在模板中使用这些资料： 123&#123;% for link in site.data.menu %&#125; &lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot;&gt;&#123;&#123; loop.key &#125;&#125;&lt;/a&gt;&#123;% endfor %&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[tag plugins]]></title>
      <url>%2F2017%2F04%2Ftag-plugins%2F</url>
      <content type="text"><![CDATA[tag plugins 用于在文章中快速插入特定内容的插件,下面列出常用几种 具体参见https://hexo.io/zh-cn/docs/tag-plugins.html 引用快在文章中插入引言，可包含作者、来源和标题。123&#123;% blockquote @Jsonz http://weibo.com/u/1638841204 %&#125;引用内容&#123;% endblockquote %&#125; 引用内容 @Jsonzweibo.com/u/1638841204 代码块样式可以在 themes&gt;next&gt;source&gt;css修改[language] [title] [url] [link text] code snippet 这是标题,Jsonz's Github1234const a = ()=&gt; &#123; [..."123"].forEach(item=&gt; ++item); return &#123;&#125;;&#125; iframe1&#123;% iframe url [width] [height] %&#125; image插入指定大小图片 1&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hello Hexo]]></title>
      <url>%2F2017%2F04%2Fhello-hexo%2F</url>
      <content type="text"><![CDATA[折腾了一晚上终于把搭好自己喜欢的主题的Hexo博客。接下来一步一步配置 Hexo __config.yml 文件Hexo 官网配置项 一步一步跟着改配置，比较麻烦的是每次修改配置都要hexo s 重启一下服务器看效果如果修改配置后重启服务看不到效果，可以先运行hexo clean清除缓存再重启服务 Site 网站123456title: jsonz1993 # 网站标题，也会显示在该主题导航左上角subtitle: # 网站副标题 会生成在导航栏主标题旁边（这里隐藏了）description: 前端开发 Jsonz 张欣欣 # 网站描述，会出现在head，侧边菜单上 主要用做SEOauthor: Jsonz # 博客作者 Your Namelanguage: zh-Hans # 语言，支持的语言可以在themes&gt;your-thems&gt;languages 找到timezone: # 默认使用电脑的时区，一般不填 URL 网址123456url: https://jsonz1993.github.io/root: /# 文章永久链接的格式 [https://hexo.io/zh-cn/docs/permalinks.html]# 可以使用的变量有[:year, :month, :day, :title, :id, :category, Front-matter所有属性]permalink: :year/:month/:day/:title/ permalink_defaults: # 可以给变量指定默认值 Directory 目录123456789# 定义文件目录, 这部分一般用默认的就可以source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render: Writing 文章相关配置123456789101112131415161718# 新文章的名称 我喜欢配合年月按文件夹分类，这样后面方便管理# 此时生成的文件位于: source/_posts/:year/:month/:title.mdnew_post_name: :year/:month/:title.md default_layout: post #命令行 hexo new &lt;layout&gt; name 中 layout默认值titlecase: false # 标题转换为首字母大写external_link: true # 是否在新标签打开连接filename_case: 0 # 文件名大小写转换 (0)不转换（1)小写 (2)大写render_drafts: false # 显示草稿# 启动资源文件夹 看个人可用可不用# 主要每次创建文件都会生成一个同名文件夹用于存放图片等资源post_asset_folder: truerelative_link: false # 把链接改为与根目录的相对位址future: true # 显示下一条文章highlight: # 代码块设置 既现在看到的这块 enable: true line_number: true auto_detect: false tab_replace: Category &amp; Tag 分类&amp;标签123default_category: uncategorized # 默认的分类category_map: # 分类映射（别名）tag_map: # 标签映射（别名） Date / Time format 日期&amp;时间格式12date_format: YYYY-MM-DDtime_format: HH:mm:ss Pagination 分页设置123# 文章数量有限，未实践过该功能per_page: 10 # 每页文章数量 0 为关闭分页pagination_dir: page # 分页的目录 Extensions 其他拓展设置12# 此处有插件与主题设置theme: next #设置的主题应存放在 根目录/themes下 将草稿转为文章1hexo publish [layout] &lt;filename&gt;]]></content>
    </entry>

    
  
  
</search>
